# 1 "c:/devl/prboom3ds/src/m_menu.c"
# 1 "c:\\devl\\prboom3ds\\build//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "c:/devl/prboom3ds/src/m_menu.c"
# 38 "c:/devl/prboom3ds/src/m_menu.c"
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 1 3
# 29 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\_ansi.h" 1 3
# 15 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\_ansi.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\newlib.h" 1 3
# 16 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\_ansi.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\config.h" 1 3



# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\ieeefp.h" 1 3
# 5 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\config.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\features.h" 1 3
# 6 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\config.h" 2 3
# 17 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\_ansi.h" 2 3
# 30 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3





# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 212 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 36 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3


# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdarg.h" 1 3 4
# 40 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3







# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 1 3
# 13 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\_ansi.h" 1 3
# 14 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 147 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 324 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 3 4
typedef unsigned int wchar_t;
# 15 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 1 3
# 12 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_types.h" 1 3






# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 1 3
# 27 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
# 37 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef short int __int16_t;
typedef short unsigned int __uint16_t;
# 55 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef long int __int32_t;
typedef long unsigned int __uint32_t;
# 77 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef long long int __int64_t;
typedef long long unsigned int __uint64_t;
# 104 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef signed char __int_least8_t;
typedef unsigned char __uint_least8_t;
# 126 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef short int __int_least16_t;
typedef short unsigned int __uint_least16_t;
# 144 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef long int __int_least32_t;
typedef long unsigned int __uint_least32_t;
# 158 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef long long int __int_least64_t;
typedef long long unsigned int __uint_least64_t;
# 168 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_default_types.h" 3
typedef int __intptr_t;
typedef unsigned int __uintptr_t;
# 8 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\_types.h" 2 3
# 13 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\lock.h" 1 3





typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
# 14 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 2 3


typedef long _off_t;



typedef int __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



__extension__ typedef long long _off64_t;







typedef long _fpos_t;
# 55 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 3
typedef signed int _ssize_t;
# 67 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 3
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 353 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 3 4
typedef unsigned int wint_t;
# 68 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_types.h" 2 3



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;



typedef _LOCK_RECURSIVE_T _flock_t;




typedef void *_iconv_t;
# 16 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 2 3






typedef unsigned long __ULong;
# 38 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct _reent;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};







struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 91 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
# 115 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 179 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  int (* _read) (struct _reent *, void *, char *, int)
                                          ;
  int (* _write) (struct _reent *, void *, const char *, int)

                                   ;
  _fpos_t (* _seek) (struct _reent *, void *, _fpos_t, int);
  int (* _close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 285 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
typedef struct __sFILE __FILE;



struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};
# 317 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};
# 569 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];

  int _current_category;
  const char *_current_locale;

  int __sdidinit;

  void (* __cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {
          unsigned int _unused_rand;
          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
        } _reent;



      struct
        {

          unsigned char * _nextf[30];
          unsigned int _nmalloc[30];
        } _unused;
    } _new;



  struct _atexit *_atexit;
  struct _atexit _atexit0;



  void (**(_sig_func))(int);




  struct _glue __sglue;
  __FILE __sf[3];
};
# 762 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\reent.h" 3
extern struct _reent *_impure_ptr ;
extern struct _reent *const _global_impure_ptr ;

void _reclaim_reent (struct _reent *);
# 47 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 1 3
# 69 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 70 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\types.h" 1 3
# 19 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\types.h" 3
typedef long int __off_t;
typedef int __pid_t;

__extension__ typedef long long int __loff_t;
# 71 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 2 3
# 93 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef unsigned char u_char;



typedef unsigned short u_short;



typedef unsigned int u_int;



typedef unsigned long u_long;





typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;



typedef unsigned long clock_t;




typedef long time_t;







struct timespec {
  time_t tv_sec;
  long tv_nsec;
};


struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};


typedef long daddr_t;



typedef char * caddr_t;
# 155 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef unsigned int ino_t;
# 184 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef _off_t off_t;
typedef __dev_t dev_t;
typedef __uid_t uid_t;
typedef __gid_t gid_t;





typedef int pid_t;







typedef long key_t;

typedef _ssize_t ssize_t;
# 217 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef unsigned int mode_t __attribute__ ((__mode__ (__SI__)));




typedef unsigned short nlink_t;
# 244 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef long fd_mask;







typedef struct _types_fd_set {
 fd_mask fds_bits[(((64)+(((sizeof (fd_mask) * 8))-1))/((sizeof (fd_mask) * 8)))];
} _types_fd_set;
# 275 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\types.h" 3
typedef unsigned long clockid_t;




typedef unsigned long timer_t;



typedef unsigned long useconds_t;
typedef long suseconds_t;

typedef __uint32_t fsblkcnt_t;
typedef __uint32_t fsfilcnt_t;
# 48 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3



typedef __FILE FILE;




typedef _fpos_t fpos_t;





# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stdio.h" 1 3
# 63 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 2 3
# 162 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);
int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *__restrict, const char *__restrict, FILE *__restrict);
void setbuf (FILE *__restrict, char *__restrict);
int setvbuf (FILE *__restrict, char *__restrict, int, size_t);
int fprintf (FILE *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fscanf (FILE *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int printf (const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int scanf (const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int sscanf (const char *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int vfprintf (FILE *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int vsprintf (char *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int fgetc (FILE *);
char * fgets (char *__restrict, int, FILE *__restrict);
int fputc (int, FILE *);
int fputs (const char *__restrict, FILE *__restrict);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void * __restrict, size_t _size, size_t _n, FILE *__restrict);
size_t fwrite (const void * __restrict , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *__restrict, fpos_t *__restrict);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *__restrict _name, const char *__restrict _type);
int sprintf (char *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int remove (const char *);
int rename (const char *, const char *);
# 230 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
int fseeko (FILE *, off_t, int);
off_t ftello ( FILE *);




int asiprintf (char **, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
char * asniprintf (char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * asnprintf (char *__restrict, size_t *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int asprintf (char **__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int diprintf (int, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

int fcloseall (void);
int fiprintf (FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int fiscanf (FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int iprintf (const char *, ...) __attribute__ ((__format__ (__printf__, 1, 2)))
                                                            ;
int iscanf (const char *, ...) __attribute__ ((__format__ (__scanf__, 1, 2)))
                                                           ;
int siprintf (char *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int siscanf (const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int snprintf (char *__restrict, size_t, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int sniprintf (char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * tempnam (const char *, const char *);
int vasiprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
char * vasniprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * vasnprintf (char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vasprintf (char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vdiprintf (int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiprintf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vfiscanf (FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vfscanf (FILE *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int viprintf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 1, 0)))
                                                            ;
int viscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vscanf (const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 1, 0)))
                                                           ;
int vsiprintf (char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int vsiscanf (const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int vsniprintf (char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsnprintf (char *__restrict, size_t, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int vsscanf (const char *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
# 307 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
FILE * fdopen (int, const char *);

int fileno (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE * popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
int getc_unlocked (FILE *);
int getchar_unlocked (void);
void flockfile (FILE *);
int ftrylockfile (FILE *);
void funlockfile (FILE *);
int putc_unlocked (int, FILE *);
int putchar_unlocked (int);
# 332 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
int dprintf (int, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;

FILE * fmemopen (void *__restrict, size_t, const char *__restrict);


FILE * open_memstream (char **, size_t *);



int vdprintf (int, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;







int _asiprintf_r (struct _reent *, char **, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
char * _asnprintf_r (struct _reent *, char *__restrict, size_t *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _asprintf_r (struct _reent *, char **__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _diprintf_r (struct _reent *, int, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _dprintf_r (struct _reent *, int, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *__restrict, int, FILE *__restrict);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fiscanf_r (struct _reent *, FILE *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
FILE * _fmemopen_r (struct _reent *, void *__restrict, size_t, const char *__restrict);
FILE * _fopen_r (struct _reent *, const char *__restrict, const char *__restrict);
FILE * _freopen_r (struct _reent *, const char *__restrict, const char *__restrict, FILE *__restrict);
int _fprintf_r (struct _reent *, FILE *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *__restrict, FILE *__restrict);
size_t _fread_r (struct _reent *, void * __restrict, size_t _size, size_t _n, FILE *__restrict);
int _fscanf_r (struct _reent *, FILE *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void * __restrict, size_t _size, size_t _n, FILE *__restrict);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _iscanf_r (struct _reent *, const char *, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 2, 3)))
                                                            ;
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *, const char *_old, const char *_new)
                                          ;
int _scanf_r (struct _reent *, const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 2, 3)))
                                                           ;
int _siprintf_r (struct _reent *, char *, const char *, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _siscanf_r (struct _reent *, const char *, const char *, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _snprintf_r (struct _reent *, char *__restrict, size_t, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 4, 5)))
                                                            ;
int _sprintf_r (struct _reent *, char *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__printf__, 3, 4)))
                                                            ;
int _sscanf_r (struct _reent *, const char *__restrict, const char *__restrict, ...) __attribute__ ((__format__ (__scanf__, 3, 4)))
                                                           ;
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vdprintf_r (struct _reent *, int, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vfprintf_r (struct _reent *, FILE *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vfscanf_r (struct _reent *, FILE *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vprintf_r (struct _reent *, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 2, 0)))
                                                            ;
int _vscanf_r (struct _reent *, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 2, 0)))
                                                           ;
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsnprintf_r (struct _reent *, char *__restrict, size_t, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 4, 0)))
                                                            ;
int _vsprintf_r (struct _reent *, char *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__printf__, 3, 0)))
                                                            ;
int _vsscanf_r (struct _reent *, const char *__restrict, const char *__restrict, __gnuc_va_list) __attribute__ ((__format__ (__scanf__, 3, 0)))
                                                           ;



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 509 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 533 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3
FILE *funopen (const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))





                                   ;
FILE *_funopen_r (struct _reent *, const void * __cookie, int (*__readfn)(void * __cookie, char *__buf, int __n), int (*__writefn)(void * __cookie, const char *__buf, int __n), fpos_t (*__seekfn)(void * __cookie, fpos_t __off, int __whence), int (*__closefn)(void * __cookie))





                                   ;







typedef ssize_t cookie_read_function_t(void *__cookie, char *__buf, size_t __n);
typedef ssize_t cookie_write_function_t(void *__cookie, const char *__buf,
     size_t __n);




typedef int cookie_seek_function_t(void *__cookie, off_t *__off, int __whence);

typedef int cookie_close_function_t(void *__cookie);
typedef struct
{


  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
FILE *fopencookie (void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
FILE *_fopencookie_r (struct _reent *, void *__cookie, const char *__mode, cookie_io_functions_t __functions)
                                                         ;
# 685 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdio.h" 3

# 39 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\fcntl.h" 1 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\fcntl.h" 1 3



# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_default_fcntl.h" 1 3
# 154 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_default_fcntl.h" 3
struct flock {
 short l_type;
 short l_whence;
 long l_start;
 long l_len;
 short l_pid;
 short l_xxx;
};




struct eflock {
 short l_type;
 short l_whence;
 long l_start;
 long l_len;
 short l_pid;
 short l_xxx;
 long l_rpid;
 long l_rsys;
};




# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 1 3
# 9 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 1 3
# 15 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 3
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 16 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 2 3


# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\time.h" 1 3
# 19 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 2 3
# 29 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 3


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
};

clock_t clock (void);
double difftime (time_t _time2, time_t _time1);
time_t mktime (struct tm *_timeptr);
time_t time (time_t *_timer);

char *asctime (const struct tm *_tblock);
char *ctime (const time_t *_time);
struct tm *gmtime (const time_t *_timer);
struct tm *localtime (const time_t *_timer);

size_t strftime (char *__restrict _s, size_t _maxsize, const char *__restrict _fmt, const struct tm *__restrict _t)

                                        ;

char *asctime_r (const struct tm *__restrict, char *__restrict)
                       ;
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *__restrict, struct tm *__restrict)
                            ;
struct tm *localtime_r (const time_t *__restrict, struct tm *__restrict)
                            ;








char *strptime (const char *__restrict, const char *__restrict, struct tm *__restrict)

                            ;
void tzset (void);
void _tzset_r (struct _reent *);

typedef struct __tzrule_struct
{
  char ch;
  int m;
  int n;
  int d;
  int s;
  time_t change;
  long offset;
} __tzrule_type;

typedef struct __tzinfo_struct
{
  int __tznorth;
  int __tzyear;
  __tzrule_type __tzrule[2];
} __tzinfo_type;

__tzinfo_type *__gettzinfo (void);
# 123 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\time.h" 3
extern long _timezone;
extern int _daylight;
extern char *_tzname[2];
# 10 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 2 3
# 25 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 3
struct stat
{
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  off_t st_size;
# 48 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 3
  time_t st_atime;
  long st_spare1;
  time_t st_mtime;
  long st_spare2;
  time_t st_ctime;
  long st_spare3;
  long st_blksize;
  long st_blocks;
  long st_spare4[2];


};
# 145 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\stat.h" 3
int chmod ( const char *__path, mode_t __mode );
int fchmod (int __fd, mode_t __mode);
int fstat ( int __fd, struct stat *__sbuf );
int mkdir ( const char *_path, mode_t __mode );
int mkfifo ( const char *__path, mode_t __mode );
int stat ( const char *__restrict __path, struct stat *__restrict __sbuf );
mode_t umask ( mode_t __mask );
# 181 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\_default_fcntl.h" 2 3

extern int open (const char *, int, ...);
extern int creat (const char *, mode_t);
extern int fcntl (int, int, ...);
# 5 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\fcntl.h" 2 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\fcntl.h" 2 3
# 40 "c:/devl/prboom3ds/src/m_menu.c" 2

# 1 "c:/devl/prboom3ds/src/doomdef.h" 1
# 49 "c:/devl/prboom3ds/src/doomdef.h"
# 1 "c:/devl/prboom3ds/src/z_zone.h" 1
# 53 "c:/devl/prboom3ds/src/z_zone.h"
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 1 3
# 10 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\ieeefp.h" 1 3
# 11 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 2 3





# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 17 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 2 3


# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\machine\\stdlib.h" 1 3
# 20 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 2 3

# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\alloca.h" 1 3
# 22 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 2 3








typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;




typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;




typedef int (*__compar_fn_t) (const void *, const void *);







int __locale_mb_cur_max (void);



void abort (void) __attribute__ ((noreturn));
int abs (int);
int atexit (void (*__func)(void));
double atof (const char *__nptr);

float atoff (const char *__nptr);

int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void * __key, const void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar)



                                ;
void * calloc (size_t __nmemb, size_t __size) ;
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((noreturn));
void free (void *) ;
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);
char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);

long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void * malloc (size_t __size) ;
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *__restrict, const char *__restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *__restrict, const char *__restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *__restrict, const char *__restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *__restrict, const char *__restrict, size_t, _mbstate_t *);
size_t wcstombs (char *__restrict, const wchar_t *__restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *__restrict, const wchar_t *__restrict, size_t, _mbstate_t *);


char * mkdtemp (char *);
int mkostemp (char *, int);
int mkostemps (char *, int, int);
int mkstemp (char *);
int mkstemps (char *, int);
char * mktemp (char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__warning__ ("the use of `mktemp' is dangerous; use `mkstemp' instead")));

void qsort (void * __base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void * realloc (void * __r, size_t __size) ;

void * reallocf (void * __r, size_t __size);
char * realpath (const char *__restrict path, char *__restrict resolved_path);

void srand (unsigned __seed);
double strtod (const char *__restrict __n, char **__restrict __end_PTR);
double _strtod_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR);

float strtof (const char *__restrict __n, char **__restrict __end_PTR);







long strtol (const char *__restrict __n, char **__restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR, int __base);
unsigned long strtoul (const char *__restrict __n, char **__restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR, int __base);

int system (const char *__string);


long a64l (const char *__input);
char * l64a (long __input);
char * _l64a_r (struct _reent *,long __input);
int on_exit (void (*__func)(int, void *),void * __arg);
void _Exit (int __status) __attribute__ ((noreturn));
int putenv (char *__string);
int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);
int setenv (const char *__string, const char *__value, int __overwrite);
int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);

char * gcvt (double,int,char *);
char * gcvtf (float,int,char *);
char * fcvt (double,int,int *,int *);
char * fcvtf (float,int,int *,int *);
char * ecvt (double,int,int *,int *);
char * ecvtbuf (double, int, int*, int*, char *);
char * fcvtbuf (double, int, int*, int*, char *);
char * ecvtf (float,int,int *,int *);
char * dtoa (double, int, int, int *, int*, char**);
int rand_r (unsigned *__seed);

double drand48 (void);
double _drand48_r (struct _reent *);
double erand48 (unsigned short [3]);
double _erand48_r (struct _reent *, unsigned short [3]);
long jrand48 (unsigned short [3]);
long _jrand48_r (struct _reent *, unsigned short [3]);
void lcong48 (unsigned short [7]);
void _lcong48_r (struct _reent *, unsigned short [7]);
long lrand48 (void);
long _lrand48_r (struct _reent *);
long mrand48 (void);
long _mrand48_r (struct _reent *);
long nrand48 (unsigned short [3]);
long _nrand48_r (struct _reent *, unsigned short [3]);
unsigned short *
       seed48 (unsigned short [3]);
unsigned short *
       _seed48_r (struct _reent *, unsigned short [3]);
void srand48 (long);
void _srand48_r (struct _reent *, long);
long long atoll (const char *__nptr);
long long _atoll_r (struct _reent *, const char *__nptr);
long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);


long long strtoll (const char *__restrict __n, char **__restrict __end_PTR, int __base);


long long _strtoll_r (struct _reent *, const char *__restrict __n, char **__restrict __end_PTR, int __base);


unsigned long long strtoull (const char *__restrict __n, char **__restrict __end_PTR, int __base);


unsigned long long _strtoull_r (struct _reent *, const char *__restrict __n, char **__restrict __end_PTR, int __base);


void cfree (void *);
int unsetenv (const char *__string);
int _unsetenv_r (struct _reent *, const char *__string);
# 221 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdlib.h" 3
char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) ;
void * _calloc_r (struct _reent *, size_t, size_t) ;
void _free_r (struct _reent *, void *) ;
void * _realloc_r (struct _reent *, void *, size_t) ;
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);




extern long double strtold (const char *__restrict, char **__restrict);




# 54 "c:/devl/prboom3ds/src/z_zone.h" 2
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 1 3
# 12 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\cdefs.h" 1 3
# 45 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\cdefs.h" 3
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 46 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\cdefs.h" 2 3
# 13 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 2 3




# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 18 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 2 3



void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void * , const void * , size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);


char *strtok (char *, const char *);


size_t strxfrm (char *, const char *, size_t);


char *strtok_r (char *, const char *, char **);

int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void * memccpy (void * , const void * , int, size_t);
void * mempcpy (void *, const void *, size_t);
void * memmem (const void *, size_t, const void *, size_t);
void * memrchr (const void *, int, size_t);
void * rawmemchr (const void *, int);
char *rindex (const char *, int);
char *stpcpy (char *, const char *);
char *stpncpy (char *, const char *, size_t);
int strcasecmp (const char *, const char *);
char *strcasestr (const char *, const char *);
char *strchrnul (const char *, int);


char *strdup (const char *);


char *_strdup_r (struct _reent *, const char *);


char *strndup (const char *, size_t);


char *_strndup_r (struct _reent *, const char *, size_t);
# 87 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 3
int strerror_r (int, char *, size_t) __asm__ ("" "__xpg_strerror_r");





size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
int strncasecmp (const char *, const char *, size_t);
size_t strnlen (const char *, size_t);
char *strsep (char **, const char *);
char *strlwr (char *);
char *strupr (char *);

char *strsignal (int __signo);






char * _strerror_r (struct _reent *, int, int, int *);
# 140 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 3
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\sys\\string.h" 1 3
# 141 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\string.h" 2 3


# 55 "c:/devl/prboom3ds/src/z_zone.h" 2
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\assert.h" 1 3
# 39 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\assert.h" 3
void __assert (const char *, int, const char *) __attribute__ ((__noreturn__))
                                 ;
void __assert_func (const char *, int, const char *, const char *) __attribute__ ((__noreturn__))
                                 ;
# 56 "c:/devl/prboom3ds/src/z_zone.h" 2




enum {PU_FREE, PU_STATIC, PU_SOUND, PU_MUSIC, PU_LEVEL, PU_LEVSPEC, PU_CACHE, PU_NEWBLOCK,
                                            PU_MAX};
# 73 "c:/devl/prboom3ds/src/z_zone.h"
void *(Z_Malloc)(size_t size, int tag, void **ptr );
void (Z_Free)(void *ptr );
void (Z_FreeTags)(int lowtag, int hightag );
void (Z_ChangeTag)(void *ptr, int tag );
void (Z_Init)(void);
void Z_Close(void);
void *(Z_Calloc)(size_t n, size_t n2, int tag, void **user );
void *(Z_Realloc)(void *p, size_t n, int tag, void **user );
char *(Z_Strdup)(const char *s, int tag, void **user );
void (Z_CheckHeap)();
void Z_DumpHistory(char *);
# 127 "c:/devl/prboom3ds/src/z_zone.h"
void Z_ZoneHistory(char *);
# 50 "c:/devl/prboom3ds/src/doomdef.h" 2




# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\ctype.h" 1 3







int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);



int isascii (int __c);
int toascii (int __c);
# 45 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\ctype.h" 3
extern char *__ctype_ptr__;
# 109 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\ctype.h" 3
extern const char _ctype_[];


# 55 "c:/devl/prboom3ds/src/doomdef.h" 2
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 1 3 4
# 34 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 3 4
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\syslimits.h" 1 3 4






# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 1 3 4
# 168 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 3 4
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\limits.h" 1 3 4
# 169 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 2 3 4
# 8 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\syslimits.h" 2 3 4
# 35 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 2 3 4
# 56 "c:/devl/prboom3ds/src/doomdef.h" 2






# 1 "c:/devl/prboom3ds/src/m_swap.h" 1
# 63 "c:/devl/prboom3ds/src/doomdef.h" 2
# 1 "c:/devl/prboom3ds/src/version.h" 1
# 38 "c:/devl/prboom3ds/src/version.h"
extern const char version_date[];
# 64 "c:/devl/prboom3ds/src/doomdef.h" 2



typedef enum {
  shareware,
  registered,
  commercial,
  retail,
  indetermined
} GameMode_t;


typedef enum {
  doom,
  doom2,
  pack_tnt,
  pack_plut,
  none
} GameMission_t;


typedef enum {
  english,
  french,
  german,
  unknown
} Language_t;
# 124 "c:/devl/prboom3ds/src/doomdef.h"
extern int SCREENWIDTH;
extern int SCREENHEIGHT;




extern int SCREENPITCH;
# 149 "c:/devl/prboom3ds/src/doomdef.h"
typedef enum {
  GS_LEVEL,
  GS_INTERMISSION,
  GS_FINALE,
  GS_DEMOSCREEN
} gamestate_t;
# 175 "c:/devl/prboom3ds/src/doomdef.h"
typedef enum {
  sk_none=-1,
  sk_baby=0,
  sk_easy,
  sk_medium,
  sk_hard,
  sk_nightmare
} skill_t;





typedef enum {
  it_bluecard,
  it_yellowcard,
  it_redcard,
  it_blueskull,
  it_yellowskull,
  it_redskull,
  NUMCARDS
} card_t;



typedef enum {
  wp_fist,
  wp_pistol,
  wp_shotgun,
  wp_chaingun,
  wp_missile,
  wp_plasma,
  wp_bfg,
  wp_chainsaw,
  wp_supershotgun,

  NUMWEAPONS,
  wp_nochange
} weapontype_t;


typedef enum {
  am_clip,
  am_shell,
  am_cell,
  am_misl,
  NUMAMMO,
  am_noammo
} ammotype_t;


typedef enum {
  pw_invulnerability,
  pw_strength,
  pw_invisibility,
  pw_ironfeet,
  pw_allmap,
  pw_infrared,
  NUMPOWERS
} powertype_t;


typedef enum {
  INVULNTICS = (30*35),
  INVISTICS = (60*35),
  INFRATICS = (120*35),
  IRONTICS = (60*35)
} powerduration_t;
# 316 "c:/devl/prboom3ds/src/doomdef.h"
typedef enum {
  ss_none,
  ss_keys,
  ss_weap,
  ss_stat,
  ss_auto,
  ss_enem,
  ss_mess,
  ss_chat,
  ss_gen,
  ss_comp,
  ss_max
} ss_types;
# 42 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/doomstat.h" 1
# 43 "c:/devl/prboom3ds/src/doomstat.h"
# 1 "c:/devl/prboom3ds/src/d_player.h" 1
# 43 "c:/devl/prboom3ds/src/d_player.h"
# 1 "c:/devl/prboom3ds/src/d_items.h" 1
# 46 "c:/devl/prboom3ds/src/d_items.h"
typedef struct
{
  ammotype_t ammo;
  int upstate;
  int downstate;
  int readystate;
  int atkstate;
  int flashstate;

} weaponinfo_t;

extern weaponinfo_t weaponinfo[NUMWEAPONS];
# 44 "c:/devl/prboom3ds/src/d_player.h" 2
# 1 "c:/devl/prboom3ds/src/p_pspr.h" 1
# 40 "c:/devl/prboom3ds/src/p_pspr.h"
# 1 "c:/devl/prboom3ds/src/m_fixed.h" 1
# 37 "c:/devl/prboom3ds/src/m_fixed.h"
# 1 "c:/devl/prboom3ds/arm9/include/config.h" 1
# 38 "c:/devl/prboom3ds/src/m_fixed.h" 2
# 1 "c:/devl/prboom3ds/src/doomtype.h" 1
# 64 "c:/devl/prboom3ds/src/doomtype.h"
# 1 "c:/devkitPro/libctru/include/3ds/types.h" 1




       

# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdint.h" 1 3 4
# 9 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdint.h" 3 4
# 1 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 1 3 4
# 41 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
typedef __int8_t int8_t ;
typedef __uint8_t uint8_t ;




typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;




typedef __int16_t int16_t ;
typedef __uint16_t uint16_t ;




typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;




typedef __int32_t int32_t ;
typedef __uint32_t uint32_t ;




typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;




typedef __int64_t int64_t ;
typedef __uint64_t uint64_t ;




typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
# 95 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef int int_fast8_t;
  typedef unsigned int uint_fast8_t;
# 105 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef int int_fast16_t;
  typedef unsigned int uint_fast16_t;
# 115 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef int int_fast32_t;
  typedef unsigned int uint_fast32_t;
# 125 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef long long int int_fast64_t;
  typedef long long unsigned int uint_fast64_t;
# 174 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef long long int intmax_t;
# 183 "c:\\devkitpro\\devkitarm\\arm-none-eabi\\include\\stdint.h" 3 4
  typedef long long unsigned int uintmax_t;






typedef __intptr_t intptr_t;
typedef __uintptr_t uintptr_t;
# 10 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdint.h" 2 3 4
# 8 "c:/devkitPro/libctru/include/3ds/types.h" 2
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdbool.h" 1 3 4
# 9 "c:/devkitPro/libctru/include/3ds/types.h" 2
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 10 "c:/devkitPro/libctru/include/3ds/types.h" 2



typedef enum
{
 mediatype_NAND,
 mediatype_SDMC,
 mediatype_GAMECARD,
} mediatypes_enum;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef int8_t s8;
typedef int16_t s16;
typedef int32_t s32;
typedef int64_t s64;

typedef volatile u8 vu8;
typedef volatile u16 vu16;
typedef volatile u32 vu32;
typedef volatile u64 vu64;

typedef volatile s8 vs8;
typedef volatile s16 vs16;
typedef volatile s32 vs32;
typedef volatile s64 vs64;

typedef u32 Handle;
typedef s32 Result;
typedef void (*ThreadFunc)(u32);
# 65 "c:/devl/prboom3ds/src/doomtype.h" 2
typedef _Bool qboolean;
typedef int boolean;
# 76 "c:/devl/prboom3ds/src/doomtype.h"
typedef unsigned char byte;
# 91 "c:/devl/prboom3ds/src/doomtype.h"
typedef signed long long int_64_t;
typedef unsigned long long uint_64_t;
# 116 "c:/devl/prboom3ds/src/doomtype.h"
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include-fixed\\limits.h" 1 3 4
# 117 "c:/devl/prboom3ds/src/doomtype.h" 2


typedef enum {
  doom_12_compatibility,
  doom_1666_compatibility,
  doom2_19_compatibility,
  ultdoom_compatibility,
  finaldoom_compatibility,
  dosdoom_compatibility,
  tasdoom_compatibility,
  boom_compatibility_compatibility,
  boom_201_compatibility,
  boom_202_compatibility,
  lxdoom_1_compatibility,
  mbf_compatibility,
  prboom_1_compatibility,
  prboom_2_compatibility,
  prboom_3_compatibility,
  prboom_4_compatibility,
  prboom_5_compatibility,
  prboom_6_compatibility,
  MAX_COMPATIBILITY_LEVEL,

  boom_compatibility = boom_201_compatibility,
  best_compatibility = prboom_6_compatibility,
} complevel_t;


enum patch_translation_e {
  VPT_NONE = 0,
  VPT_FLIP = 1,
  VPT_TRANS = 2,
  VPT_STRETCH = 4,
};
# 39 "c:/devl/prboom3ds/src/m_fixed.h" 2
# 47 "c:/devl/prboom3ds/src/m_fixed.h"
typedef int fixed_t;
# 56 "c:/devl/prboom3ds/src/m_fixed.h"
inline static __attribute__((const)) fixed_t D_abs(fixed_t x)
{
  fixed_t _t = (x),_s;
  _s = _t >> (8*sizeof _t-1);
  return (_t^_s)-_s;
}
# 70 "c:/devl/prboom3ds/src/m_fixed.h"
inline static __attribute__((const)) fixed_t FixedMul(fixed_t a, fixed_t b)
{
  return (fixed_t)((int_64_t) a*b >> 16);
}
# 82 "c:/devl/prboom3ds/src/m_fixed.h"
inline static __attribute__((const)) fixed_t FixedDiv(fixed_t a, fixed_t b)
{
  return (D_abs(a)>>14) >= D_abs(b) ? ((a^b)>>31) ^ 2147483647 :
    (fixed_t)(((int_64_t) a << 16) / b);
}






inline static __attribute__((const)) fixed_t FixedMod(fixed_t a, fixed_t b)
{
  if (b & (b-1)) {
    fixed_t r = a % b;
    return ((r<0) ? r+b : r);
  } else
    return (a & (b-1));
}
# 41 "c:/devl/prboom3ds/src/p_pspr.h" 2
# 1 "c:/devl/prboom3ds/src/tables.h" 1
# 71 "c:/devl/prboom3ds/src/tables.h"
typedef unsigned angle_t;


void R_LoadTrigTables(void);


extern fixed_t finesine[5*8192/4];


static fixed_t *const finecosine = finesine + (8192/4);


extern fixed_t finetangent[8192/2];




extern angle_t tantoangle[2048 +1];


int SlopeDiv(unsigned num, unsigned den);
# 42 "c:/devl/prboom3ds/src/p_pspr.h" 2
# 50 "c:/devl/prboom3ds/src/p_pspr.h"
# 1 "c:/devl/prboom3ds/src/info.h" 1
# 40 "c:/devl/prboom3ds/src/info.h"
# 1 "c:/devl/prboom3ds/src/d_think.h" 1
# 50 "c:/devl/prboom3ds/src/d_think.h"
typedef void (*actionf_t)();
# 72 "c:/devl/prboom3ds/src/d_think.h"
typedef actionf_t think_t;



typedef struct thinker_s
{
  struct thinker_s* prev;
  struct thinker_s* next;
  think_t function;





  struct thinker_s *cnext, *cprev;




  unsigned references;
} thinker_t;
# 41 "c:/devl/prboom3ds/src/info.h" 2




typedef enum
{
  SPR_TROO,
  SPR_SHTG,
  SPR_PUNG,
  SPR_PISG,
  SPR_PISF,
  SPR_SHTF,
  SPR_SHT2,
  SPR_CHGG,
  SPR_CHGF,
  SPR_MISG,
  SPR_MISF,
  SPR_SAWG,
  SPR_PLSG,
  SPR_PLSF,
  SPR_BFGG,
  SPR_BFGF,
  SPR_BLUD,
  SPR_PUFF,
  SPR_BAL1,
  SPR_BAL2,
  SPR_PLSS,
  SPR_PLSE,
  SPR_MISL,
  SPR_BFS1,
  SPR_BFE1,
  SPR_BFE2,
  SPR_TFOG,
  SPR_IFOG,
  SPR_PLAY,
  SPR_POSS,
  SPR_SPOS,
  SPR_VILE,
  SPR_FIRE,
  SPR_FATB,
  SPR_FBXP,
  SPR_SKEL,
  SPR_MANF,
  SPR_FATT,
  SPR_CPOS,
  SPR_SARG,
  SPR_HEAD,
  SPR_BAL7,
  SPR_BOSS,
  SPR_BOS2,
  SPR_SKUL,
  SPR_SPID,
  SPR_BSPI,
  SPR_APLS,
  SPR_APBX,
  SPR_CYBR,
  SPR_PAIN,
  SPR_SSWV,
  SPR_KEEN,
  SPR_BBRN,
  SPR_BOSF,
  SPR_ARM1,
  SPR_ARM2,
  SPR_BAR1,
  SPR_BEXP,
  SPR_FCAN,
  SPR_BON1,
  SPR_BON2,
  SPR_BKEY,
  SPR_RKEY,
  SPR_YKEY,
  SPR_BSKU,
  SPR_RSKU,
  SPR_YSKU,
  SPR_STIM,
  SPR_MEDI,
  SPR_SOUL,
  SPR_PINV,
  SPR_PSTR,
  SPR_PINS,
  SPR_MEGA,
  SPR_SUIT,
  SPR_PMAP,
  SPR_PVIS,
  SPR_CLIP,
  SPR_AMMO,
  SPR_ROCK,
  SPR_BROK,
  SPR_CELL,
  SPR_CELP,
  SPR_SHEL,
  SPR_SBOX,
  SPR_BPAK,
  SPR_BFUG,
  SPR_MGUN,
  SPR_CSAW,
  SPR_LAUN,
  SPR_PLAS,
  SPR_SHOT,
  SPR_SGN2,
  SPR_COLU,
  SPR_SMT2,
  SPR_GOR1,
  SPR_POL2,
  SPR_POL5,
  SPR_POL4,
  SPR_POL3,
  SPR_POL1,
  SPR_POL6,
  SPR_GOR2,
  SPR_GOR3,
  SPR_GOR4,
  SPR_GOR5,
  SPR_SMIT,
  SPR_COL1,
  SPR_COL2,
  SPR_COL3,
  SPR_COL4,
  SPR_CAND,
  SPR_CBRA,
  SPR_COL6,
  SPR_TRE1,
  SPR_TRE2,
  SPR_ELEC,
  SPR_CEYE,
  SPR_FSKU,
  SPR_COL5,
  SPR_TBLU,
  SPR_TGRN,
  SPR_TRED,
  SPR_SMBT,
  SPR_SMGT,
  SPR_SMRT,
  SPR_HDB1,
  SPR_HDB2,
  SPR_HDB3,
  SPR_HDB4,
  SPR_HDB5,
  SPR_HDB6,
  SPR_POB1,
  SPR_POB2,
  SPR_BRS1,
  SPR_TLMP,
  SPR_TLP2,
  SPR_TNT1,


  SPR_DOGS,


  NUMSPRITES

} spritenum_t;





typedef enum
{
  S_NULL,
  S_LIGHTDONE,
  S_PUNCH,
  S_PUNCHDOWN,
  S_PUNCHUP,
  S_PUNCH1,
  S_PUNCH2,
  S_PUNCH3,
  S_PUNCH4,
  S_PUNCH5,
  S_PISTOL,
  S_PISTOLDOWN,
  S_PISTOLUP,
  S_PISTOL1,
  S_PISTOL2,
  S_PISTOL3,
  S_PISTOL4,
  S_PISTOLFLASH,
  S_SGUN,
  S_SGUNDOWN,
  S_SGUNUP,
  S_SGUN1,
  S_SGUN2,
  S_SGUN3,
  S_SGUN4,
  S_SGUN5,
  S_SGUN6,
  S_SGUN7,
  S_SGUN8,
  S_SGUN9,
  S_SGUNFLASH1,
  S_SGUNFLASH2,
  S_DSGUN,
  S_DSGUNDOWN,
  S_DSGUNUP,
  S_DSGUN1,
  S_DSGUN2,
  S_DSGUN3,
  S_DSGUN4,
  S_DSGUN5,
  S_DSGUN6,
  S_DSGUN7,
  S_DSGUN8,
  S_DSGUN9,
  S_DSGUN10,
  S_DSNR1,
  S_DSNR2,
  S_DSGUNFLASH1,
  S_DSGUNFLASH2,
  S_CHAIN,
  S_CHAINDOWN,
  S_CHAINUP,
  S_CHAIN1,
  S_CHAIN2,
  S_CHAIN3,
  S_CHAINFLASH1,
  S_CHAINFLASH2,
  S_MISSILE,
  S_MISSILEDOWN,
  S_MISSILEUP,
  S_MISSILE1,
  S_MISSILE2,
  S_MISSILE3,
  S_MISSILEFLASH1,
  S_MISSILEFLASH2,
  S_MISSILEFLASH3,
  S_MISSILEFLASH4,
  S_SAW,
  S_SAWB,
  S_SAWDOWN,
  S_SAWUP,
  S_SAW1,
  S_SAW2,
  S_SAW3,
  S_PLASMA,
  S_PLASMADOWN,
  S_PLASMAUP,
  S_PLASMA1,
  S_PLASMA2,
  S_PLASMAFLASH1,
  S_PLASMAFLASH2,
  S_BFG,
  S_BFGDOWN,
  S_BFGUP,
  S_BFG1,
  S_BFG2,
  S_BFG3,
  S_BFG4,
  S_BFGFLASH1,
  S_BFGFLASH2,
  S_BLOOD1,
  S_BLOOD2,
  S_BLOOD3,
  S_PUFF1,
  S_PUFF2,
  S_PUFF3,
  S_PUFF4,
  S_TBALL1,
  S_TBALL2,
  S_TBALLX1,
  S_TBALLX2,
  S_TBALLX3,
  S_RBALL1,
  S_RBALL2,
  S_RBALLX1,
  S_RBALLX2,
  S_RBALLX3,
  S_PLASBALL,
  S_PLASBALL2,
  S_PLASEXP,
  S_PLASEXP2,
  S_PLASEXP3,
  S_PLASEXP4,
  S_PLASEXP5,
  S_ROCKET,
  S_BFGSHOT,
  S_BFGSHOT2,
  S_BFGLAND,
  S_BFGLAND2,
  S_BFGLAND3,
  S_BFGLAND4,
  S_BFGLAND5,
  S_BFGLAND6,
  S_BFGEXP,
  S_BFGEXP2,
  S_BFGEXP3,
  S_BFGEXP4,
  S_EXPLODE1,
  S_EXPLODE2,
  S_EXPLODE3,
  S_TFOG,
  S_TFOG01,
  S_TFOG02,
  S_TFOG2,
  S_TFOG3,
  S_TFOG4,
  S_TFOG5,
  S_TFOG6,
  S_TFOG7,
  S_TFOG8,
  S_TFOG9,
  S_TFOG10,
  S_IFOG,
  S_IFOG01,
  S_IFOG02,
  S_IFOG2,
  S_IFOG3,
  S_IFOG4,
  S_IFOG5,
  S_PLAY,
  S_PLAY_RUN1,
  S_PLAY_RUN2,
  S_PLAY_RUN3,
  S_PLAY_RUN4,
  S_PLAY_ATK1,
  S_PLAY_ATK2,
  S_PLAY_PAIN,
  S_PLAY_PAIN2,
  S_PLAY_DIE1,
  S_PLAY_DIE2,
  S_PLAY_DIE3,
  S_PLAY_DIE4,
  S_PLAY_DIE5,
  S_PLAY_DIE6,
  S_PLAY_DIE7,
  S_PLAY_XDIE1,
  S_PLAY_XDIE2,
  S_PLAY_XDIE3,
  S_PLAY_XDIE4,
  S_PLAY_XDIE5,
  S_PLAY_XDIE6,
  S_PLAY_XDIE7,
  S_PLAY_XDIE8,
  S_PLAY_XDIE9,
  S_POSS_STND,
  S_POSS_STND2,
  S_POSS_RUN1,
  S_POSS_RUN2,
  S_POSS_RUN3,
  S_POSS_RUN4,
  S_POSS_RUN5,
  S_POSS_RUN6,
  S_POSS_RUN7,
  S_POSS_RUN8,
  S_POSS_ATK1,
  S_POSS_ATK2,
  S_POSS_ATK3,
  S_POSS_PAIN,
  S_POSS_PAIN2,
  S_POSS_DIE1,
  S_POSS_DIE2,
  S_POSS_DIE3,
  S_POSS_DIE4,
  S_POSS_DIE5,
  S_POSS_XDIE1,
  S_POSS_XDIE2,
  S_POSS_XDIE3,
  S_POSS_XDIE4,
  S_POSS_XDIE5,
  S_POSS_XDIE6,
  S_POSS_XDIE7,
  S_POSS_XDIE8,
  S_POSS_XDIE9,
  S_POSS_RAISE1,
  S_POSS_RAISE2,
  S_POSS_RAISE3,
  S_POSS_RAISE4,
  S_SPOS_STND,
  S_SPOS_STND2,
  S_SPOS_RUN1,
  S_SPOS_RUN2,
  S_SPOS_RUN3,
  S_SPOS_RUN4,
  S_SPOS_RUN5,
  S_SPOS_RUN6,
  S_SPOS_RUN7,
  S_SPOS_RUN8,
  S_SPOS_ATK1,
  S_SPOS_ATK2,
  S_SPOS_ATK3,
  S_SPOS_PAIN,
  S_SPOS_PAIN2,
  S_SPOS_DIE1,
  S_SPOS_DIE2,
  S_SPOS_DIE3,
  S_SPOS_DIE4,
  S_SPOS_DIE5,
  S_SPOS_XDIE1,
  S_SPOS_XDIE2,
  S_SPOS_XDIE3,
  S_SPOS_XDIE4,
  S_SPOS_XDIE5,
  S_SPOS_XDIE6,
  S_SPOS_XDIE7,
  S_SPOS_XDIE8,
  S_SPOS_XDIE9,
  S_SPOS_RAISE1,
  S_SPOS_RAISE2,
  S_SPOS_RAISE3,
  S_SPOS_RAISE4,
  S_SPOS_RAISE5,
  S_VILE_STND,
  S_VILE_STND2,
  S_VILE_RUN1,
  S_VILE_RUN2,
  S_VILE_RUN3,
  S_VILE_RUN4,
  S_VILE_RUN5,
  S_VILE_RUN6,
  S_VILE_RUN7,
  S_VILE_RUN8,
  S_VILE_RUN9,
  S_VILE_RUN10,
  S_VILE_RUN11,
  S_VILE_RUN12,
  S_VILE_ATK1,
  S_VILE_ATK2,
  S_VILE_ATK3,
  S_VILE_ATK4,
  S_VILE_ATK5,
  S_VILE_ATK6,
  S_VILE_ATK7,
  S_VILE_ATK8,
  S_VILE_ATK9,
  S_VILE_ATK10,
  S_VILE_ATK11,
  S_VILE_HEAL1,
  S_VILE_HEAL2,
  S_VILE_HEAL3,
  S_VILE_PAIN,
  S_VILE_PAIN2,
  S_VILE_DIE1,
  S_VILE_DIE2,
  S_VILE_DIE3,
  S_VILE_DIE4,
  S_VILE_DIE5,
  S_VILE_DIE6,
  S_VILE_DIE7,
  S_VILE_DIE8,
  S_VILE_DIE9,
  S_VILE_DIE10,
  S_FIRE1,
  S_FIRE2,
  S_FIRE3,
  S_FIRE4,
  S_FIRE5,
  S_FIRE6,
  S_FIRE7,
  S_FIRE8,
  S_FIRE9,
  S_FIRE10,
  S_FIRE11,
  S_FIRE12,
  S_FIRE13,
  S_FIRE14,
  S_FIRE15,
  S_FIRE16,
  S_FIRE17,
  S_FIRE18,
  S_FIRE19,
  S_FIRE20,
  S_FIRE21,
  S_FIRE22,
  S_FIRE23,
  S_FIRE24,
  S_FIRE25,
  S_FIRE26,
  S_FIRE27,
  S_FIRE28,
  S_FIRE29,
  S_FIRE30,
  S_SMOKE1,
  S_SMOKE2,
  S_SMOKE3,
  S_SMOKE4,
  S_SMOKE5,
  S_TRACER,
  S_TRACER2,
  S_TRACEEXP1,
  S_TRACEEXP2,
  S_TRACEEXP3,
  S_SKEL_STND,
  S_SKEL_STND2,
  S_SKEL_RUN1,
  S_SKEL_RUN2,
  S_SKEL_RUN3,
  S_SKEL_RUN4,
  S_SKEL_RUN5,
  S_SKEL_RUN6,
  S_SKEL_RUN7,
  S_SKEL_RUN8,
  S_SKEL_RUN9,
  S_SKEL_RUN10,
  S_SKEL_RUN11,
  S_SKEL_RUN12,
  S_SKEL_FIST1,
  S_SKEL_FIST2,
  S_SKEL_FIST3,
  S_SKEL_FIST4,
  S_SKEL_MISS1,
  S_SKEL_MISS2,
  S_SKEL_MISS3,
  S_SKEL_MISS4,
  S_SKEL_PAIN,
  S_SKEL_PAIN2,
  S_SKEL_DIE1,
  S_SKEL_DIE2,
  S_SKEL_DIE3,
  S_SKEL_DIE4,
  S_SKEL_DIE5,
  S_SKEL_DIE6,
  S_SKEL_RAISE1,
  S_SKEL_RAISE2,
  S_SKEL_RAISE3,
  S_SKEL_RAISE4,
  S_SKEL_RAISE5,
  S_SKEL_RAISE6,
  S_FATSHOT1,
  S_FATSHOT2,
  S_FATSHOTX1,
  S_FATSHOTX2,
  S_FATSHOTX3,
  S_FATT_STND,
  S_FATT_STND2,
  S_FATT_RUN1,
  S_FATT_RUN2,
  S_FATT_RUN3,
  S_FATT_RUN4,
  S_FATT_RUN5,
  S_FATT_RUN6,
  S_FATT_RUN7,
  S_FATT_RUN8,
  S_FATT_RUN9,
  S_FATT_RUN10,
  S_FATT_RUN11,
  S_FATT_RUN12,
  S_FATT_ATK1,
  S_FATT_ATK2,
  S_FATT_ATK3,
  S_FATT_ATK4,
  S_FATT_ATK5,
  S_FATT_ATK6,
  S_FATT_ATK7,
  S_FATT_ATK8,
  S_FATT_ATK9,
  S_FATT_ATK10,
  S_FATT_PAIN,
  S_FATT_PAIN2,
  S_FATT_DIE1,
  S_FATT_DIE2,
  S_FATT_DIE3,
  S_FATT_DIE4,
  S_FATT_DIE5,
  S_FATT_DIE6,
  S_FATT_DIE7,
  S_FATT_DIE8,
  S_FATT_DIE9,
  S_FATT_DIE10,
  S_FATT_RAISE1,
  S_FATT_RAISE2,
  S_FATT_RAISE3,
  S_FATT_RAISE4,
  S_FATT_RAISE5,
  S_FATT_RAISE6,
  S_FATT_RAISE7,
  S_FATT_RAISE8,
  S_CPOS_STND,
  S_CPOS_STND2,
  S_CPOS_RUN1,
  S_CPOS_RUN2,
  S_CPOS_RUN3,
  S_CPOS_RUN4,
  S_CPOS_RUN5,
  S_CPOS_RUN6,
  S_CPOS_RUN7,
  S_CPOS_RUN8,
  S_CPOS_ATK1,
  S_CPOS_ATK2,
  S_CPOS_ATK3,
  S_CPOS_ATK4,
  S_CPOS_PAIN,
  S_CPOS_PAIN2,
  S_CPOS_DIE1,
  S_CPOS_DIE2,
  S_CPOS_DIE3,
  S_CPOS_DIE4,
  S_CPOS_DIE5,
  S_CPOS_DIE6,
  S_CPOS_DIE7,
  S_CPOS_XDIE1,
  S_CPOS_XDIE2,
  S_CPOS_XDIE3,
  S_CPOS_XDIE4,
  S_CPOS_XDIE5,
  S_CPOS_XDIE6,
  S_CPOS_RAISE1,
  S_CPOS_RAISE2,
  S_CPOS_RAISE3,
  S_CPOS_RAISE4,
  S_CPOS_RAISE5,
  S_CPOS_RAISE6,
  S_CPOS_RAISE7,
  S_TROO_STND,
  S_TROO_STND2,
  S_TROO_RUN1,
  S_TROO_RUN2,
  S_TROO_RUN3,
  S_TROO_RUN4,
  S_TROO_RUN5,
  S_TROO_RUN6,
  S_TROO_RUN7,
  S_TROO_RUN8,
  S_TROO_ATK1,
  S_TROO_ATK2,
  S_TROO_ATK3,
  S_TROO_PAIN,
  S_TROO_PAIN2,
  S_TROO_DIE1,
  S_TROO_DIE2,
  S_TROO_DIE3,
  S_TROO_DIE4,
  S_TROO_DIE5,
  S_TROO_XDIE1,
  S_TROO_XDIE2,
  S_TROO_XDIE3,
  S_TROO_XDIE4,
  S_TROO_XDIE5,
  S_TROO_XDIE6,
  S_TROO_XDIE7,
  S_TROO_XDIE8,
  S_TROO_RAISE1,
  S_TROO_RAISE2,
  S_TROO_RAISE3,
  S_TROO_RAISE4,
  S_TROO_RAISE5,
  S_SARG_STND,
  S_SARG_STND2,
  S_SARG_RUN1,
  S_SARG_RUN2,
  S_SARG_RUN3,
  S_SARG_RUN4,
  S_SARG_RUN5,
  S_SARG_RUN6,
  S_SARG_RUN7,
  S_SARG_RUN8,
  S_SARG_ATK1,
  S_SARG_ATK2,
  S_SARG_ATK3,
  S_SARG_PAIN,
  S_SARG_PAIN2,
  S_SARG_DIE1,
  S_SARG_DIE2,
  S_SARG_DIE3,
  S_SARG_DIE4,
  S_SARG_DIE5,
  S_SARG_DIE6,
  S_SARG_RAISE1,
  S_SARG_RAISE2,
  S_SARG_RAISE3,
  S_SARG_RAISE4,
  S_SARG_RAISE5,
  S_SARG_RAISE6,
  S_HEAD_STND,
  S_HEAD_RUN1,
  S_HEAD_ATK1,
  S_HEAD_ATK2,
  S_HEAD_ATK3,
  S_HEAD_PAIN,
  S_HEAD_PAIN2,
  S_HEAD_PAIN3,
  S_HEAD_DIE1,
  S_HEAD_DIE2,
  S_HEAD_DIE3,
  S_HEAD_DIE4,
  S_HEAD_DIE5,
  S_HEAD_DIE6,
  S_HEAD_RAISE1,
  S_HEAD_RAISE2,
  S_HEAD_RAISE3,
  S_HEAD_RAISE4,
  S_HEAD_RAISE5,
  S_HEAD_RAISE6,
  S_BRBALL1,
  S_BRBALL2,
  S_BRBALLX1,
  S_BRBALLX2,
  S_BRBALLX3,
  S_BOSS_STND,
  S_BOSS_STND2,
  S_BOSS_RUN1,
  S_BOSS_RUN2,
  S_BOSS_RUN3,
  S_BOSS_RUN4,
  S_BOSS_RUN5,
  S_BOSS_RUN6,
  S_BOSS_RUN7,
  S_BOSS_RUN8,
  S_BOSS_ATK1,
  S_BOSS_ATK2,
  S_BOSS_ATK3,
  S_BOSS_PAIN,
  S_BOSS_PAIN2,
  S_BOSS_DIE1,
  S_BOSS_DIE2,
  S_BOSS_DIE3,
  S_BOSS_DIE4,
  S_BOSS_DIE5,
  S_BOSS_DIE6,
  S_BOSS_DIE7,
  S_BOSS_RAISE1,
  S_BOSS_RAISE2,
  S_BOSS_RAISE3,
  S_BOSS_RAISE4,
  S_BOSS_RAISE5,
  S_BOSS_RAISE6,
  S_BOSS_RAISE7,
  S_BOS2_STND,
  S_BOS2_STND2,
  S_BOS2_RUN1,
  S_BOS2_RUN2,
  S_BOS2_RUN3,
  S_BOS2_RUN4,
  S_BOS2_RUN5,
  S_BOS2_RUN6,
  S_BOS2_RUN7,
  S_BOS2_RUN8,
  S_BOS2_ATK1,
  S_BOS2_ATK2,
  S_BOS2_ATK3,
  S_BOS2_PAIN,
  S_BOS2_PAIN2,
  S_BOS2_DIE1,
  S_BOS2_DIE2,
  S_BOS2_DIE3,
  S_BOS2_DIE4,
  S_BOS2_DIE5,
  S_BOS2_DIE6,
  S_BOS2_DIE7,
  S_BOS2_RAISE1,
  S_BOS2_RAISE2,
  S_BOS2_RAISE3,
  S_BOS2_RAISE4,
  S_BOS2_RAISE5,
  S_BOS2_RAISE6,
  S_BOS2_RAISE7,
  S_SKULL_STND,
  S_SKULL_STND2,
  S_SKULL_RUN1,
  S_SKULL_RUN2,
  S_SKULL_ATK1,
  S_SKULL_ATK2,
  S_SKULL_ATK3,
  S_SKULL_ATK4,
  S_SKULL_PAIN,
  S_SKULL_PAIN2,
  S_SKULL_DIE1,
  S_SKULL_DIE2,
  S_SKULL_DIE3,
  S_SKULL_DIE4,
  S_SKULL_DIE5,
  S_SKULL_DIE6,
  S_SPID_STND,
  S_SPID_STND2,
  S_SPID_RUN1,
  S_SPID_RUN2,
  S_SPID_RUN3,
  S_SPID_RUN4,
  S_SPID_RUN5,
  S_SPID_RUN6,
  S_SPID_RUN7,
  S_SPID_RUN8,
  S_SPID_RUN9,
  S_SPID_RUN10,
  S_SPID_RUN11,
  S_SPID_RUN12,
  S_SPID_ATK1,
  S_SPID_ATK2,
  S_SPID_ATK3,
  S_SPID_ATK4,
  S_SPID_PAIN,
  S_SPID_PAIN2,
  S_SPID_DIE1,
  S_SPID_DIE2,
  S_SPID_DIE3,
  S_SPID_DIE4,
  S_SPID_DIE5,
  S_SPID_DIE6,
  S_SPID_DIE7,
  S_SPID_DIE8,
  S_SPID_DIE9,
  S_SPID_DIE10,
  S_SPID_DIE11,
  S_BSPI_STND,
  S_BSPI_STND2,
  S_BSPI_SIGHT,
  S_BSPI_RUN1,
  S_BSPI_RUN2,
  S_BSPI_RUN3,
  S_BSPI_RUN4,
  S_BSPI_RUN5,
  S_BSPI_RUN6,
  S_BSPI_RUN7,
  S_BSPI_RUN8,
  S_BSPI_RUN9,
  S_BSPI_RUN10,
  S_BSPI_RUN11,
  S_BSPI_RUN12,
  S_BSPI_ATK1,
  S_BSPI_ATK2,
  S_BSPI_ATK3,
  S_BSPI_ATK4,
  S_BSPI_PAIN,
  S_BSPI_PAIN2,
  S_BSPI_DIE1,
  S_BSPI_DIE2,
  S_BSPI_DIE3,
  S_BSPI_DIE4,
  S_BSPI_DIE5,
  S_BSPI_DIE6,
  S_BSPI_DIE7,
  S_BSPI_RAISE1,
  S_BSPI_RAISE2,
  S_BSPI_RAISE3,
  S_BSPI_RAISE4,
  S_BSPI_RAISE5,
  S_BSPI_RAISE6,
  S_BSPI_RAISE7,
  S_ARACH_PLAZ,
  S_ARACH_PLAZ2,
  S_ARACH_PLEX,
  S_ARACH_PLEX2,
  S_ARACH_PLEX3,
  S_ARACH_PLEX4,
  S_ARACH_PLEX5,
  S_CYBER_STND,
  S_CYBER_STND2,
  S_CYBER_RUN1,
  S_CYBER_RUN2,
  S_CYBER_RUN3,
  S_CYBER_RUN4,
  S_CYBER_RUN5,
  S_CYBER_RUN6,
  S_CYBER_RUN7,
  S_CYBER_RUN8,
  S_CYBER_ATK1,
  S_CYBER_ATK2,
  S_CYBER_ATK3,
  S_CYBER_ATK4,
  S_CYBER_ATK5,
  S_CYBER_ATK6,
  S_CYBER_PAIN,
  S_CYBER_DIE1,
  S_CYBER_DIE2,
  S_CYBER_DIE3,
  S_CYBER_DIE4,
  S_CYBER_DIE5,
  S_CYBER_DIE6,
  S_CYBER_DIE7,
  S_CYBER_DIE8,
  S_CYBER_DIE9,
  S_CYBER_DIE10,
  S_PAIN_STND,
  S_PAIN_RUN1,
  S_PAIN_RUN2,
  S_PAIN_RUN3,
  S_PAIN_RUN4,
  S_PAIN_RUN5,
  S_PAIN_RUN6,
  S_PAIN_ATK1,
  S_PAIN_ATK2,
  S_PAIN_ATK3,
  S_PAIN_ATK4,
  S_PAIN_PAIN,
  S_PAIN_PAIN2,
  S_PAIN_DIE1,
  S_PAIN_DIE2,
  S_PAIN_DIE3,
  S_PAIN_DIE4,
  S_PAIN_DIE5,
  S_PAIN_DIE6,
  S_PAIN_RAISE1,
  S_PAIN_RAISE2,
  S_PAIN_RAISE3,
  S_PAIN_RAISE4,
  S_PAIN_RAISE5,
  S_PAIN_RAISE6,
  S_SSWV_STND,
  S_SSWV_STND2,
  S_SSWV_RUN1,
  S_SSWV_RUN2,
  S_SSWV_RUN3,
  S_SSWV_RUN4,
  S_SSWV_RUN5,
  S_SSWV_RUN6,
  S_SSWV_RUN7,
  S_SSWV_RUN8,
  S_SSWV_ATK1,
  S_SSWV_ATK2,
  S_SSWV_ATK3,
  S_SSWV_ATK4,
  S_SSWV_ATK5,
  S_SSWV_ATK6,
  S_SSWV_PAIN,
  S_SSWV_PAIN2,
  S_SSWV_DIE1,
  S_SSWV_DIE2,
  S_SSWV_DIE3,
  S_SSWV_DIE4,
  S_SSWV_DIE5,
  S_SSWV_XDIE1,
  S_SSWV_XDIE2,
  S_SSWV_XDIE3,
  S_SSWV_XDIE4,
  S_SSWV_XDIE5,
  S_SSWV_XDIE6,
  S_SSWV_XDIE7,
  S_SSWV_XDIE8,
  S_SSWV_XDIE9,
  S_SSWV_RAISE1,
  S_SSWV_RAISE2,
  S_SSWV_RAISE3,
  S_SSWV_RAISE4,
  S_SSWV_RAISE5,
  S_KEENSTND,
  S_COMMKEEN,
  S_COMMKEEN2,
  S_COMMKEEN3,
  S_COMMKEEN4,
  S_COMMKEEN5,
  S_COMMKEEN6,
  S_COMMKEEN7,
  S_COMMKEEN8,
  S_COMMKEEN9,
  S_COMMKEEN10,
  S_COMMKEEN11,
  S_COMMKEEN12,
  S_KEENPAIN,
  S_KEENPAIN2,
  S_BRAIN,
  S_BRAIN_PAIN,
  S_BRAIN_DIE1,
  S_BRAIN_DIE2,
  S_BRAIN_DIE3,
  S_BRAIN_DIE4,
  S_BRAINEYE,
  S_BRAINEYESEE,
  S_BRAINEYE1,
  S_SPAWN1,
  S_SPAWN2,
  S_SPAWN3,
  S_SPAWN4,
  S_SPAWNFIRE1,
  S_SPAWNFIRE2,
  S_SPAWNFIRE3,
  S_SPAWNFIRE4,
  S_SPAWNFIRE5,
  S_SPAWNFIRE6,
  S_SPAWNFIRE7,
  S_SPAWNFIRE8,
  S_BRAINEXPLODE1,
  S_BRAINEXPLODE2,
  S_BRAINEXPLODE3,
  S_ARM1,
  S_ARM1A,
  S_ARM2,
  S_ARM2A,
  S_BAR1,
  S_BAR2,
  S_BEXP,
  S_BEXP2,
  S_BEXP3,
  S_BEXP4,
  S_BEXP5,
  S_BBAR1,
  S_BBAR2,
  S_BBAR3,
  S_BON1,
  S_BON1A,
  S_BON1B,
  S_BON1C,
  S_BON1D,
  S_BON1E,
  S_BON2,
  S_BON2A,
  S_BON2B,
  S_BON2C,
  S_BON2D,
  S_BON2E,
  S_BKEY,
  S_BKEY2,
  S_RKEY,
  S_RKEY2,
  S_YKEY,
  S_YKEY2,
  S_BSKULL,
  S_BSKULL2,
  S_RSKULL,
  S_RSKULL2,
  S_YSKULL,
  S_YSKULL2,
  S_STIM,
  S_MEDI,
  S_SOUL,
  S_SOUL2,
  S_SOUL3,
  S_SOUL4,
  S_SOUL5,
  S_SOUL6,
  S_PINV,
  S_PINV2,
  S_PINV3,
  S_PINV4,
  S_PSTR,
  S_PINS,
  S_PINS2,
  S_PINS3,
  S_PINS4,
  S_MEGA,
  S_MEGA2,
  S_MEGA3,
  S_MEGA4,
  S_SUIT,
  S_PMAP,
  S_PMAP2,
  S_PMAP3,
  S_PMAP4,
  S_PMAP5,
  S_PMAP6,
  S_PVIS,
  S_PVIS2,
  S_CLIP,
  S_AMMO,
  S_ROCK,
  S_BROK,
  S_CELL,
  S_CELP,
  S_SHEL,
  S_SBOX,
  S_BPAK,
  S_BFUG,
  S_MGUN,
  S_CSAW,
  S_LAUN,
  S_PLAS,
  S_SHOT,
  S_SHOT2,
  S_COLU,
  S_STALAG,
  S_BLOODYTWITCH,
  S_BLOODYTWITCH2,
  S_BLOODYTWITCH3,
  S_BLOODYTWITCH4,
  S_DEADTORSO,
  S_DEADBOTTOM,
  S_HEADSONSTICK,
  S_GIBS,
  S_HEADONASTICK,
  S_HEADCANDLES,
  S_HEADCANDLES2,
  S_DEADSTICK,
  S_LIVESTICK,
  S_LIVESTICK2,
  S_MEAT2,
  S_MEAT3,
  S_MEAT4,
  S_MEAT5,
  S_STALAGTITE,
  S_TALLGRNCOL,
  S_SHRTGRNCOL,
  S_TALLREDCOL,
  S_SHRTREDCOL,
  S_CANDLESTIK,
  S_CANDELABRA,
  S_SKULLCOL,
  S_TORCHTREE,
  S_BIGTREE,
  S_TECHPILLAR,
  S_EVILEYE,
  S_EVILEYE2,
  S_EVILEYE3,
  S_EVILEYE4,
  S_FLOATSKULL,
  S_FLOATSKULL2,
  S_FLOATSKULL3,
  S_HEARTCOL,
  S_HEARTCOL2,
  S_BLUETORCH,
  S_BLUETORCH2,
  S_BLUETORCH3,
  S_BLUETORCH4,
  S_GREENTORCH,
  S_GREENTORCH2,
  S_GREENTORCH3,
  S_GREENTORCH4,
  S_REDTORCH,
  S_REDTORCH2,
  S_REDTORCH3,
  S_REDTORCH4,
  S_BTORCHSHRT,
  S_BTORCHSHRT2,
  S_BTORCHSHRT3,
  S_BTORCHSHRT4,
  S_GTORCHSHRT,
  S_GTORCHSHRT2,
  S_GTORCHSHRT3,
  S_GTORCHSHRT4,
  S_RTORCHSHRT,
  S_RTORCHSHRT2,
  S_RTORCHSHRT3,
  S_RTORCHSHRT4,
  S_HANGNOGUTS,
  S_HANGBNOBRAIN,
  S_HANGTLOOKDN,
  S_HANGTSKULL,
  S_HANGTLOOKUP,
  S_HANGTNOBRAIN,
  S_COLONGIBS,
  S_SMALLPOOL,
  S_BRAINSTEM,
  S_TECHLAMP,
  S_TECHLAMP2,
  S_TECHLAMP3,
  S_TECHLAMP4,
  S_TECH2LAMP,
  S_TECH2LAMP2,
  S_TECH2LAMP3,
  S_TECH2LAMP4,
  S_TNT1,

  S_GRENADE,
  S_DETONATE,
  S_DETONATE2,
  S_DETONATE3,


  S_DOGS_STND,
  S_DOGS_STND2,
  S_DOGS_RUN1,
  S_DOGS_RUN2,
  S_DOGS_RUN3,
  S_DOGS_RUN4,
  S_DOGS_RUN5,
  S_DOGS_RUN6,
  S_DOGS_RUN7,
  S_DOGS_RUN8,
  S_DOGS_ATK1,
  S_DOGS_ATK2,
  S_DOGS_ATK3,
  S_DOGS_PAIN,
  S_DOGS_PAIN2,
  S_DOGS_DIE1,
  S_DOGS_DIE2,
  S_DOGS_DIE3,
  S_DOGS_DIE4,
  S_DOGS_DIE5,
  S_DOGS_DIE6,
  S_DOGS_RAISE1,
  S_DOGS_RAISE2,
  S_DOGS_RAISE3,
  S_DOGS_RAISE4,
  S_DOGS_RAISE5,
  S_DOGS_RAISE6,



  S_OLDBFG1,
  S_OLDBFG42 = S_OLDBFG1+41,
  S_OLDBFG43,

  S_PLS1BALL,
  S_PLS1BALL2,
  S_PLS1EXP,
  S_PLS1EXP2,
  S_PLS1EXP3,
  S_PLS1EXP4,
  S_PLS1EXP5,

  S_PLS2BALL,
  S_PLS2BALL2,
  S_PLS2BALLX1,
  S_PLS2BALLX2,
  S_PLS2BALLX3,
  S_BON3,
  S_BON4,


  S_BSKUL_STND,
  S_BSKUL_RUN1,
  S_BSKUL_RUN2,
  S_BSKUL_RUN3,
  S_BSKUL_RUN4,
  S_BSKUL_ATK1,
  S_BSKUL_ATK2,
  S_BSKUL_ATK3,
  S_BSKUL_PAIN1,
  S_BSKUL_PAIN2,
  S_BSKUL_PAIN3,
  S_BSKUL_DIE1,
  S_BSKUL_DIE2,
  S_BSKUL_DIE3,
  S_BSKUL_DIE4,
  S_BSKUL_DIE5,
  S_BSKUL_DIE6,
  S_BSKUL_DIE7,
  S_BSKUL_DIE8,

  S_MUSHROOM,

  NUMSTATES

} statenum_t;





typedef struct
{
  spritenum_t sprite;
  long frame;
  long tics;
  actionf_t action;
  statenum_t nextstate;
  long misc1, misc2;
} state_t;


extern state_t states[NUMSTATES];
extern const char *sprnames[];







typedef enum {
  MT_PLAYER,
  MT_POSSESSED,
  MT_SHOTGUY,
  MT_VILE,
  MT_FIRE,
  MT_UNDEAD,
  MT_TRACER,
  MT_SMOKE,
  MT_FATSO,
  MT_FATSHOT,
  MT_CHAINGUY,
  MT_TROOP,
  MT_SERGEANT,
  MT_SHADOWS,
  MT_HEAD,
  MT_BRUISER,
  MT_BRUISERSHOT,
  MT_KNIGHT,
  MT_SKULL,
  MT_SPIDER,
  MT_BABY,
  MT_CYBORG,
  MT_PAIN,
  MT_WOLFSS,
  MT_KEEN,
  MT_BOSSBRAIN,
  MT_BOSSSPIT,
  MT_BOSSTARGET,
  MT_SPAWNSHOT,
  MT_SPAWNFIRE,
  MT_BARREL,
  MT_TROOPSHOT,
  MT_HEADSHOT,
  MT_ROCKET,
  MT_PLASMA,
  MT_BFG,
  MT_ARACHPLAZ,
  MT_PUFF,
  MT_BLOOD,
  MT_TFOG,
  MT_IFOG,
  MT_TELEPORTMAN,
  MT_EXTRABFG,
  MT_MISC0,
  MT_MISC1,
  MT_MISC2,
  MT_MISC3,
  MT_MISC4,
  MT_MISC5,
  MT_MISC6,
  MT_MISC7,
  MT_MISC8,
  MT_MISC9,
  MT_MISC10,
  MT_MISC11,
  MT_MISC12,
  MT_INV,
  MT_MISC13,
  MT_INS,
  MT_MISC14,
  MT_MISC15,
  MT_MISC16,
  MT_MEGA,
  MT_CLIP,
  MT_MISC17,
  MT_MISC18,
  MT_MISC19,
  MT_MISC20,
  MT_MISC21,
  MT_MISC22,
  MT_MISC23,
  MT_MISC24,
  MT_MISC25,
  MT_CHAINGUN,
  MT_MISC26,
  MT_MISC27,
  MT_MISC28,
  MT_SHOTGUN,
  MT_SUPERSHOTGUN,
  MT_MISC29,
  MT_MISC30,
  MT_MISC31,
  MT_MISC32,
  MT_MISC33,
  MT_MISC34,
  MT_MISC35,
  MT_MISC36,
  MT_MISC37,
  MT_MISC38,
  MT_MISC39,
  MT_MISC40,
  MT_MISC41,
  MT_MISC42,
  MT_MISC43,
  MT_MISC44,
  MT_MISC45,
  MT_MISC46,
  MT_MISC47,
  MT_MISC48,
  MT_MISC49,
  MT_MISC50,
  MT_MISC51,
  MT_MISC52,
  MT_MISC53,
  MT_MISC54,
  MT_MISC55,
  MT_MISC56,
  MT_MISC57,
  MT_MISC58,
  MT_MISC59,
  MT_MISC60,
  MT_MISC61,
  MT_MISC62,
  MT_MISC63,
  MT_MISC64,
  MT_MISC65,
  MT_MISC66,
  MT_MISC67,
  MT_MISC68,
  MT_MISC69,
  MT_MISC70,
  MT_MISC71,
  MT_MISC72,
  MT_MISC73,
  MT_MISC74,
  MT_MISC75,
  MT_MISC76,
  MT_MISC77,
  MT_MISC78,
  MT_MISC79,
  MT_MISC80,
  MT_MISC81,
  MT_MISC82,
  MT_MISC83,
  MT_MISC84,
  MT_MISC85,
  MT_MISC86,
  MT_PUSH,
  MT_PULL,


  MT_DOGS,




  MT_STEALTHBABY,
  MT_STEALTHVILE,
  MT_STEALTHBRUISER,
  MT_STEALTHHEAD,
  MT_STEALTHCHAINGUY,
  MT_STEALTHSERGEANT,
  MT_STEALTHKNIGHT,
  MT_STEALTHIMP,
  MT_STEALTHFATSO,
  MT_STEALTHUNDEAD,
  MT_STEALTHSHOTGUY,
  MT_STEALTHZOMBIE,

  NUMMOBJTYPES
} mobjtype_t;
# 1448 "c:/devl/prboom3ds/src/info.h"
typedef struct
{
  int doomednum;

  int spawnstate;

  int spawnhealth;
  int seestate;
  int seesound;
  int reactiontime;


  int attacksound;
  int painstate;
  int painchance;





  int painsound;
  int meleestate;
  int missilestate;

  int deathstate;
  int xdeathstate;

  int deathsound;


  int speed;

  int radius;
  int height;

  int mass;


  int damage;
  int activesound;

  uint_64_t flags;
  int raisestate;


} mobjinfo_t;


extern mobjinfo_t mobjinfo[NUMMOBJTYPES];
# 51 "c:/devl/prboom3ds/src/p_pspr.h" 2
# 70 "c:/devl/prboom3ds/src/p_pspr.h"
typedef enum
{
  ps_weapon,
  ps_flash,
  NUMPSPRITES
} psprnum_t;

typedef struct
{
  state_t *state;
  int tics;
  fixed_t sx;
  fixed_t sy;
} pspdef_t;

extern int weapon_preferences[2][NUMWEAPONS+1];
int P_WeaponPreferred(int w1, int w2);

struct player_s;
int P_SwitchWeapon(struct player_s *player);
int P_GetAmmoLevel(struct player_s *player, weapontype_t weapon);
boolean P_CheckAmmo(struct player_s *player);
void P_SetupPsprites(struct player_s *curplayer);
void P_MovePsprites(struct player_s *curplayer);
void P_DropWeapon(struct player_s *player);

void A_Light0();
void A_WeaponReady();
void A_Lower();
void A_Raise();
void A_Punch();
void A_ReFire();
void A_FirePistol();
void A_Light1();
void A_FireShotgun();
void A_Light2();
void A_FireShotgun2();
void A_CheckReload();
void A_OpenShotgun2();
void A_LoadShotgun2();
void A_CloseShotgun2();
void A_FireCGun();
void A_GunFlash();
void A_FireMissile();
void A_Saw();
void A_FirePlasma();
void A_BFGsound();
void A_FireBFG();
void A_BFGSpray();
# 45 "c:/devl/prboom3ds/src/d_player.h" 2



# 1 "c:/devl/prboom3ds/src/p_mobj.h" 1
# 46 "c:/devl/prboom3ds/src/p_mobj.h"
# 1 "c:/devl/prboom3ds/src/doomdata.h" 1
# 40 "c:/devl/prboom3ds/src/doomdata.h"
# 1 "c:/devl/prboom3ds/arm9/include/config.h" 1
# 41 "c:/devl/prboom3ds/src/doomdata.h" 2
# 51 "c:/devl/prboom3ds/src/doomdata.h"
enum {
  ML_LABEL,
  ML_THINGS,
  ML_LINEDEFS,
  ML_SIDEDEFS,
  ML_VERTEXES,
  ML_SEGS,
  ML_SSECTORS,
  ML_NODES,
  ML_SECTORS,
  ML_REJECT,
  ML_BLOCKMAP
};







typedef struct {
  short x,y;
} __attribute__((packed)) mapvertex_t;



typedef struct {
  short textureoffset;
  short rowoffset;
  char toptexture[8];
  char bottomtexture[8];
  char midtexture[8];
  short sector;
} __attribute__((packed)) mapsidedef_t;



typedef struct {
  unsigned short v1;
  unsigned short v2;
  unsigned short flags;
  short special;
  short tag;



  unsigned short sidenum[2];
} __attribute__((packed)) maplinedef_t;
# 147 "c:/devl/prboom3ds/src/doomdata.h"
typedef struct {
  short floorheight;
  short ceilingheight;
  char floorpic[8];
  char ceilingpic[8];
  short lightlevel;
  short special;
  short tag;
} __attribute__((packed)) mapsector_t;


typedef struct {
  unsigned short numsegs;
  unsigned short firstseg;
} __attribute__((packed)) mapsubsector_t;



typedef struct {
  unsigned short v1;
  unsigned short v2;
  short angle;
  unsigned short linedef;
  short side;
  short offset;
} __attribute__((packed)) mapseg_t;






typedef struct {
  short x;
  short y;
  short dx;
  short dy;

  short bbox[2][4];

  unsigned short children[2];
} __attribute__((packed)) mapnode_t;



typedef struct {
  short x;
  short y;
  short angle;
  short type;
  short options;
} __attribute__((packed)) mapthing_t;
# 47 "c:/devl/prboom3ds/src/p_mobj.h" 2
# 224 "c:/devl/prboom3ds/src/p_mobj.h"
enum {
  MIF_FALLING = 1,
  MIF_ARMED = 2,
};
# 248 "c:/devl/prboom3ds/src/p_mobj.h"
typedef struct mobj_s
{

    thinker_t thinker;


    fixed_t x;
    fixed_t y;
    fixed_t z;


    struct mobj_s* snext;
    struct mobj_s** sprev;


    angle_t angle;
    spritenum_t sprite;
    int frame;



    struct mobj_s* bnext;
    struct mobj_s** bprev;

    struct subsector_s* subsector;


    fixed_t floorz;
    fixed_t ceilingz;


    fixed_t dropoffz;


    fixed_t radius;
    fixed_t height;


    fixed_t momx;
    fixed_t momy;
    fixed_t momz;


    int validcount;

    mobjtype_t type;
    mobjinfo_t* info;

    int tics;
    state_t* state;
    uint_64_t flags;
    int intflags;
    int health;


    short movedir;
    short movecount;
    short strafecount;



    struct mobj_s* target;



    short reactiontime;



    short threshold;


    short pursuecount;

    short gear;



    struct player_s* player;


    short lastlook;


    mapthing_t spawnpoint;


    struct mobj_s* tracer;


    struct mobj_s* lastenemy;





    int friction;
    int movefactor;


    struct msecnode_s* touching_sectorlist;

    fixed_t PrevX;
    fixed_t PrevY;
    fixed_t PrevZ;

    fixed_t pad;


} mobj_t;
# 385 "c:/devl/prboom3ds/src/p_mobj.h"
extern int iquehead;
extern int iquetail;

void P_RespawnSpecials(void);
mobj_t *P_SpawnMobj(fixed_t x, fixed_t y, fixed_t z, mobjtype_t type);
void P_RemoveMobj(mobj_t *th);
boolean P_SetMobjState(mobj_t *mobj, statenum_t state);
void P_MobjThinker(mobj_t *mobj);
void P_SpawnPuff(fixed_t x, fixed_t y, fixed_t z);
void P_SpawnBlood(fixed_t x, fixed_t y, fixed_t z, int damage);
mobj_t *P_SpawnMissile(mobj_t *source, mobj_t *dest, mobjtype_t type);
void P_SpawnPlayerMissile(mobj_t *source, mobjtype_t type);
boolean P_IsDoomnumAllowed(int doomnum);
void P_SpawnMapThing (const mapthing_t* mthing);
void P_SpawnPlayer(int n, const mapthing_t *mthing);
void P_CheckMissileSpawn(mobj_t*);
void P_ExplodeMissile(mobj_t*);
# 49 "c:/devl/prboom3ds/src/d_player.h" 2




# 1 "c:/devl/prboom3ds/src/d_ticcmd.h" 1
# 49 "c:/devl/prboom3ds/src/d_ticcmd.h"
typedef struct
{
  signed char forwardmove;
  signed char sidemove;
  signed short angleturn;
  short consistancy;
  byte chatchar;
  byte buttons;
} ticcmd_t;
# 54 "c:/devl/prboom3ds/src/d_player.h" 2
# 63 "c:/devl/prboom3ds/src/d_player.h"
typedef enum
{

  PST_LIVE,

  PST_DEAD,

  PST_REBORN

} playerstate_t;





typedef enum
{

  CF_NOCLIP = 1,

  CF_GODMODE = 2,

  CF_NOMOMENTUM = 4

} cheat_t;





typedef struct player_s
{
  mobj_t* mo;
  playerstate_t playerstate;
  ticcmd_t cmd;




  fixed_t viewz;

  fixed_t viewheight;

  fixed_t deltaviewheight;

  fixed_t bob;






  fixed_t momx, momy;



  int health;
  int armorpoints;

  int armortype;


  int powers[NUMPOWERS];
  boolean cards[NUMCARDS];
  boolean backpack;


  int frags[4];
  weapontype_t readyweapon;


  weapontype_t pendingweapon;

  boolean weaponowned[NUMWEAPONS];
  int ammo[NUMAMMO];
  int maxammo[NUMAMMO];


  int attackdown;
  int usedown;



  int cheats;


  int refire;


  int killcount;
  int itemcount;
  int secretcount;


  const char* message;


  int damagecount;
  int bonuscount;


  mobj_t* attacker;


  int extralight;



  int fixedcolormap;



  int colormap;


  pspdef_t psprites[NUMPSPRITES];


  boolean didsecret;

} player_t;






typedef struct
{
  boolean in;


  int skills;
  int sitems;
  int ssecret;
  int stime;
  int frags[4];
  int score;

} wbplayerstruct_t;

typedef struct
{
  int epsd;


  boolean didsecret;


  int last;
  int next;

  int maxkills;
  int maxitems;
  int maxsecret;
  int maxfrags;


  int partime;


  int pnum;

  wbplayerstruct_t plyr[4];


  int totaltimes;

} wbstartstruct_t;
# 44 "c:/devl/prboom3ds/src/doomstat.h" 2
# 53 "c:/devl/prboom3ds/src/doomstat.h"
extern boolean nomonsters;
extern boolean respawnparm;
extern boolean fastparm;
extern boolean devparm;





extern GameMode_t gamemode;
extern GameMission_t gamemission;


extern boolean modifiedgame;


extern complevel_t compatibility_level, default_compatibility_level;







extern int pitched_sounds;

extern int default_translucency;
extern boolean general_translucency;

extern int demo_insurance, default_demo_insurance;




enum {
  comp_telefrag,
  comp_dropoff,
  comp_vile,
  comp_pain,
  comp_skull,
  comp_blazing,
  comp_doorlight,
  comp_model,
  comp_god,
  comp_falloff,
  comp_floors,
  comp_skymap,
  comp_pursuit,
  comp_doorstuck,
  comp_staylift,
  comp_zombie,
  comp_stairs,
  comp_infcheat,
  comp_zerotags,
  comp_moveblock,
  comp_respawn,
  comp_sound,
  comp_666,
  comp_soul,
  comp_maskedanim,
  COMP_NUM,
  COMP_TOTAL=32
};

extern int comp[COMP_TOTAL], default_comp[COMP_TOTAL];



extern Language_t language;






extern skill_t startskill;
extern int startepisode;
extern int startmap;

extern boolean autostart;


extern skill_t gameskill;
extern int gameepisode;
extern int gamemap;


extern boolean respawnmonsters;


extern boolean netgame;



extern boolean deathmatch;
# 160 "c:/devl/prboom3ds/src/doomstat.h"
extern int snd_SfxVolume;
extern int snd_MusicVolume;


extern unsigned int desired_screenwidth, desired_screenheight;





enum automapmode_e {
  am_active = 1,
  am_overlay= 2,
  am_rotate = 4,
  am_follow = 8,
  am_grid =16,
};
extern enum automapmode_e automapmode;

enum menuactive_e {
  mnact_inactive,
  mnact_float,
  mnact_full,
};
extern enum menuactive_e menuactive;

extern boolean paused;
extern boolean nodrawers;
extern boolean noblit;



extern int viewangleoffset;


extern int consoleplayer;
extern int displayplayer;





extern int totalkills, totallive;
extern int totalitems;
extern int totalsecret;


extern int basetic;
extern int leveltime;




extern boolean usergame;
extern boolean demoplayback;
extern boolean demorecording;
extern int demover;


extern boolean singledemo;

extern boolean timingdemo;

extern boolean fastdemo;

extern gamestate_t gamestate;







extern int gametic;



extern player_t players[4];


extern boolean playeringame[4];
extern boolean realplayeringame[4];

extern mapthing_t *deathmatchstarts;
extern size_t num_deathmatchstarts;

extern mapthing_t *deathmatch_p;


extern mapthing_t playerstarts[];



extern wbstartstruct_t wminfo;






extern FILE *debugfile;


extern boolean precache;



extern gamestate_t wipegamestate;

extern int mouseSensitivity_horiz;
extern int mouseSensitivity_vert;


extern boolean singletics;

extern int bodyqueslot;




extern int skyflatnum;

extern int maketic;




extern ticcmd_t netcmds[][12];
extern int ticdup;



extern int allow_pushers;
extern int default_allow_pushers;

extern int variable_friction;
extern int default_variable_friction;

extern int monsters_remember;
extern int default_monsters_remember;

extern int weapon_recoil;
extern int default_weapon_recoil;

extern int player_bobbing;
extern int default_player_bobbing;


extern int dogs, default_dogs;
extern int dog_jumping, default_dog_jumping;



extern int distfriend, default_distfriend;


extern int monster_backing, default_monster_backing;


extern int monster_avoid_hazards, default_monster_avoid_hazards;


extern int monster_friction, default_monster_friction;


extern int help_friends, default_help_friends;

extern int flashing_hom;

extern int doom_weapon_toggles;


extern int monster_infighting, default_monster_infighting;

extern int monkeys, default_monkeys;

extern int HelperThing;
# 43 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/dstrings.h" 1
# 50 "c:/devl/prboom3ds/src/dstrings.h"
# 1 "c:/devl/prboom3ds/src/d_englsh.h" 1
# 51 "c:/devl/prboom3ds/src/dstrings.h" 2
# 74 "c:/devl/prboom3ds/src/dstrings.h"
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stddef.h" 1 3 4
# 75 "c:/devl/prboom3ds/src/dstrings.h" 2

extern const size_t NUM_QUITMESSAGES;

extern const char* const endmsg[];
# 44 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/d_main.h" 1
# 37 "c:/devl/prboom3ds/src/d_main.h"
# 1 "c:/devl/prboom3ds/src/d_event.h" 1
# 47 "c:/devl/prboom3ds/src/d_event.h"
typedef enum
{
  ev_keydown,
  ev_keyup,
  ev_mouse,
  ev_joystick
} evtype_t;


typedef struct
{
  evtype_t type;
  int data1;
  int data2;
  int data3;
} event_t;


typedef enum
{
  ga_nothing,
  ga_loadlevel,
  ga_newgame,
  ga_loadgame,
  ga_savegame,
  ga_playdemo,
  ga_completed,
  ga_victory,
  ga_worlddone,
} gameaction_t;






typedef enum
{

  BT_ATTACK = 1,


  BT_USE = 2,


  BT_SPECIAL = 128,
  BT_SPECIALMASK = 3,



  BT_CHANGE = 4,



  BT_WEAPONMASK = (8+16+32+64),
  BT_WEAPONSHIFT = 3,


  BTS_LOADGAME = 0,

  BTS_PAUSE = 1,

  BTS_SAVEGAME = 2,
  BTS_RESTARTLEVEL= 3,


  BTS_SAVEMASK = (4+8+16),
  BTS_SAVESHIFT = 2,

} buttoncode_t;






extern gameaction_t gameaction;
# 38 "c:/devl/prboom3ds/src/d_main.h" 2
# 1 "c:/devl/prboom3ds/src/w_wad.h" 1
# 47 "c:/devl/prboom3ds/src/w_wad.h"
typedef struct
{
  char identification[4];
  int numlumps;
  int infotableofs;
} wadinfo_t;

typedef struct
{
  int filepos;
  int size;
  char name[8];
} filelump_t;







typedef enum {

  source_iwad=0,
  source_pre,
  source_auto_load,
  source_pwad,
  source_lmp,
  source_net
} wad_source_t;




typedef struct {
  const char* name;
  wad_source_t src;
  FILE* handle;
} wadfile_info_t;

extern wadfile_info_t *wadfiles;

extern size_t numwadfiles;

void W_Init(void);
void W_ReleaseAllWads(void);
void W_InitCache(void);
void W_DoneCache(void);

typedef struct
{


  char name[9];
  int size;


  int index, next;


  enum {
    ns_global=0,
    ns_sprites,
    ns_flats,
    ns_colormaps,
    ns_hires,
    ns_prboom
  } li_namespace;

  wadfile_info_t *wadfile;
  int position;
  wad_source_t source;
} lumpinfo_t;

extern lumpinfo_t *lumpinfo;
extern int numlumps;





int (W_FindNumFromName)(const char *name, int ns, int lump);
int W_ListNumFromName(const char *name, int lump);

static inline
int (W_CheckNumForName)(const char *name, int ns)
        { return (W_FindNumFromName)(name, ns, -1); }
int W_GetNumForName (const char* name);
int W_LumpLength (int lump);
void W_ReadLump (int lump, void *dest);

const void* W_CacheLumpNum (int lump);
const void* W_LockLumpNum(int lump);
void W_UnlockLumpNum(int lump);
int W_LumpIsCached(int lump);
# 149 "c:/devl/prboom3ds/src/w_wad.h"
char *AddDefaultExtension(char *, const char *);
void ExtractFileBase(const char *, char *);
unsigned W_LumpNameHash(const char *s);
void W_HashLumps(void);
# 39 "c:/devl/prboom3ds/src/d_main.h" 2







extern char *basesavegame;


extern boolean clnomonsters;
extern boolean clrespawnparm;
extern boolean clfastparm;


extern boolean nosfxparm;
extern boolean nomusicparm;
extern int ffmap;


void D_PostEvent(event_t* ev);


extern boolean advancedemo;
void D_AdvanceDemo(void);
void D_DoAdvanceDemo (void);





void D_Display(void);
void D_PageTicker(void);
void D_StartTitle(void);
void D_DoomMain(void);
void D_AddFile (const char *file, wad_source_t source);



extern const char *wad_files[2], *deh_files[2];
# 45 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/v_video.h" 1
# 43 "c:/devl/prboom3ds/src/v_video.h"
# 1 "c:/devl/prboom3ds/src/r_data.h" 1
# 39 "c:/devl/prboom3ds/src/r_data.h"
# 1 "c:/devl/prboom3ds/src/r_defs.h" 1
# 74 "c:/devl/prboom3ds/src/r_defs.h"
typedef struct
{
 union {
  struct {
   fixed_t x, y;
  };
  fixed_t v[2];
 };
} vertex_t;


typedef struct
{
  thinker_t thinker;
  fixed_t x, y, z;
} degenmobj_t;






typedef struct
{
  int iSectorID;
  boolean no_toptextures;
  boolean no_bottomtextures;
  fixed_t floorheight;
  fixed_t ceilingheight;
  int nexttag,firsttag;
  int soundtraversed;
  mobj_t *soundtarget;
  int blockbox[4];
  degenmobj_t soundorg;
  int validcount;
  mobj_t *thinglist;





  int friction,movefactor;


  void *floordata;
  void *ceilingdata;
  void *lightingdata;


  int stairlock;
  int prevsec;
  int nextsec;


  int heightsec;

  int bottommap, midmap, topmap;



  struct msecnode_s *touching_thinglist;

  int linecount;
  struct line_s **lines;
# 146 "c:/devl/prboom3ds/src/r_defs.h"
  int sky;


  fixed_t floor_xoffs, floor_yoffs;
  fixed_t ceiling_xoffs, ceiling_yoffs;


  int floorlightsec, ceilinglightsec;

  short floorpic;
  short ceilingpic;
  short lightlevel;
  short special;
  short oldspecial;
  short tag;



} sector_t;




typedef enum
{
  ST_HORIZONTAL,
  ST_VERTICAL,
  ST_POSITIVE,
  ST_NEGATIVE
} slopetype_t;

typedef struct line_s
{
  int iLineID;
  vertex_t *v1, *v2;
  fixed_t dx, dy;
  unsigned short flags;
  short special;
  short tag;
  unsigned short sidenum[2];
  fixed_t bbox[4];
  slopetype_t slopetype;
  sector_t *frontsector;
  sector_t *backsector;
  int validcount;
  void *specialdata;
  int tranlump;
  int firsttag,nexttag;
  int r_validcount;
  enum {
    RF_TOP_TILE = 1,
    RF_MID_TILE = 2,
    RF_BOT_TILE = 4,
    RF_IGNORE = 8,
    RF_CLOSED =16,
  } r_flags;
  degenmobj_t soundorg;
} line_t;
# 222 "c:/devl/prboom3ds/src/r_defs.h"
typedef struct msecnode_s
{
  sector_t *m_sector;
  struct mobj_s *m_thing;
  struct msecnode_s *m_tprev;
  struct msecnode_s *m_tnext;
  struct msecnode_s *m_sprev;
  struct msecnode_s *m_snext;
  boolean visited;
} msecnode_t;




typedef struct
{
  vertex_t *v1, *v2;
  fixed_t offset;
  angle_t angle;
  struct side_s* sidedef;
  line_t* linedef;

  int iSegID;

  float length;
  boolean miniseg;







  sector_t *frontsector, *backsector;
} seg_t;





typedef struct side_s
{
 fixed_t textureoffset;
 fixed_t rowoffset;
 short toptexture;
 short bottomtexture;
 short midtexture;
 sector_t* sector;





 int special;

 seg_t sideSeg;


} side_t;
# 291 "c:/devl/prboom3ds/src/r_defs.h"
typedef struct subsector_s
{
  sector_t *sector;
  int numlines, firstline;
} subsector_t;





typedef struct
{
  fixed_t x, y, dx, dy;
  fixed_t bbox[2][4];
  unsigned int children[2];
} node_t;
# 318 "c:/devl/prboom3ds/src/r_defs.h"
typedef byte lighttable_t;





typedef struct drawseg_s
{
  seg_t *curline;
  int x1, x2;
  fixed_t scale1, scale2, scalestep;
  int silhouette;
  fixed_t bsilheight;
  fixed_t tsilheight;


  fixed_t rw_offset, rw_distance, rw_centerangle;




  int *sprtopclip, *sprbottomclip, *maskedtexturecol;
} drawseg_t;


typedef struct
{
  int width,height;
  int leftoffset,topoffset;
  int lumpnum;
} patchnum_t;






typedef struct vissprite_s
{
  mobj_t *thing;
  boolean flip;
  int x1, x2;
  fixed_t gx, gy;
  fixed_t gz, gzt;
  fixed_t startfrac;
  fixed_t scale;
  fixed_t xiscale;
  fixed_t texturemid;
  int patch;
  uint_64_t mobjflags;


  const lighttable_t *colormap;


  int heightsec;

  boolean isplayersprite;
} vissprite_t;
# 394 "c:/devl/prboom3ds/src/r_defs.h"
typedef struct
{



  boolean rotate;


  short lump[8];


  byte flip[8];

} spriteframe_t;






typedef struct
{
  int numframes;
  spriteframe_t *spriteframes;
} spritedef_t;







typedef struct visplane
{
  struct visplane *next;
  int picnum, lightlevel, minx, maxx;
  fixed_t height;
  fixed_t xoffs, yoffs;
  unsigned int pad1;
  unsigned int top[400];
  unsigned int pad2, pad3;
  unsigned int bottom[400];
  unsigned int pad4;
} visplane_t;
# 40 "c:/devl/prboom3ds/src/r_data.h" 2
# 1 "c:/devl/prboom3ds/src/r_state.h" 1
# 40 "c:/devl/prboom3ds/src/r_state.h"
# 1 "c:/devl/prboom3ds/src/r_data.h" 1
# 41 "c:/devl/prboom3ds/src/r_state.h" 2
# 53 "c:/devl/prboom3ds/src/r_state.h"
extern fixed_t *textureheight;

extern int scaledviewwidth;

extern int firstflat, numflats;


extern int *flattranslation;
extern int *texturetranslation;


extern int firstspritelump;
extern int lastspritelump;
extern int numspritelumps;




extern int numsprites;
extern spritedef_t *sprites;

extern int numvertexes;
extern vertex_t *vertexes;

extern int numsegs;
extern seg_t *segs;

extern int numsectors;
extern sector_t *sectors;

extern int numsubsectors;
extern subsector_t *subsectors;

extern int numnodes;
extern node_t *nodes;

extern int numlines;
extern line_t *lines;

extern int numsides;
extern side_t *sides;





extern fixed_t viewx;
extern fixed_t viewy;
extern fixed_t viewz;
extern angle_t viewangle;
extern player_t *viewplayer;
extern angle_t clipangle;
extern int viewangletox[8192/2];
extern angle_t xtoviewangle[400 +1];
extern fixed_t rw_distance;
extern angle_t rw_normalangle;


extern int rw_angle1;

extern visplane_t *floorplane;
extern visplane_t *ceilingplane;
# 41 "c:/devl/prboom3ds/src/r_data.h" 2
# 1 "c:/devl/prboom3ds/src/r_patch.h" 1
# 36 "c:/devl/prboom3ds/src/r_patch.h"
typedef enum {
  RDRAW_EDGESLOPE_TOP_UP = (1<<0),
  RDRAW_EDGESLOPE_TOP_DOWN = (1<<1),
  RDRAW_EDGESLOPE_BOT_UP = (1<<2),
  RDRAW_EDGESLOPE_BOT_DOWN = (1<<3),
  RDRAW_EDGESLOPE_TOP_MASK = 0x3,
  RDRAW_EDGESLOPE_BOT_MASK = 0xc,
} edgeslope_t;

typedef struct {
  int topdelta;
  int length;
  edgeslope_t slope;
} rpost_t;

typedef struct {
  int numPosts;
  rpost_t *posts;
  unsigned char *pixels;
} rcolumn_t;

typedef struct {
  int width;
  int height;
  unsigned widthmask;

  unsigned char isNotTileable;

  int leftoffset;
  int topoffset;



  unsigned char *data;


  unsigned char *pixels;
  rcolumn_t *columns;
  rpost_t *posts;




  unsigned int locks;
} rpatch_t;


const rpatch_t *R_CachePatchNum(int id);
void R_UnlockPatchNum(int id);



const rpatch_t *R_CacheTextureCompositePatchNum(int id);
void R_UnlockTextureCompositePatchNum(int id);



int R_NumPatchWidth(int lump) ;
int R_NumPatchHeight(int lump);




const rcolumn_t *R_GetPatchColumnWrapped(const rpatch_t *patch, int columnIndex);
const rcolumn_t *R_GetPatchColumnClamped(const rpatch_t *patch, int columnIndex);




const rcolumn_t *R_GetPatchColumn(const rpatch_t *patch, int columnIndex);


void R_InitPatches();
void R_FlushAllPatches();
# 42 "c:/devl/prboom3ds/src/r_data.h" 2







typedef struct
{
  int originx, originy;
  int patch;
} texpatch_t;







typedef struct
{
  char name[8];
  int next, index;

  unsigned widthmask;

  short width, height;
  short patchcount;
  texpatch_t patches[1];
} texture_t;

extern int numtextures;
extern texture_t **textures;


const byte *R_GetTextureColumn(const rpatch_t *texpatch, int col);



void R_InitData (void);
void R_PrecacheLevel (void);





int R_FlatNumForName (const char* name);






int __attribute__((pure)) R_TextureNumForName (const char *name);
int __attribute__((pure)) R_SafeTextureNumForName (const char *name, int snum);
int __attribute__((pure)) R_CheckTextureNumForName (const char *name);

void R_InitTranMap(int);
int R_ColormapNumForName(const char *name);

const lighttable_t* R_ColourMap(int lightlevel, fixed_t spryscale);

extern const byte *main_tranmap, *tranmap;


void R_SetPatchNum(patchnum_t *patchnum, const char *name);
# 44 "c:/devl/prboom3ds/src/v_video.h" 2
# 55 "c:/devl/prboom3ds/src/v_video.h"
extern const byte *colrngs[];


typedef enum
{
  CR_BRICK,
  CR_TAN,
  CR_GRAY,
  CR_GREEN,
  CR_BROWN,
  CR_GOLD,
  CR_RED,
  CR_BLUE,
  CR_ORANGE,
  CR_YELLOW,
  CR_BLUE2,
  CR_LIMIT
} crange_idx_e;




typedef struct {
  byte *data;
  boolean not_on_heap;

  int width;
  int height;
  int byte_pitch;
  int short_pitch;
  int int_pitch;
} screeninfo_t;


extern screeninfo_t screens[6];
extern int usegamma;
# 105 "c:/devl/prboom3ds/src/v_video.h"
extern unsigned short *V_Palette15;
extern unsigned short *V_Palette16;
extern unsigned int *V_Palette32;






typedef enum {
  VID_MODE8,
  VID_MODE15,
  VID_MODE16,
  VID_MODE32,
  VID_MODEGL,
  VID_MODEMAX
} video_mode_t;

extern const char *default_videomode;

void V_InitMode(video_mode_t mode);


video_mode_t V_GetMode(void);
int V_GetModePixelDepth(video_mode_t mode);
int V_GetNumPixelBits(void);
int V_GetPixelDepth(void);


void V_InitColorTranslation(void);


void V_Init (void);


typedef void (*V_CopyRect_f)(int srcx, int srcy, int srcscrn,
                             int width, int height,
                             int destx, int desty, int destscrn,
                             enum patch_translation_e flags);
extern V_CopyRect_f V_CopyRect;


typedef void (*V_FillRect_f)(int scrn, int x, int y,
                             int width, int height, byte colour);
extern V_FillRect_f V_FillRect;





typedef void (*V_DrawNumPatch_f)(int x, int y, int scrn,
                                 int lump, int cm,
                                 enum patch_translation_e flags);
extern V_DrawNumPatch_f V_DrawNumPatch;
# 172 "c:/devl/prboom3ds/src/v_video.h"
typedef void (*V_DrawBackground_f)(const char* flatname, int scrn);
extern V_DrawBackground_f V_DrawBackground;

void V_DestroyUnusedTrueColorPalettes(void);

void V_SetPalette(int pal);




typedef void (*V_PlotPixel_f)(int,int,int,byte);
extern V_PlotPixel_f V_PlotPixel;

typedef struct
{
  int x, y;
} fpoint_t;

typedef struct
{
  fpoint_t a, b;
} fline_t;


typedef void (*V_DrawLine_f)(fline_t* fl, int color);
extern V_DrawLine_f V_DrawLine;

void V_AllocScreen(screeninfo_t *scrn);
void V_AllocScreens();
void V_FreeScreen(screeninfo_t *scrn);
void V_FreeScreens();
# 46 "c:/devl/prboom3ds/src/m_menu.c" 2

# 1 "c:/devl/prboom3ds/src/r_main.h" 1
# 48 "c:/devl/prboom3ds/src/r_main.h"
extern fixed_t viewcos;
extern fixed_t viewsin;
extern int viewwidth;
extern int viewheight;
extern int viewwindowx;
extern int viewwindowy;
extern int centerx;
extern int centery;
extern fixed_t centerxfrac;
extern fixed_t centeryfrac;
extern fixed_t viewheightfrac;
extern fixed_t projection;

extern fixed_t projectiony;
extern int validcount;





extern int rendered_visplanes, rendered_segs, rendered_vissprites;
extern boolean rendering_stats;
# 87 "c:/devl/prboom3ds/src/r_main.h"
extern const lighttable_t *(*zlight)[128];
extern const lighttable_t *fullcolormap;
extern int numcolormaps;
extern const lighttable_t **colormaps;


extern int extralight;
extern const lighttable_t *fixedcolormap;
# 105 "c:/devl/prboom3ds/src/r_main.h"
__attribute__((pure)) int R_PointOnSide(fixed_t x, fixed_t y, const node_t *node);
__attribute__((pure)) int R_PointOnSegSide(fixed_t x, fixed_t y, const seg_t *line);
angle_t R_PointToAngle(fixed_t x, fixed_t y);
angle_t R_PointToAngle2(fixed_t x1, fixed_t y1, fixed_t x2, fixed_t y2);
subsector_t *R_PointInSubsector(fixed_t x, fixed_t y);





void R_RenderPlayerView(player_t *player);
void R_Init(void);
void R_SetViewSize(int blocks);
void R_ExecuteSetViewSize(void);
# 48 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/hu_stuff.h" 1
# 60 "c:/devl/prboom3ds/src/hu_stuff.h"
void HU_Init(void);
void HU_Start(void);

boolean HU_Responder(event_t* ev);

void HU_Ticker(void);
void HU_Drawer(void);
char HU_dequeueChatChar(void);
void HU_Erase(void);
void HU_MoveHud(void);




extern int hudcolor_titl;
extern int hudcolor_xyco;

extern int hudcolor_mesg;
extern int hudcolor_chat;

extern int hudcolor_list;
extern int hud_list_bgon;
extern int hud_msg_lines;
extern int hud_distributed;

extern int hud_displayed;

extern int hud_active;
extern int hud_nosecrets;
# 49 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/g_game.h" 1
# 46 "c:/devl/prboom3ds/src/g_game.h"
boolean G_Responder(event_t *ev);
boolean G_CheckDemoStatus(void);
void G_DeathMatchSpawnPlayer(int playernum);
void G_InitNew(skill_t skill, int episode, int map);
void G_DeferedInitNew(skill_t skill, int episode, int map);
void G_DeferedPlayDemo(const char *demo);
void G_LoadGame(int slot, boolean is_command);
void G_ForcedLoadGame(void);
void G_DoLoadGame(void);
void G_SaveGame(int slot, char *description);
void G_BeginRecording(void);

void G_RecordDemo(const char *name);
void G_ExitLevel(void);
void G_SecretExitLevel(void);
void G_WorldDone(void);
void G_EndGame(void);
void G_Ticker(void);
void G_ReloadDefaults(void);
int G_SaveGameName(char *, size_t, int, boolean);
void G_SetFastParms(int);
void G_DoNewGame(void);
void G_DoReborn(int playernum);
void G_DoPlayDemo(void);
void G_DoCompleted(void);
void G_ReadDemoTiccmd(ticcmd_t *cmd);
void G_WriteDemoTiccmd(ticcmd_t *cmd);
void G_DoWorldDone(void);
void G_Compatibility(void);
const byte *G_ReadOptions(const byte *demo_p);
byte *G_WriteOptions(byte *demo_p);
void G_PlayerReborn(int player);
void G_RestartLevel(void);
void G_DoVictory(void);
void G_BuildTiccmd (ticcmd_t* cmd);
void G_ChangedPlayerColour(int pn, int cl);
void G_MakeSpecialEvent(buttoncode_t bc, ...);



void doom_printf(const char *, ...) __attribute__((format(printf,1,2)));



extern int key_right;
extern int key_left;
extern int key_up;
extern int key_down;
extern int key_menu_right;
extern int key_menu_left;
extern int key_menu_up;
extern int key_menu_down;
extern int key_menu_backspace;
extern int key_menu_escape;
extern int key_menu_enter;
extern int key_strafeleft;
extern int key_straferight;

extern int key_fire;
extern int key_use;
extern int key_strafe;
extern int key_speed;
extern int key_escape;
extern int key_savegame;
extern int key_loadgame;
extern int key_autorun;
extern int key_reverse;
extern int key_zoomin;
extern int key_zoomout;
extern int key_chat;
extern int key_backspace;
extern int key_enter;
extern int key_help;
extern int key_soundvolume;
extern int key_hud;
extern int key_quicksave;
extern int key_endgame;
extern int key_messages;
extern int key_quickload;
extern int key_quit;
extern int key_gamma;
extern int key_spy;
extern int key_pause;
extern int key_setup;
extern int key_forward;
extern int key_leftturn;
extern int key_rightturn;
extern int key_backward;
extern int key_weapontoggle;
extern int key_weapon1;
extern int key_weapon2;
extern int key_weapon3;
extern int key_weapon4;
extern int key_weapon5;
extern int key_weapon6;
extern int key_weapon7;
extern int key_weapon8;
extern int key_weapon9;
extern int destination_keys[4];
extern int key_map_right;
extern int key_map_left;
extern int key_map_up;
extern int key_map_down;
extern int key_map_zoomin;
extern int key_map_zoomout;
extern int key_map;
extern int key_map_gobig;
extern int key_map_follow;
extern int key_map_mark;
extern int key_map_clear;
extern int key_map_grid;
extern int key_map_rotate;
extern int key_map_overlay;
extern int key_screenshot;
extern int autorun;
extern int mousebfire;
extern int mousebstrafe;
extern int mousebforward;
extern int mousebbackward;
extern int mousebuse;
extern int mouse_double_click_use;
extern int joybfire;
extern int joybstrafe;
extern int joybuse;
extern int joybspeed;

extern int defaultskill;
extern boolean haswolflevels;

extern int bodyquesize;



extern int pars[4][10];
extern int cpars[32];


extern char savedescription[32];


extern const char * comp_lev_str[];
# 50 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/s_sound.h" 1
# 46 "c:/devl/prboom3ds/src/s_sound.h"
void S_Init(int sfxVolume, int musicVolume);


void S_Stop(void);






void S_Start(void);





void S_StartSound(void *origin, int sound_id);


void S_StartSoundAtVolume(void *origin, int sound_id, int volume);





void S_StopSound(void* origin);


void S_StartMusic(int music_id);


void S_ChangeMusic(int music_id, int looping);


void S_StopMusic(void);


void S_PauseSound(void);
void S_ResumeSound(void);




void S_UpdateSounds(void* listener);
void S_SetMusicVolume(int volume);
void S_SetSfxVolume(int volume);


extern int default_numChannels;
extern int numChannels;


extern int idmusnum;
# 51 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/sounds.h" 1
# 42 "c:/devl/prboom3ds/src/sounds.h"
struct sfxinfo_struct;

typedef struct sfxinfo_struct sfxinfo_t;

struct sfxinfo_struct {


  const char *name;


  int singularity;


  int priority;


  sfxinfo_t *link;


  int pitch;


  int volume;


  void *data;




  int usefulness;


  int lumpnum;
};





typedef struct {

  const char *name;


  int lumpnum;


  const void *data;


  int handle;
} musicinfo_t;


extern sfxinfo_t S_sfx[];


extern musicinfo_t S_music[];





typedef enum {
  mus_None,
  mus_e1m1,
  mus_e1m2,
  mus_e1m3,
  mus_e1m4,
  mus_e1m5,
  mus_e1m6,
  mus_e1m7,
  mus_e1m8,
  mus_e1m9,
  mus_e2m1,
  mus_e2m2,
  mus_e2m3,
  mus_e2m4,
  mus_e2m5,
  mus_e2m6,
  mus_e2m7,
  mus_e2m8,
  mus_e2m9,
  mus_e3m1,
  mus_e3m2,
  mus_e3m3,
  mus_e3m4,
  mus_e3m5,
  mus_e3m6,
  mus_e3m7,
  mus_e3m8,
  mus_e3m9,
  mus_inter,
  mus_intro,
  mus_bunny,
  mus_victor,
  mus_introa,
  mus_runnin,
  mus_stalks,
  mus_countd,
  mus_betwee,
  mus_doom,
  mus_the_da,
  mus_shawn,
  mus_ddtblu,
  mus_in_cit,
  mus_dead,
  mus_stlks2,
  mus_theda2,
  mus_doom2,
  mus_ddtbl2,
  mus_runni2,
  mus_dead2,
  mus_stlks3,
  mus_romero,
  mus_shawn2,
  mus_messag,
  mus_count2,
  mus_ddtbl3,
  mus_ampie,
  mus_theda3,
  mus_adrian,
  mus_messg2,
  mus_romer2,
  mus_tense,
  mus_shawn3,
  mus_openin,
  mus_evil,
  mus_ultima,
  mus_read_m,
  mus_dm2ttl,
  mus_dm2int,
  NUMMUSIC
} musicenum_t;





typedef enum {
  sfx_None,
  sfx_pistol,
  sfx_shotgn,
  sfx_sgcock,
  sfx_dshtgn,
  sfx_dbopn,
  sfx_dbcls,
  sfx_dbload,
  sfx_plasma,
  sfx_bfg,
  sfx_sawup,
  sfx_sawidl,
  sfx_sawful,
  sfx_sawhit,
  sfx_rlaunc,
  sfx_rxplod,
  sfx_firsht,
  sfx_firxpl,
  sfx_pstart,
  sfx_pstop,
  sfx_doropn,
  sfx_dorcls,
  sfx_stnmov,
  sfx_swtchn,
  sfx_swtchx,
  sfx_plpain,
  sfx_dmpain,
  sfx_popain,
  sfx_vipain,
  sfx_mnpain,
  sfx_pepain,
  sfx_slop,
  sfx_itemup,
  sfx_wpnup,
  sfx_oof,
  sfx_telept,
  sfx_posit1,
  sfx_posit2,
  sfx_posit3,
  sfx_bgsit1,
  sfx_bgsit2,
  sfx_sgtsit,
  sfx_cacsit,
  sfx_brssit,
  sfx_cybsit,
  sfx_spisit,
  sfx_bspsit,
  sfx_kntsit,
  sfx_vilsit,
  sfx_mansit,
  sfx_pesit,
  sfx_sklatk,
  sfx_sgtatk,
  sfx_skepch,
  sfx_vilatk,
  sfx_claw,
  sfx_skeswg,
  sfx_pldeth,
  sfx_pdiehi,
  sfx_podth1,
  sfx_podth2,
  sfx_podth3,
  sfx_bgdth1,
  sfx_bgdth2,
  sfx_sgtdth,
  sfx_cacdth,
  sfx_skldth,
  sfx_brsdth,
  sfx_cybdth,
  sfx_spidth,
  sfx_bspdth,
  sfx_vildth,
  sfx_kntdth,
  sfx_pedth,
  sfx_skedth,
  sfx_posact,
  sfx_bgact,
  sfx_dmact,
  sfx_bspact,
  sfx_bspwlk,
  sfx_vilact,
  sfx_noway,
  sfx_barexp,
  sfx_punch,
  sfx_hoof,
  sfx_metal,
  sfx_chgun,
  sfx_tink,
  sfx_bdopn,
  sfx_bdcls,
  sfx_itmbk,
  sfx_flame,
  sfx_flamst,
  sfx_getpow,
  sfx_bospit,
  sfx_boscub,
  sfx_bossit,
  sfx_bospn,
  sfx_bosdth,
  sfx_manatk,
  sfx_mandth,
  sfx_sssit,
  sfx_ssdth,
  sfx_keenpn,
  sfx_keendt,
  sfx_skeact,
  sfx_skesit,
  sfx_skeatk,
  sfx_radio,



  sfx_dgsit,
  sfx_dgatk,
  sfx_dgact,
  sfx_dgdth,
  sfx_dgpain,


  NUMSFX
} sfxenum_t;
# 52 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/m_menu.h" 1
# 48 "c:/devl/prboom3ds/src/m_menu.h"
boolean M_Responder (event_t *ev);




void M_Ticker (void);




void M_Drawer (void);




void M_Init (void);




void M_StartControlPanel (void);

void M_ForcedLoadGame(const char *msg);

void M_Trans(void);

void M_ResetMenu(void);

void M_DrawCredits(void);





extern int warning_about_changes, print_warning_about_changes;

extern boolean menu_background;
# 137 "c:/devl/prboom3ds/src/m_menu.h"
typedef enum {
  m_null,
  m_scrn,
  m_map,
  m_menu,
} setup_group;
# 161 "c:/devl/prboom3ds/src/m_menu.h"
typedef struct setup_menu_s
{
  const char *m_text;
  int m_flags;
  setup_group m_group;
  short m_x;
  short m_y;

  union
  {
    const void *var;
    int *m_key;
    const char *name;
    struct default_s *def;
    struct setup_menu_s *menu;
  } var;

  int *m_mouse;
  int *m_joy;
  void (*action)(void);
  const char **selectstrings;
} setup_menu_t;
# 53 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/d_deh.h" 1
# 45 "c:/devl/prboom3ds/src/d_deh.h"
void ProcessDehFile(const char *filename, const char *outfilename, int lumpnum);
# 62 "c:/devl/prboom3ds/src/d_deh.h"
extern const char *s_D_DEVSTR;

extern const char *s_D_CDROM;





extern const char *s_PRESSKEY;

extern const char *s_PRESSYN;

extern const char *s_QUITMSG;

extern const char *s_LOADNET;

extern const char *s_QLOADNET;

extern const char *s_QSAVESPOT;

extern const char *s_SAVEDEAD;

extern const char *s_QSPROMPT;

extern const char *s_QLPROMPT;






extern const char *s_NEWGAME;


extern const char *s_RESTARTLEVEL;






extern const char *s_NIGHTMARE;






extern const char *s_SWSTRING;

extern const char *s_LOADING;
extern const char *s_SAVING;


extern const char *s_MSGOFF;

extern const char *s_MSGON;

extern const char *s_NETEND;

extern const char *s_ENDGAME;


extern const char *s_DOSY;


extern const char *s_DETAILHI;

extern const char *s_DETAILLO;

extern const char *s_GAMMALVL0;

extern const char *s_GAMMALVL1;

extern const char *s_GAMMALVL2;

extern const char *s_GAMMALVL3;

extern const char *s_GAMMALVL4;

extern const char *s_EMPTYSTRING;





extern const char *s_GOTARMOR;

extern const char *s_GOTMEGA;

extern const char *s_GOTHTHBONUS;

extern const char *s_GOTARMBONUS;

extern const char *s_GOTSTIM;

extern const char *s_GOTMEDINEED;

extern const char *s_GOTMEDIKIT;

extern const char *s_GOTSUPER;


extern const char *s_GOTBLUECARD;

extern const char *s_GOTYELWCARD;

extern const char *s_GOTREDCARD;

extern const char *s_GOTBLUESKUL;

extern const char *s_GOTYELWSKUL;

extern const char *s_GOTREDSKULL;


extern const char *s_GOTINVUL;

extern const char *s_GOTBERSERK;

extern const char *s_GOTINVIS;

extern const char *s_GOTSUIT;

extern const char *s_GOTMAP;

extern const char *s_GOTVISOR;

extern const char *s_GOTMSPHERE;


extern const char *s_GOTCLIP;

extern const char *s_GOTCLIPBOX;

extern const char *s_GOTROCKET;

extern const char *s_GOTROCKBOX;

extern const char *s_GOTCELL;

extern const char *s_GOTCELLBOX;

extern const char *s_GOTSHELLS;

extern const char *s_GOTSHELLBOX;

extern const char *s_GOTBACKPACK;


extern const char *s_GOTBFG9000;

extern const char *s_GOTCHAINGUN;

extern const char *s_GOTCHAINSAW;

extern const char *s_GOTLAUNCHER;

extern const char *s_GOTPLASMA;

extern const char *s_GOTSHOTGUN;

extern const char *s_GOTSHOTGUN2;





extern const char *s_PD_BLUEO;

extern const char *s_PD_REDO;

extern const char *s_PD_YELLOWO;

extern const char *s_PD_BLUEK;

extern const char *s_PD_REDK;

extern const char *s_PD_YELLOWK;


extern const char *s_PD_BLUEC;

extern const char *s_PD_REDC;

extern const char *s_PD_YELLOWC;

extern const char *s_PD_BLUES;

extern const char *s_PD_REDS;

extern const char *s_PD_YELLOWS;

extern const char *s_PD_ANY;

extern const char *s_PD_ALL3;

extern const char *s_PD_ALL6;





extern const char *s_GGSAVED;





extern const char *s_HUSTR_MSGU;


extern const char *s_HUSTR_E1M1;

extern const char *s_HUSTR_E1M2;

extern const char *s_HUSTR_E1M3;

extern const char *s_HUSTR_E1M4;

extern const char *s_HUSTR_E1M5;

extern const char *s_HUSTR_E1M6;

extern const char *s_HUSTR_E1M7;

extern const char *s_HUSTR_E1M8;

extern const char *s_HUSTR_E1M9;


extern const char *s_HUSTR_E2M1;

extern const char *s_HUSTR_E2M2;

extern const char *s_HUSTR_E2M3;

extern const char *s_HUSTR_E2M4;

extern const char *s_HUSTR_E2M5;

extern const char *s_HUSTR_E2M6;

extern const char *s_HUSTR_E2M7;

extern const char *s_HUSTR_E2M8;

extern const char *s_HUSTR_E2M9;


extern const char *s_HUSTR_E3M1;

extern const char *s_HUSTR_E3M2;

extern const char *s_HUSTR_E3M3;

extern const char *s_HUSTR_E3M4;

extern const char *s_HUSTR_E3M5;

extern const char *s_HUSTR_E3M6;

extern const char *s_HUSTR_E3M7;

extern const char *s_HUSTR_E3M8;

extern const char *s_HUSTR_E3M9;


extern const char *s_HUSTR_E4M1;

extern const char *s_HUSTR_E4M2;

extern const char *s_HUSTR_E4M3;

extern const char *s_HUSTR_E4M4;

extern const char *s_HUSTR_E4M5;

extern const char *s_HUSTR_E4M6;

extern const char *s_HUSTR_E4M7;

extern const char *s_HUSTR_E4M8;

extern const char *s_HUSTR_E4M9;


extern const char *s_HUSTR_1;

extern const char *s_HUSTR_2;

extern const char *s_HUSTR_3;

extern const char *s_HUSTR_4;

extern const char *s_HUSTR_5;

extern const char *s_HUSTR_6;

extern const char *s_HUSTR_7;

extern const char *s_HUSTR_8;

extern const char *s_HUSTR_9;

extern const char *s_HUSTR_10;

extern const char *s_HUSTR_11;


extern const char *s_HUSTR_12;

extern const char *s_HUSTR_13;

extern const char *s_HUSTR_14;

extern const char *s_HUSTR_15;

extern const char *s_HUSTR_16;

extern const char *s_HUSTR_17;

extern const char *s_HUSTR_18;

extern const char *s_HUSTR_19;

extern const char *s_HUSTR_20;


extern const char *s_HUSTR_21;

extern const char *s_HUSTR_22;

extern const char *s_HUSTR_23;

extern const char *s_HUSTR_24;

extern const char *s_HUSTR_25;

extern const char *s_HUSTR_26;

extern const char *s_HUSTR_27;

extern const char *s_HUSTR_28;

extern const char *s_HUSTR_29;

extern const char *s_HUSTR_30;


extern const char *s_HUSTR_31;

extern const char *s_HUSTR_32;


extern const char *s_PHUSTR_1;

extern const char *s_PHUSTR_2;

extern const char *s_PHUSTR_3;

extern const char *s_PHUSTR_4;

extern const char *s_PHUSTR_5;

extern const char *s_PHUSTR_6;

extern const char *s_PHUSTR_7;

extern const char *s_PHUSTR_8;

extern const char *s_PHUSTR_9;

extern const char *s_PHUSTR_10;

extern const char *s_PHUSTR_11;


extern const char *s_PHUSTR_12;

extern const char *s_PHUSTR_13;

extern const char *s_PHUSTR_14;

extern const char *s_PHUSTR_15;

extern const char *s_PHUSTR_16;

extern const char *s_PHUSTR_17;

extern const char *s_PHUSTR_18;

extern const char *s_PHUSTR_19;

extern const char *s_PHUSTR_20;


extern const char *s_PHUSTR_21;

extern const char *s_PHUSTR_22;

extern const char *s_PHUSTR_23;

extern const char *s_PHUSTR_24;

extern const char *s_PHUSTR_25;

extern const char *s_PHUSTR_26;

extern const char *s_PHUSTR_27;

extern const char *s_PHUSTR_28;

extern const char *s_PHUSTR_29;

extern const char *s_PHUSTR_30;


extern const char *s_PHUSTR_31;

extern const char *s_PHUSTR_32;


extern const char *s_THUSTR_1;

extern const char *s_THUSTR_2;

extern const char *s_THUSTR_3;

extern const char *s_THUSTR_4;

extern const char *s_THUSTR_5;

extern const char *s_THUSTR_6;

extern const char *s_THUSTR_7;

extern const char *s_THUSTR_8;

extern const char *s_THUSTR_9;

extern const char *s_THUSTR_10;

extern const char *s_THUSTR_11;


extern const char *s_THUSTR_12;

extern const char *s_THUSTR_13;

extern const char *s_THUSTR_14;

extern const char *s_THUSTR_15;

extern const char *s_THUSTR_16;

extern const char *s_THUSTR_17;

extern const char *s_THUSTR_18;

extern const char *s_THUSTR_19;

extern const char *s_THUSTR_20;


extern const char *s_THUSTR_21;

extern const char *s_THUSTR_22;

extern const char *s_THUSTR_23;

extern const char *s_THUSTR_24;

extern const char *s_THUSTR_25;

extern const char *s_THUSTR_26;

extern const char *s_THUSTR_27;

extern const char *s_THUSTR_28;

extern const char *s_THUSTR_29;

extern const char *s_THUSTR_30;


extern const char *s_THUSTR_31;

extern const char *s_THUSTR_32;


extern const char *s_HUSTR_CHATMACRO1;

extern const char *s_HUSTR_CHATMACRO2;

extern const char *s_HUSTR_CHATMACRO3;

extern const char *s_HUSTR_CHATMACRO4;

extern const char *s_HUSTR_CHATMACRO5;

extern const char *s_HUSTR_CHATMACRO6;

extern const char *s_HUSTR_CHATMACRO7;

extern const char *s_HUSTR_CHATMACRO8;

extern const char *s_HUSTR_CHATMACRO9;

extern const char *s_HUSTR_CHATMACRO0;


extern const char *s_HUSTR_TALKTOSELF1;

extern const char *s_HUSTR_TALKTOSELF2;

extern const char *s_HUSTR_TALKTOSELF3;

extern const char *s_HUSTR_TALKTOSELF4;

extern const char *s_HUSTR_TALKTOSELF5;


extern const char *s_HUSTR_MESSAGESENT;





extern const char *s_HUSTR_PLRGREEN;

extern const char *s_HUSTR_PLRINDIGO;

extern const char *s_HUSTR_PLRBROWN;

extern const char *s_HUSTR_PLRRED;






extern const char* s_AMSTR_FOLLOWON;

extern const char* s_AMSTR_FOLLOWOFF;


extern const char* s_AMSTR_GRIDON;

extern const char* s_AMSTR_GRIDOFF;


extern const char* s_AMSTR_MARKEDSPOT;

extern const char* s_AMSTR_MARKSCLEARED;


extern const char* s_AMSTR_ROTATEON;
extern const char* s_AMSTR_ROTATEOFF;
extern const char* s_AMSTR_OVERLAYON;
extern const char* s_AMSTR_OVERLAYOFF;






extern const char* s_STSTR_MUS;

extern const char* s_STSTR_NOMUS;

extern const char* s_STSTR_DQDON;

extern const char* s_STSTR_DQDOFF;


extern const char* s_STSTR_KFAADDED;

extern const char* s_STSTR_FAADDED;


extern const char* s_STSTR_NCON;

extern const char* s_STSTR_NCOFF;


extern const char* s_STSTR_BEHOLD;

extern const char* s_STSTR_BEHOLDX;


extern const char* s_STSTR_CHOPPERS;

extern const char* s_STSTR_CLEV;
# 679 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_E1TEXT;
# 702 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_E2TEXT;
# 725 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_E3TEXT;
# 747 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_E4TEXT;
# 767 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C1TEXT;
# 791 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C2TEXT;
# 808 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C3TEXT;
# 831 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C4TEXT;
# 845 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C5TEXT;
# 856 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_C6TEXT;
# 876 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P1TEXT;
# 890 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P2TEXT;
# 908 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P3TEXT;
# 927 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P4TEXT;
# 938 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P5TEXT;
# 948 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_P6TEXT;
# 966 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T1TEXT;
# 981 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T2TEXT;
# 995 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T3TEXT;
# 1011 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T4TEXT;
# 1022 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T5TEXT;
# 1038 "c:/devl/prboom3ds/src/d_deh.h"
extern const char* s_T6TEXT;





extern const char* s_CC_ZOMBIE;

extern const char* s_CC_SHOTGUN;

extern const char* s_CC_HEAVY;

extern const char* s_CC_IMP;

extern const char* s_CC_DEMON;

extern const char* s_CC_LOST;

extern const char* s_CC_CACO;

extern const char* s_CC_HELL;

extern const char* s_CC_BARON;

extern const char* s_CC_ARACH;

extern const char* s_CC_PAIN;

extern const char* s_CC_REVEN;

extern const char* s_CC_MANCU;

extern const char* s_CC_ARCH;

extern const char* s_CC_SPIDER;

extern const char* s_CC_CYBER;

extern const char* s_CC_HERO;



extern const char* bgflatE1;

extern const char* bgflatE2;

extern const char* bgflatE3;

extern const char* bgflatE4;


extern const char* bgflat06;

extern const char* bgflat11;

extern const char* bgflat20;

extern const char* bgflat30;

extern const char* bgflat15;

extern const char* bgflat31;


extern const char* bgcastcall;



extern const char* startup1;

extern const char* startup2;

extern const char* startup3;

extern const char* startup4;

extern const char* startup5;


extern const char* savegamename;

void D_BuildBEXTables(void);
# 54 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/m_misc.h" 1
# 45 "c:/devl/prboom3ds/src/m_misc.h"
boolean M_WriteFile (char const* name,void* source,int length);

int M_ReadFile (char const* name,byte** buffer);

void M_ScreenShot (void);
void M_DoScreenShot (const char*);

void M_LoadDefaults (void);

void M_SaveDefaults (void);

struct default_s *M_LookupDefault(const char *name);






typedef struct default_s
{
  const char* name;
# 76 "c:/devl/prboom3ds/src/m_misc.h"
  struct {
    int* pi;
    const char** ppsz;
  } location;
  struct {
    int i;
    const char* psz;
  } defaultvalue;

  int minvalue;
  int maxvalue;
  enum {
    def_none,
    def_str,
    def_int,
    def_hex,
    def_bool = def_int,
    def_key = def_hex,
    def_mouseb = def_int,
    def_colour = def_hex
  } type;
  int setupscreen;
  int *current;



  struct setup_menu_s *setup_menu;
} default_t;
# 55 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/lprintf.h" 1
# 37 "c:/devl/prboom3ds/src/lprintf.h"
# 1 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdarg.h" 1 3 4
# 98 "c:\\devkitpro\\devkitarm\\lib\\gcc\\arm-none-eabi\\4.9.2\\include\\stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 38 "c:/devl/prboom3ds/src/lprintf.h" 2

typedef enum
{
  LO_INFO=1,
  LO_CONFIRM=2,
  LO_WARN=4,
  LO_ERROR=8,
  LO_FATAL=16,
  LO_DEBUG=32,
  LO_ALWAYS=64,
} OutputLevels;





extern int lprintf(OutputLevels pri, const char *fmt, ...) __attribute__((format(printf,2,3)));
extern int cons_output_mask;
extern int cons_error_mask;




void I_Error(const char *error, ...) __attribute__((format(printf,1,2)));
# 70 "c:/devl/prboom3ds/src/lprintf.h"
int doom_vsnprintf(char *buf, size_t max, const char *fmt, va_list va);
int doom_snprintf(char *buf, size_t max, const char *fmt, ...) __attribute__((format(printf,3,4)));
# 56 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/am_map.h" 1
# 48 "c:/devl/prboom3ds/src/am_map.h"
boolean AM_Responder (event_t* ev);


void AM_Ticker (void);



void AM_Drawer (void);



void AM_Stop (void);



extern void AM_Start(void);



extern void AM_clearMarks(void);

typedef struct
{
 fixed_t x,y;
} mpoint_t;

extern mpoint_t *markpoints;
extern int markpointnum, markpointnum_max;






extern int mapcolor_back;
extern int mapcolor_grid;
extern int mapcolor_wall;
extern int mapcolor_fchg;
extern int mapcolor_cchg;
extern int mapcolor_clsd;
extern int mapcolor_rkey;
extern int mapcolor_bkey;
extern int mapcolor_ykey;
extern int mapcolor_rdor;
extern int mapcolor_bdor;
extern int mapcolor_ydor;
extern int mapcolor_tele;
extern int mapcolor_secr;

extern int mapcolor_exit;
extern int mapcolor_unsn;
extern int mapcolor_flat;
extern int mapcolor_sprt;
extern int mapcolor_item;
extern int mapcolor_enemy;
extern int mapcolor_frnd;
extern int mapcolor_hair;
extern int mapcolor_sngl;
extern int mapcolor_plyr[4];
extern int mapcolor_me;

extern int map_secret_after;
# 57 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/i_main.h" 1
# 39 "c:/devl/prboom3ds/src/i_main.h"
void I_Init(void);
void I_SafeExit(int rc);

extern int (*I_GetTime)(void);
# 58 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/i_system.h" 1
# 42 "c:/devl/prboom3ds/src/i_system.h"
extern int ms_to_next_tick;
boolean I_StartDisplay(void);
void I_EndDisplay(void);
int I_GetTime_RealTime(void);

fixed_t I_GetTimeFrac (void);

void I_GetTime_SaveMS(void);

unsigned long I_GetRandomTimeSeed(void);

void I_uSleep(unsigned long usecs);




const char* I_GetVersionString(char* buf, size_t sz);




const char* I_SigString(char* buf, size_t sz, int signum);

const char *I_DoomExeDir(void);

boolean HasTrailingSlash(const char* dn);
char* I_FindFile(const char* wfname, const char* ext);


void I_Read(FILE* fd, void* buf, size_t sz);


int I_Filelength(FILE* handle);

void I_SetAffinityMask(void);
# 59 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/i_video.h" 1
# 44 "c:/devl/prboom3ds/src/i_video.h"
void I_PreInitGraphics(void);
void I_CalculateRes(unsigned int width, unsigned int height);
void I_SetRes(void);
void I_InitGraphics (void);
void I_UpdateVideoMode(void);
void I_ShutdownGraphics(void);


void I_SetPalette(int pal);

void I_UpdateNoBlit (void);
void I_FinishUpdate (void);

int I_ScreenShot (const char *fname);







void I_StartTic (void);
# 76 "c:/devl/prboom3ds/src/i_video.h"
void I_StartFrame (void);

extern int use_doublebuffer;
extern int use_fullscreen;
extern int desired_fullscreen;
# 60 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/i_sound.h" 1
# 48 "c:/devl/prboom3ds/src/i_sound.h"
void I_InitSound(void);


void I_ShutdownSound(void);






void I_SetChannels(void);


int I_GetSfxLumpNum (sfxinfo_t *sfxinfo);


int I_StartSound(int id, int channel, int vol, int sep, int pitch, int priority);


void I_StopSound(int handle);




boolean I_SoundIsPlaying(int handle);


boolean I_AnySoundStillPlaying(void);



void I_UpdateSoundParams(int handle, int vol, int sep, int pitch);




void I_InitMusic(void);
void I_ShutdownMusic(void);

void I_UpdateMusic(void);


void I_SetMusicVolume(int volume);


void I_PauseSong(int handle);
void I_ResumeSong(int handle);


int I_RegisterSong(const void *data, size_t len);


int I_RegisterMusic( const char* filename, musicinfo_t *music );





void I_PlaySong(int handle, int looping);


void I_StopSong(int handle);


void I_UnRegisterSong(int handle);


extern int snd_card;
extern int mus_card;

extern int snd_samplerate;
# 61 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/r_demo.h" 1
# 39 "c:/devl/prboom3ds/src/r_demo.h"
extern int demo_smoothturns;
extern int demo_smoothturnsfactor;

void R_SmoothPlaying_Reset(player_t *player);
void R_SmoothPlaying_Add(int delta);
angle_t R_SmoothPlaying_Get(angle_t defangle);
void R_ResetAfterTeleport(player_t *player);
# 62 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devl/prboom3ds/src/r_fps.h" 1
# 40 "c:/devl/prboom3ds/src/r_fps.h"
extern int movement_smooth;

typedef struct {
  fixed_t viewx;
  fixed_t viewy;
  fixed_t viewz;
  angle_t viewangle;
  angle_t viewpitch;
} view_vars_t;

extern view_vars_t original_view_vars;

typedef struct {
  unsigned int start;
  unsigned int next;
  unsigned int step;
  fixed_t frac;
  float msec;
} tic_vars_t;

extern tic_vars_t tic_vars;

void R_InitInterpolation(void);
void R_InterpolateView (player_t *player, fixed_t frac);

extern boolean WasRenderedInTryRunTics;

void R_ResetViewInterpolation ();
void R_UpdateInterpolations();
void R_StopAllInterpolations(void);
void R_DoInterpolations(fixed_t smoothratio);
void R_RestoreInterpolations();
void R_ActivateSectorInterpolations();
void R_ActivateThinkerInterpolations(thinker_t *th);
void R_StopInterpolationIfNeeded(thinker_t *th);
# 63 "c:/devl/prboom3ds/src/m_menu.c" 2
# 1 "c:/devkitPro/libctru/include/3ds.h" 1
       







# 1 "c:/devkitPro/libctru/include/3ds/svc.h" 1




       

typedef enum {
 MEMOP_FREE =1,
 MEMOP_ALLOC=3,
 MEMOP_MAP =4,
 MEMOP_UNMAP=5,
 MEMOP_PROT =6,

 MEMOP_FREE_LINEAR =0x10001,
 MEMOP_ALLOC_LINEAR=0x10003
} MemOp;

typedef enum {
 MEMPERM_READ = 1,
 MEMPERM_WRITE = 2,
 MEMPERM_EXECUTE = 4,
 MEMPERM_DONTCARE = 0x10000000,
 MEMPERM_MAX = 0xFFFFFFFF
} MemPerm;

typedef struct {
    u32 base_addr;
    u32 size;
    u32 perm;
    u32 state;
} MemInfo;

typedef struct {
    u32 flags;
} PageInfo;

typedef enum {
 ARBITER_FREE =0,
 ARBITER_ACQUIRE =1,
 ARBITER_KERNEL2 =2,
 ARBITER_ACQUIRE_TIMEOUT=3,
 ARBITER_KERNEL4 =4,
} ArbitrationType;

static inline void* getThreadLocalStorage(void)
{
 void* ret;
 asm volatile("mrc p15, 0, %[data], c13, c0, 3" : [data] "=r" (ret));
 return ret;
}

static inline u32* getThreadCommandBuffer(void)
{
 return (u32*)((u8*)getThreadLocalStorage() + 0x80);
}

s32 svcControlMemory(u32* addr_out, u32 addr0, u32 addr1, u32 size, MemOp op, MemPerm perm);
s32 svcQueryMemory(MemInfo* info, PageInfo* out, u32 addr);
void __attribute__((noreturn)) svcExitProcess();
s32 svcCreateThread(Handle* thread, ThreadFunc entrypoint, u32 arg, u32* stack_top, s32 thread_priority, s32 processor_id);
void __attribute__((noreturn)) svcExitThread();
void svcSleepThread(s64 ns);
s32 svcSetThreadPriority(Handle thread, s32 prio);
s32 svcCreateMutex(Handle* mutex, _Bool initially_locked);
s32 svcReleaseMutex(Handle handle);
s32 svcCreateSemaphore(Handle* semaphore, s32 initial_count, s32 max_count);
s32 svcReleaseSemaphore(s32* count, Handle semaphore, s32 release_count);
s32 svcCreateEvent(Handle* event, u8 reset_type);
s32 svcSignalEvent(Handle handle);
s32 svcClearEvent(Handle handle);
s32 svcCreateTimer(Handle* timer, u8 reset_type);
s32 svcSetTimer(Handle timer, s64 initial, s64 interval);
s32 svcCancelTimer(Handle timer);
s32 svcClearTimer(Handle timer);
s32 svcCreateMemoryBlock(Handle* memblock, u32 addr, u32 size, MemPerm my_perm, MemPerm other_perm);
s32 svcMapMemoryBlock(Handle memblock, u32 addr, MemPerm my_perm, MemPerm other_perm);
s32 svcUnmapMemoryBlock(Handle memblock, u32 addr);
s32 svcCreateAddressArbiter(Handle *arbiter);
s32 svcArbitrateAddress(Handle arbiter, u32 addr, ArbitrationType type, s32 value, s64 nanoseconds);
s32 svcWaitSynchronization(Handle handle, s64 nanoseconds);
s32 svcWaitSynchronizationN(s32* out, Handle* handles, s32 handles_num, _Bool wait_all, s64 nanoseconds);
s32 svcCloseHandle(Handle handle);
s32 svcDuplicateHandle(Handle* out, Handle original);
u64 svcGetSystemTick();
s32 svcGetSystemInfo(s64* out, u32 type, s32 param);
s32 svcGetProcessInfo(s64* out, Handle process, u32 type);
s32 svcConnectToPort(volatile Handle* out, const char* portName);
s32 svcSendSyncRequest(Handle session);
s32 svcGetProcessId(u32 *out, Handle handle);
s32 svcGetThreadId(u32 *out, Handle handle);
s32 svcOutputDebugString(const char* str, int length);
# 10 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/srv.h" 1
       

Result srvInit();
Result srvExit();
Result srvRegisterClient();
Result srvGetServiceHandle(Handle* out, const char* name);

Result srvPmInit();
Result srvRegisterProcess(u32 procid, u32 count, void *serviceaccesscontrol);
Result srvUnregisterProcess(u32 procid);
# 11 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/linear.h" 1
       


void* linearAlloc(size_t size);
void* linearMemAlign(size_t size, size_t alignment);
void* linearRealloc(void* mem, size_t size);
void linearFree(void* mem);
u32 linearSpaceFree();
# 12 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/vram.h" 1
       


void* vramAlloc(size_t size);
void* vramMemAlign(size_t size, size_t alignment);
void* vramRealloc(void* mem, size_t size);
void vramFree(void* mem);
u32 vramSpaceFree();
# 13 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/os.h" 1
       




u32 osConvertVirtToPhys(u32 vaddr);
u32 osConvertOldLINEARMemToNew(u32 addr);
const char* osStrError(u32 error);
u32 osGetFirmVersion();
u32 osGetKernelVersion();
u64 osGetTime();
# 14 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/gfx.h" 1
       

# 1 "c:/devkitPro/libctru/include/3ds/services/gsp.h" 1
       



typedef struct
{
 u32 active_framebuf;
 u32 *framebuf0_vaddr;
 u32 *framebuf1_vaddr;
 u32 framebuf_widthbytesize;
 u32 format;
 u32 framebuf_dispselect;
 u32 unk;
} GSP_FramebufferInfo;

typedef enum
{
 GSP_RGBA8_OES=0,
 GSP_BGR8_OES=1,
 GSP_RGB565_OES=2,
 GSP_RGB5_A1_OES=3,
 GSP_RGBA4_OES=4
}GSP_FramebufferFormats;

typedef struct
{
 u32 *framebuf0_vaddr;
 u32 *framebuf1_vaddr;
 u32 format;
 u32 framebuf_widthbytesize;
} GSP_CaptureInfoEntry;

typedef struct
{
 GSP_CaptureInfoEntry screencapture[2];
} GSP_CaptureInfo;

typedef enum
{
 GSPEVENT_PSC0 = 0,
 GSPEVENT_PSC1,
 GSPEVENT_VBlank0,
 GSPEVENT_VBlank1,
 GSPEVENT_PPF,
 GSPEVENT_P3D,
 GSPEVENT_DMA,

 GSPEVENT_MAX,
} GSP_Event;

Result gspInit();
void gspExit();

Result gspInitEventHandler(Handle gspEvent, vu8* gspSharedMem, u8 gspThreadId);
void gspExitEventHandler();
void gspWaitForEvent(GSP_Event id, _Bool nextEvent);
# 66 "c:/devkitPro/libctru/include/3ds/services/gsp.h"
Result GSPGPU_AcquireRight(Handle *handle, u8 flags);
Result GSPGPU_ReleaseRight(Handle *handle);
Result GSPGPU_ImportDisplayCaptureInfo(Handle* handle, GSP_CaptureInfo *captureinfo);
Result GSPGPU_SaveVramSysArea(Handle* handle);
Result GSPGPU_RestoreVramSysArea(Handle* handle);
Result GSPGPU_SetLcdForceBlack(Handle *handle, u8 flags);
Result GSPGPU_SetBufferSwap(Handle* handle, u32 screenid, GSP_FramebufferInfo *framebufinfo);
Result GSPGPU_FlushDataCache(Handle *handle, u8* adr, u32 size);
Result GSPGPU_InvalidateDataCache(Handle* handle, u8* adr, u32 size);
Result GSPGPU_WriteHWRegs(Handle *handle, u32 regAddr, u32* data, u8 size);
Result GSPGPU_WriteHWRegsWithMask(Handle* handle, u32 regAddr, u32* data, u8 datasize, u32* maskdata, u8 masksize);
Result GSPGPU_ReadHWRegs(Handle *handle, u32 regAddr, u32* data, u8 size);
Result GSPGPU_RegisterInterruptRelayQueue(Handle *handle, Handle eventHandle, u32 flags, Handle* outMemHandle, u8* threadID);
Result GSPGPU_UnregisterInterruptRelayQueue(Handle* handle);
Result GSPGPU_TriggerCmdReqQueue(Handle *handle);
Result GSPGPU_SubmitGxCommand(u32* sharedGspCmdBuf, u32 gxCommand[0x8], Handle* handle);
# 4 "c:/devkitPro/libctru/include/3ds/gfx.h" 2




typedef enum
{
 GFX_TOP = 0,
 GFX_BOTTOM = 1
}gfxScreen_t;

typedef enum
{
 GFX_LEFT = 0,
 GFX_RIGHT = 1,

}gfx3dSide_t;


void gfxInit();
void gfxExit();


void gfxSet3D(_Bool enable);
void gfxSetScreenFormat(gfxScreen_t screen, GSP_FramebufferFormats format);
GSP_FramebufferFormats gfxGetScreenFormat(gfxScreen_t screen);
void gfxSetDoubleBuffering(gfxScreen_t screen, _Bool doubleBuffering);
void gfxFlushBuffers();
void gfxSwapBuffers();
void gfxSwapBuffersGpu();


u8* gfxGetFramebuffer(gfxScreen_t screen, gfx3dSide_t side, u16* width, u16* height);


extern u8* gfxTopLeftFramebuffers[2];
extern u8* gfxTopRightFramebuffers[2];
extern u8* gfxBottomFramebuffers[2];
extern u32* gxCmdBuf;
# 15 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/console.h" 1
# 26 "c:/devkitPro/libctru/include/3ds/console.h"
typedef _Bool(* ConsolePrint)(void* con, char c);


typedef struct ConsoleFont
{
 u8* gfx;
 u16 asciiOffset;
 u16 numChars;

}ConsoleFont;
# 64 "c:/devkitPro/libctru/include/3ds/console.h"
typedef struct PrintConsole
{
 ConsoleFont font;

 u16 *frameBuffer;

 int cursorX;
 int cursorY;

 int prevCursorX;
 int prevCursorY;

 int consoleWidth;
 int consoleHeight;

 int windowX;
 int windowY;
 int windowWidth;
 int windowHeight;

 int tabSize;
 int fg;
 int bg;
 int flags;

 ConsolePrint PrintChar;


 _Bool consoleInitialised;
}PrintConsole;
# 106 "c:/devkitPro/libctru/include/3ds/console.h"
typedef enum {
 debugDevice_NULL,
 debugDevice_3DMOO,
 debugDevice_CONSOLE,
} debugDevice;





void consoleSetFont(PrintConsole* console, ConsoleFont* font);
# 125 "c:/devkitPro/libctru/include/3ds/console.h"
void consoleSetWindow(PrintConsole* console, int x, int y, int width, int height);





PrintConsole* consoleGetDefault(void);





PrintConsole *consoleSelect(PrintConsole* console);






PrintConsole* consoleInit(gfxScreen_t screen, PrintConsole* console);




void consoleDebugInit(debugDevice device);



void consoleClear(void);
# 16 "c:/devkitPro/libctru/include/3ds.h" 2

# 1 "c:/devkitPro/libctru/include/3ds/services/ac.h" 1
       

Result acInit();
Result acExit();

Result ACU_GetWifiStatus(Handle* servhandle, u32 *out);
Result ACU_WaitInternetConnection();
# 18 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/apt.h" 1
       




typedef enum{
 APPID_HOMEMENU = 0x101,
 APPID_CAMERA = 0x110,
 APPID_WEB = 0x114,
 APPID_APPLICATION = 0x300,
}NS_APPID;

typedef enum{
 APP_NOTINITIALIZED,
 APP_RUNNING,
 APP_SUSPENDED,
 APP_EXITING,
 APP_SUSPENDING,
 APP_SLEEPMODE,
 APP_PREPARE_SLEEPMODE,
 APP_APPLETSTARTED,
 APP_APPLETCLOSED
}APP_STATUS;

enum {
 APTSIGNAL_HOMEBUTTON = 1,

 APTSIGNAL_PREPARESLEEP = 3,

 APTSIGNAL_ENTERSLEEP = 5,
 APTSIGNAL_WAKEUP = 6,
 APTSIGNAL_ENABLE = 7,
 APTSIGNAL_POWERBUTTON = 8,
 APTSIGNAL_UTILITY = 9,
 APTSIGNAL_SLEEPSYSTEM = 10,
 APTSIGNAL_ERROR = 11
};


extern Handle aptEvents[3];

Result aptInit();
void aptExit();
void aptOpenSession();
void aptCloseSession();
void aptSetStatus(APP_STATUS status);
APP_STATUS aptGetStatus();
u32 aptGetStatusPower();
void aptSetStatusPower(u32 status);
void aptReturnToMenu();
void aptWaitStatusEvent();
void aptSignalReadyForSleep();
NS_APPID aptGetMenuAppID();
_Bool aptMainLoop();

Result APT_GetLockHandle(Handle* handle, u16 flags, Handle* lockHandle);
Result APT_Initialize(Handle* handle, NS_APPID appId, Handle* eventHandle1, Handle* eventHandle2);
Result APT_HardwareResetAsync(Handle* handle);
Result APT_Enable(Handle* handle, u32 a);
Result APT_GetAppletManInfo(Handle* handle, u8 inval, u8 *outval8, u32 *outval32, NS_APPID *menu_appid, NS_APPID *active_appid);
Result APT_PrepareToJumpToHomeMenu(Handle* handle);
Result APT_JumpToHomeMenu(Handle* handle, u32 a, u32 b, u32 c);
Result APT_IsRegistered(Handle* handle, NS_APPID appID, u8* out);
Result APT_InquireNotification(Handle* handle, u32 appID, u8* signalType);
Result APT_NotifyToWait(Handle* handle, NS_APPID appID);
Result APT_AppletUtility(Handle* handle, u32* out, u32 a, u32 size1, u8* buf1, u32 size2, u8* buf2);
Result APT_GlanceParameter(Handle* handle, NS_APPID appID, u32 bufferSize, u32* buffer, u32* actualSize, u8* signalType);
Result APT_ReceiveParameter(Handle* handle, NS_APPID appID, u32 bufferSize, u32* buffer, u32* actualSize, u8* signalType);
Result APT_SendParameter(Handle* handle, NS_APPID src_appID, NS_APPID dst_appID, u32 bufferSize, u32* buffer, Handle paramhandle, u8 signalType);
Result APT_SendCaptureBufferInfo(Handle* handle, u32 bufferSize, u32* buffer);
Result APT_ReplySleepQuery(Handle* handle, NS_APPID appID, u32 a);
Result APT_ReplySleepNotificationComplete(Handle* handle, NS_APPID appID);
Result APT_PrepareToCloseApplication(Handle* handle, u8 a);
Result APT_CloseApplication(Handle* handle, u32 a, u32 b, u32 c);
Result APT_SetAppCpuTimeLimit(Handle* handle, u32 percent);
Result APT_GetAppCpuTimeLimit(Handle* handle, u32 *percent);
Result APT_CheckNew3DS_Application(Handle* handle, u8 *out);
Result APT_CheckNew3DS_System(Handle* handle, u8 *out);
Result APT_CheckNew3DS(Handle* handle, u8 *out);
Result APT_PrepareToDoAppJump(Handle* handle, u8 flags, u64 programID, u8 mediatype);
Result APT_DoAppJump(Handle* handle, u32 NSbuf0Size, u32 NSbuf1Size, u8 *NSbuf0Ptr, u8 *NSbuf1Ptr);
Result APT_PrepareToStartLibraryApplet(Handle* handle, NS_APPID appID);
Result APT_StartLibraryApplet(Handle* handle, NS_APPID appID, Handle inhandle, u32 *parambuf, u32 parambufsize);
Result APT_LaunchLibraryApplet(NS_APPID appID, Handle inhandle, u32 *parambuf, u32 parambufsize);
# 19 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/cfgnor.h" 1
       

Result CFGNOR_Initialize(u8 value);
Result CFGNOR_Shutdown();
Result CFGNOR_ReadData(u32 offset, u32 *buf, u32 size);
Result CFGNOR_WriteData(u32 offset, u32 *buf, u32 size);
Result CFGNOR_DumpFlash(u32 *buf, u32 size);
Result CFGNOR_WriteFlash(u32 *buf, u32 size);
# 20 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/cfgu.h" 1
       

Result initCfgu(void);
Result exitCfgu(void);

Result CFGU_GetRegionCanadaUSA(u8* value);
Result CFGU_GetSystemModel(u8* model);
Result CFGU_GetModelNintendo2DS(u8* value);
Result CFGU_GetCountryCodeString(u16 code, u16* string);
Result CFGU_GetCountryCodeID(u16 string, u16* code);
# 21 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/csnd.h" 1
       



typedef enum{
    CSND_LOOP_DISABLE,
    CSND_LOOP_ENABLE
} CSND_LOOPING;

typedef enum{
    CSND_ENCODING_PCM8,
    CSND_ENCODING_PCM16,
    CSND_ENCODING_IMA_ADPCM,
    CSND_ENCODING_PSG
} CSND_ENCODING;




Result CSND_initialize(u32* sharedMem);
Result CSND_shutdown();

Result CSND_playsound(u32 channel, u32 looping, u32 encoding, u32 samplerate, u32 *vaddr0, u32 *vaddr1, u32 totalbytesize, u32 unk0, u32 unk1);
void CSND_setchannel_playbackstate(u32 channel, u32 value);
void CSND_sharedmemtype0_cmd0(u32 channel, u32 value);
void CSND_writesharedmem_cmdtype0(u16 cmdid, u8 *cmdparams);
Result CSND_sharedmemtype0_cmdupdatestate(int waitdone);

Result CSND_getchannelstate(u32 entryindex, u32 *out);
Result CSND_getchannelstate_isplaying(u32 entryindex, u8 *status);
# 22 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/fs.h" 1
       
# 60 "c:/devkitPro/libctru/include/3ds/services/fs.h"
typedef enum
{
 PATH_INVALID = 0,
 PATH_EMPTY = 1,
 PATH_BINARY = 2,
 PATH_CHAR = 3,
 PATH_WCHAR = 4,
} FS_pathType;


typedef enum
{
 ARCH_ROMFS = 0x3,
 ARCH_SAVEDATA = 0x4,
 ARCH_EXTDATA = 0x6,
 ARCH_SHARED_EXTDATA = 0x7,
 ARCH_SYSTEM_SAVEDATA = 0x8,
 ARCH_SDMC = 0x9,
 ARCH_SDMC_WRITE_ONLY = 0xA,
 ARCH_BOSS_EXTDATA = 0x12345678,
 ARCH_CARD_SPIFS = 0x12345679,
 ARCH_NAND_RW = 0x1234567D,
 ARCH_NAND_RO = 0x1234567E,
 ARCH_NAND_RO_WRITE_ACCESS = 0x1234567F,
} FS_archiveIds;


typedef struct
{
 FS_pathType type;
 u32 size;
 const u8 *data;
} FS_path;


typedef struct
{
 u32 id;
 FS_path lowPath;
 Handle handleLow;
 Handle handleHigh;
} FS_archive;


typedef struct
{

  u16 name[0x106];

  u8 shortName[0x09];

  u8 unknown1;

  u8 shortExt[0x04];

  u8 unknown2;

  u8 unknown3;

  u8 isDirectory;

  u8 isHidden;

  u8 isArchive;

  u8 isReadOnly;

  u64 fileSize;
} FS_dirent;

Result fsInit(void);
Result fsExit(void);

FS_path FS_makePath(FS_pathType type, const char *path);

Result FSUSER_Initialize(Handle* handle);
Result FSUSER_OpenArchive(Handle* handle, FS_archive* archive);
Result FSUSER_OpenDirectory(Handle* handle, Handle* out, FS_archive archive, FS_path dirLowPath);
Result FSUSER_OpenFile(Handle* handle, Handle* out, FS_archive archive, FS_path fileLowPath, u32 openflags, u32 attributes);
Result FSUSER_OpenFileDirectly(Handle* handle, Handle* out, FS_archive archive, FS_path fileLowPath, u32 openflags, u32 attributes);
Result FSUSER_CloseArchive(Handle* handle, FS_archive* archive);
Result FSUSER_CreateFile(Handle* handle, FS_archive archive, FS_path fileLowPath, u32 fileSize);
Result FSUSER_CreateDirectory(Handle* handle, FS_archive archive, FS_path dirLowPath);
Result FSUSER_DeleteFile(Handle *handle, FS_archive archive, FS_path fileLowPath);
Result FSUSER_DeleteDirectory(Handle *handle, FS_archive archive, FS_path dirLowPath);
Result FSUSER_RenameFile(Handle *handle, FS_archive srcArchive, FS_path srcFileLowPath, FS_archive destArchive, FS_path destFileLowPath);
Result FSUSER_RenameDirectory(Handle *handle, FS_archive srcArchive, FS_path srcDirLowPath, FS_archive destArchive, FS_path destDirLowPath);
Result FSUSER_GetSdmcArchiveResource(Handle *handle, u32 *sectorSize, u32 *clusterSize, u32 *numClusters, u32 *freeClusters);
Result FSUSER_IsSdmcDetected(Handle *handle, u8 *detected);
Result FSUSER_IsSdmcWritable(Handle *handle, u8 *writable);

Result FSFILE_Close(Handle handle);
Result FSFILE_Read(Handle handle, u32 *bytesRead, u64 offset, void *buffer, u32 size);
Result FSFILE_Write(Handle handle, u32 *bytesWritten, u64 offset, const void *buffer, u32 size, u32 flushFlags);
Result FSFILE_GetSize(Handle handle, u64 *size);
Result FSFILE_SetSize(Handle handle, u64 size);
Result FSFILE_GetAttributes(Handle handle, u32 *attributes);
Result FSFILE_SetAttributes(Handle handle, u32 attributes);
Result FSFILE_Flush(Handle handle);

Result FSDIR_Read(Handle handle, u32 *entriesRead, u32 entrycount, FS_dirent *buffer);
Result FSDIR_Close(Handle handle);
# 23 "c:/devkitPro/libctru/include/3ds.h" 2

# 1 "c:/devkitPro/libctru/include/3ds/services/hid.h" 1
       





typedef enum
{
 KEY_A = (1U<<(0)),
 KEY_B = (1U<<(1)),
 KEY_SELECT = (1U<<(2)),
 KEY_START = (1U<<(3)),
 KEY_DRIGHT = (1U<<(4)),
 KEY_DLEFT = (1U<<(5)),
 KEY_DUP = (1U<<(6)),
 KEY_DDOWN = (1U<<(7)),
 KEY_R = (1U<<(8)),
 KEY_L = (1U<<(9)),
 KEY_X = (1U<<(10)),
 KEY_Y = (1U<<(11)),
 KEY_ZL = (1U<<(14)),
 KEY_ZR = (1U<<(15)),
 KEY_TOUCH = (1U<<(20)),
 KEY_CSTICK_RIGHT = (1U<<(24)),
 KEY_CSTICK_LEFT = (1U<<(25)),
 KEY_CSTICK_UP = (1U<<(26)),
 KEY_CSTICK_DOWN = (1U<<(27)),
 KEY_CPAD_RIGHT = (1U<<(28)),
 KEY_CPAD_LEFT = (1U<<(29)),
 KEY_CPAD_UP = (1U<<(30)),
 KEY_CPAD_DOWN = (1U<<(31)),


 KEY_UP = KEY_DUP | KEY_CPAD_UP,
 KEY_DOWN = KEY_DDOWN | KEY_CPAD_DOWN,
 KEY_LEFT = KEY_DLEFT | KEY_CPAD_LEFT,
 KEY_RIGHT = KEY_DRIGHT | KEY_CPAD_RIGHT,
} PAD_KEY;

typedef struct
{
 u16 px, py;
} touchPosition;

typedef struct
{
 s16 dx, dy;
} circlePosition;

typedef struct
{
 s16 x;
 s16 y;
 s16 z;
} accelVector;

typedef struct
{
 s16 x;
 s16 z;
 s16 y;
} angularRate;

typedef enum
{
 HIDEVENT_PAD0 = 0,
 HIDEVENT_PAD1,
 HIDEVENT_Accel,
 HIDEVENT_Gyro,
 HIDEVENT_DebugPad,

 HIDEVENT_MAX,
} HID_Event;

extern Handle hidMemHandle;
extern vu32* hidSharedMem;

Result hidInit(u32* sharedMem);
void hidExit();

void hidScanInput();
u32 hidKeysHeld();
u32 hidKeysDown();
u32 hidKeysUp();
void hidTouchRead(touchPosition* pos);
void hidCircleRead(circlePosition* pos);
void hidAccelRead(accelVector* vector);
void hidGyroRead(angularRate* rate);

void hidWaitForEvent(HID_Event id, _Bool nextEvent);
# 100 "c:/devkitPro/libctru/include/3ds/services/hid.h"
Result HIDUSER_GetHandles(Handle* outMemHandle, Handle *eventpad0, Handle *eventpad1, Handle *eventaccel, Handle *eventgyro, Handle *eventdebugpad);
Result HIDUSER_EnableAccelerometer();
Result HIDUSER_DisableAccelerometer();
Result HIDUSER_EnableGyroscope();
Result HIDUSER_DisableGyroscope();
Result HIDUSER_GetGyroscopeRawToDpsCoefficient(float *coeff);
Result HIDUSER_GetSoundVolume(u8 *volume);
# 25 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/irrst.h" 1
       







extern Handle irrstMemHandle;
extern vu32* irrstSharedMem;

Result irrstInit(u32* sharedMem);
void irrstExit();

void irrstScanInput();
u32 irrstKeysHeld();
void irrstCstickRead(circlePosition* pos);

void irrstWaitForEvent(_Bool nextEvent);



Result IRRST_GetHandles(Handle* outMemHandle, Handle* outEventHandle);
Result IRRST_Initialize(u32 unk1, u8 unk2);
Result IRRST_Shutdown(void);
# 26 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/httpc.h" 1
       

typedef struct {
 Handle servhandle;
 u32 httphandle;
} httpcContext;

typedef enum{
 HTTPCREQSTAT_INPROGRESS_REQSENT = 0x5,
 HTTPCREQSTAT_DLREADY = 0x7
} httpcReqStatus;



Result httpcInit();
void httpcExit();

Result httpcOpenContext(httpcContext *context, char* url, u32 use_defaultproxy);
Result httpcCloseContext(httpcContext *context);
Result httpcBeginRequest(httpcContext *context);
Result httpcReceiveData(httpcContext *context, u8* buffer, u32 size);
Result httpcGetRequestState(httpcContext *context, httpcReqStatus* out);
Result httpcGetDownloadSizeState(httpcContext *context, u32* downloadedsize, u32* contentsize);
Result httpcGetResponseStatusCode(httpcContext *context, u32* out, u64 delay);

Result httpcDownloadData(httpcContext *context, u8* buffer, u32 size, u32 *downloadedsize);



Result HTTPC_Initialize(Handle handle);
Result HTTPC_InitializeConnectionSession(Handle handle, Handle contextHandle);
Result HTTPC_CreateContext(Handle handle, char* url, Handle* contextHandle);
Result HTTPC_CloseContext(Handle handle, Handle contextHandle);
Result HTTPC_SetProxyDefault(Handle handle, Handle contextHandle);
Result HTTPC_AddRequestHeaderField(Handle handle, Handle contextHandle, char* name, char* value);
Result HTTPC_BeginRequest(Handle handle, Handle contextHandle);
Result HTTPC_ReceiveData(Handle handle, Handle contextHandle, u8* buffer, u32 size);
Result HTTPC_GetRequestState(Handle handle, Handle contextHandle, httpcReqStatus* out);
Result HTTPC_GetDownloadSizeState(Handle handle, Handle contextHandle, u32* downloadedsize, u32* contentsize);
Result HTTPC_GetResponseStatusCode(Handle handle, Handle contextHandle, u32* out);
# 27 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/ir.h" 1
       

Result IRU_Initialize(u32 *sharedmem_addr, u32 sharedmem_size);
Result IRU_Shutdown();
Handle IRU_GetServHandle();
Result IRU_SendData(u8 *buf, u32 size, u32 wait);
Result IRU_RecvData(u8 *buf, u32 size, u8 flag, u32 *transfercount, u32 wait);
Result IRU_SetBitRate(u8 value);
Result IRU_GetBitRate(u8 *out);
Result IRU_SetIRLEDState(u32 value);
Result IRU_GetIRLEDRecvState(u32 *out);
# 28 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/ptm.h" 1
       

Result ptmInit();
Result ptmExit();

Result PTMU_GetShellState(Handle* servhandle, u8 *out);
Result PTMU_GetBatteryLevel(Handle* servhandle, u8 *out);
Result PTMU_GetBatteryChargeState(Handle* servhandle, u8 *out);
Result PTMU_GetPedometerState(Handle* servhandle, u8 *out);
Result PTMU_GetTotalStepCount(Handle* servhandle, u32 *steps);
# 29 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/soc.h" 1
       

Result SOC_Initialize(u32 *context_addr, u32 context_size);
Result SOC_Shutdown();
int SOC_GetErrno();

Result SOC_Shutdown(void);
int SOC_GetErrno(void);


long gethostid(void);
# 30 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/mic.h" 1
       



Result MIC_Initialize(u32 *sharedmem, u32 sharedmem_size, u8 control, u8 recording, u8 unk0, u8 unk1, u8 unk2);
Result MIC_Shutdown();
u32 MIC_GetSharedMemOffsetValue();
u32 MIC_ReadAudioData(u8 *outbuf, u32 readsize, u32 waitforevent);

Result MIC_MapSharedMem(Handle handle, u32 size);
Result MIC_UnmapSharedMem();
Result MIC_cmd3_Initialize(u8 unk0, u8 unk1, u32 sharedmem_baseoffset, u32 sharedmem_endoffset, u8 unk2);
Result MIC_cmd5();
Result MIC_GetCNTBit15(u8 *out);
Result MIC_GetEventHandle(Handle *handle);
Result MIC_SetControl(u8 value);
Result MIC_GetControl(u8 *value);
Result MIC_SetRecording(u8 value);
Result MIC_IsRecoding(u8 *value);
# 31 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/services/mvd.h" 1
       



typedef enum {
 MVDMODE_COLORFORMATCONV,
 MVDMODE_VIDEOPROCESSING
} mvdstdMode;

typedef enum {
 MVDTYPEIN_YUYV422 = 0x00010001,
 MVDTYPEIN_H264 = 0x00020001
} mvdstdTypeInput;

typedef enum {
 MVDTYPEOUT_RGB565 = 0x00040002
} mvdstdTypeOutput;

typedef struct {
 mvdstdTypeInput input_type;
 u32 unk_x04;
 u32 unk_x08;
 u32 inwidth, inheight;
 u32 physaddr_colorconv_indata;
 u32 unk_x18[0x28>>2];
 u32 flag_x40;
 u32 unk_x44;
 u32 unk_x48;
 u32 outheight0, outwidth0;
 u32 unk_x54;
 mvdstdTypeOutput output_type;
 u32 outwidth1, outheight1;
 u32 physaddr_outdata0;
 u32 physaddr_outdata1_colorconv;
 u32 unk_x6c[0xb0>>2];
} mvdstdConfig;

void mvdstdGenerateDefaultConfig(mvdstdConfig *config, u32 input_width, u32 input_height, u32 output_width, u32 output_height, u32 *vaddr_colorconv_indata, u32 *vaddr_outdata0, u32 *vaddr_outdata1_colorconv);

Result mvdstdInit(mvdstdMode mode, mvdstdTypeInput input_type, mvdstdTypeOutput output_type, u32 size);
Result mvdstdShutdown();

Result mvdstdSetConfig(mvdstdConfig *config);
Result mvdstdProcessFrame(mvdstdConfig *config, u32 *h264_vaddr_inframe, u32 h264_inframesize, u32 h264_frameid);
# 32 "c:/devkitPro/libctru/include/3ds.h" 2

# 1 "c:/devkitPro/libctru/include/3ds/gpu/gx.h" 1
       



Result GX_RequestDma(u32* gxbuf, u32* src, u32* dst, u32 length);
Result GX_SetCommandList_Last(u32* gxbuf, u32* buf0a, u32 buf0s, u8 flags);
Result GX_SetMemoryFill(u32* gxbuf, u32* buf0a, u32 buf0v, u32* buf0e, u16 width0, u32* buf1a, u32 buf1v, u32* buf1e, u16 width1);
Result GX_SetDisplayTransfer(u32* gxbuf, u32* inadr, u32 indim, u32* outadr, u32 outdim, u32 flags);
Result GX_SetTextureCopy(u32* gxbuf, u32* inadr, u32 indim, u32* outadr, u32 outdim, u32 size, u32 flags);
Result GX_SetCommandList_First(u32* gxbuf, u32* buf0a, u32 buf0s, u32* buf1a, u32 buf1s, u32* buf2a, u32 buf2s);
# 34 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/gpu/gpu.h" 1
       

void GPU_Init(Handle *gsphandle);
void GPU_Reset(u32* gxbuf, u32* gpuBuf, u32 gpuBufSize);

void GPUCMD_SetBuffer(u32* adr, u32 size, u32 offset);
void GPUCMD_SetBufferOffset(u32 offset);
void GPUCMD_GetBuffer(u32** adr, u32* size, u32* offset);
void GPUCMD_AddRawCommands(u32* cmd, u32 size);
void GPUCMD_Run(u32* gxbuf);
void GPUCMD_FlushAndRun(u32* gxbuf);
void GPUCMD_Add(u32 cmd, u32* param, u32 paramlength);
void GPUCMD_AddSingleParam(u32 cmd, u32 param);
void GPUCMD_Finalize();







typedef enum
{
 GPU_NEAREST = 0x0,
 GPU_LINEAR = 0x1,
}GPU_TEXTURE_FILTER_PARAM;

typedef enum
{
 GPU_CLAMP_TO_EDGE = 0x0,
 GPU_REPEAT = 0x2,
}GPU_TEXTURE_WRAP_PARAM;

typedef enum
{
 GPU_TEXUNIT0 = 0x1,
 GPU_TEXUNIT1 = 0x2,
 GPU_TEXUNIT2 = 0x4
} GPU_TEXUNIT;

typedef enum{
 GPU_RGBA8=0x0,
 GPU_RGB8=0x1,
 GPU_RGBA5551=0x2,
 GPU_RGB565=0x3,
 GPU_RGBA4=0x4,
 GPU_LA8=0x5,
 GPU_HILO8=0x6,
 GPU_L8=0x7,
 GPU_A8=0x8,
 GPU_LA4=0x9,
 GPU_L4=0xA,
 GPU_ETC1=0xB,
 GPU_ETC1A4=0xC
}GPU_TEXCOLOR;

typedef enum
{
 GPU_NEVER = 0,
 GPU_ALWAYS = 1,
 GPU_EQUAL = 2,
 GPU_NOTEQUAL = 3,
 GPU_LESS = 4,
 GPU_LEQUAL = 5,
 GPU_GREATER = 6,
 GPU_GEQUAL = 7
}GPU_TESTFUNC;

typedef enum
{
 GPU_SCISSOR_DISABLE = 0,
 GPU_SCISSOR_INVERT = 1,

 GPU_SCISSOR_NORMAL = 3,

} GPU_SCISSORMODE;

typedef enum
{
 GPU_KEEP = 0,
 GPU_AND_NOT = 1,
 GPU_XOR = 5,

} GPU_STENCILOP;

typedef enum
{
 GPU_WRITE_RED = 0x01,
 GPU_WRITE_GREEN = 0x02,
 GPU_WRITE_BLUE = 0x04,
 GPU_WRITE_ALPHA = 0x08,
 GPU_WRITE_DEPTH = 0x10,

 GPU_WRITE_COLOR = 0x0F,
 GPU_WRITE_ALL = 0x1F
} GPU_WRITEMASK;

typedef enum
{
 GPU_BLEND_ADD = 0,
 GPU_BLEND_SUBTRACT = 1,
 GPU_BLEND_REVERSE_SUBTRACT = 2,
 GPU_BLEND_MIN = 3,
 GPU_BLEND_MAX = 4
} GPU_BLENDEQUATION;

typedef enum
{
 GPU_ZERO = 0,
 GPU_ONE = 1,
 GPU_SRC_COLOR = 2,
 GPU_ONE_MINUS_SRC_COLOR = 3,
 GPU_DST_COLOR = 4,
 GPU_ONE_MINUS_DST_COLOR = 5,
 GPU_SRC_ALPHA = 6,
 GPU_ONE_MINUS_SRC_ALPHA = 7,
 GPU_DST_ALPHA = 8,
 GPU_ONE_MINUS_DST_ALPHA = 9,
 GPU_CONSTANT_COLOR = 10,
 GPU_ONE_MINUS_CONSTANT_COLOR = 11,
 GPU_CONSTANT_ALPHA = 12,
 GPU_ONE_MINUS_CONSTANT_ALPHA = 13,
 GPU_SRC_ALPHA_SATURATE = 14
} GPU_BLENDFACTOR;

typedef enum
{
 GPU_LOGICOP_CLEAR = 0,
 GPU_LOGICOP_AND = 1,
 GPU_LOGICOP_AND_REVERSE = 2,
 GPU_LOGICOP_COPY = 3,
 GPU_LOGICOP_SET = 4,
 GPU_LOGICOP_COPY_INVERTED = 5,
 GPU_LOGICOP_NOOP = 6,
 GPU_LOGICOP_INVERT = 7,
 GPU_LOGICOP_NAND = 8,
 GPU_LOGICOP_OR = 9,
 GPU_LOGICOP_NOR = 10,
 GPU_LOGICOP_XOR = 11,
 GPU_LOGICOP_EQUIV = 12,
 GPU_LOGICOP_AND_INVERTED = 13,
 GPU_LOGICOP_OR_REVERSE = 14,
 GPU_LOGICOP_OR_INVERTED = 15
} GPU_LOGICOP;

typedef enum{
 GPU_BYTE = 0,
 GPU_UNSIGNED_BYTE = 1,
 GPU_SHORT = 2,
 GPU_FLOAT = 3
}GPU_FORMATS;


typedef enum{
 GPU_CULL_NONE = 0,
 GPU_CULL_FRONT_CCW = 1,
 GPU_CULL_BACK_CCW = 2
}GPU_CULLMODE;



typedef enum{
 GPU_PRIMARY_COLOR = 0x00,
 GPU_TEXTURE0 = 0x03,
 GPU_TEXTURE1 = 0x04,
 GPU_TEXTURE2 = 0x05,
 GPU_TEXTURE3 = 0x06,
 GPU_CONSTANT = 0x0E,
 GPU_PREVIOUS = 0x0F,
}GPU_TEVSRC;

typedef enum{
 GPU_REPLACE = 0x00,
 GPU_MODULATE = 0x01,
 GPU_ADD = 0x02,
 GPU_ADD_SIGNED = 0x03,
 GPU_INTERPOLATE = 0x04,
 GPU_SUBTRACT = 0x05,
 GPU_DOT3_RGB = 0x06
}GPU_COMBINEFUNC;




typedef enum{
 GPU_TRIANGLES = 0x0000,
 GPU_TRIANGLE_STRIP = 0x0100,
 GPU_TRIANGLE_FAN = 0x0200,
 GPU_UNKPRIM = 0x0300
}GPU_Primitive_t;

void GPU_SetUniform(u32 startreg, u32* data, u32 numreg);

void GPU_SetViewport(u32* depthBuffer, u32* colorBuffer, u32 x, u32 y, u32 w, u32 h);

void GPU_SetScissorTest(GPU_SCISSORMODE mode, u32 x, u32 y, u32 w, u32 h);

void GPU_DepthRange(float nearVal, float farVal);
void GPU_SetAlphaTest(_Bool enable, GPU_TESTFUNC function, u8 ref);
void GPU_SetDepthTestAndWriteMask(_Bool enable, GPU_TESTFUNC function, GPU_WRITEMASK writemask);
void GPU_SetStencilTest(_Bool enable, GPU_TESTFUNC function, u8 ref, u8 mask, u8 replace);
void GPU_SetStencilOp(GPU_STENCILOP sfail, GPU_STENCILOP dfail, GPU_STENCILOP pass);
void GPU_SetFaceCulling(GPU_CULLMODE mode);


void GPU_SetAlphaBlending(GPU_BLENDEQUATION colorEquation, GPU_BLENDEQUATION alphaEquation,
 GPU_BLENDFACTOR colorSrc, GPU_BLENDFACTOR colorDst,
 GPU_BLENDFACTOR alphaSrc, GPU_BLENDFACTOR alphaDst);
void GPU_SetColorLogicOp(GPU_LOGICOP op);

void GPU_SetBlendingColor(u8 r, u8 g, u8 b, u8 a);

void GPU_SetAttributeBuffers(u8 totalAttributes, u32* baseAddress, u64 attributeFormats, u16 attributeMask, u64 attributePermutation, u8 numBuffers, u32 bufferOffsets[], u64 bufferPermutations[], u8 bufferNumAttributes[]);

void GPU_SetTextureEnable(GPU_TEXUNIT units);
void GPU_SetTexture(GPU_TEXUNIT unit, u32* data, u16 width, u16 height, u32 param, GPU_TEXCOLOR colorType);
void GPU_SetTexEnv(u8 id, u16 rgbSources, u16 alphaSources, u16 rgbOperands, u16 alphaOperands, GPU_COMBINEFUNC rgbCombine, GPU_COMBINEFUNC alphaCombine, u32 constantColor);

void GPU_DrawArray(GPU_Primitive_t primitive, u32 n);
void GPU_DrawElements(GPU_Primitive_t primitive, u32* indexArray, u32 n);

void GPU_FinishDrawing();
# 35 "c:/devkitPro/libctru/include/3ds.h" 2
# 1 "c:/devkitPro/libctru/include/3ds/gpu/shdr.h" 1
       

typedef enum{
 VERTEX_SHDR=0x0,
 GEOMETRY_SHDR=0x1
}SHDR_type;

typedef enum{
 RESULT_POSITION = 0x0,
 RESULT_COLOR = 0x2,
 RESULT_TEXCOORD0 = 0x3,
 RESULT_TEXCOORD1 = 0x5,
 RESULT_TEXCOORD2 = 0x6
}SHDR_outType;

typedef struct{
 u32 codeSize;
 u32* codeData;
 u32 opdescSize;
 u32* opcdescData;
}DVLP_s;

typedef struct{
 u32 header;
 u32 data[4];
}DVLE_constEntry_s;

typedef struct{
 u16 type;
 u16 regID;
 u32 header;
}DVLE_outEntry_s;

typedef struct{
 u32 symbolOffset;
 u16 startReg;
 u16 endReg;
}DVLE_uniformEntry_s;

typedef struct{
 SHDR_type type;
 u32 mainOffset, endmainOffset;
 u32 constTableSize;
 DVLE_constEntry_s* constTableData;
 u32 outTableSize;
 DVLE_outEntry_s* outTableData;
 u32 uniformTableSize;
 DVLE_uniformEntry_s* uniformTableData;
 char* symbolTableData;
}DVLE_s;

typedef struct{
 u32 numDVLE;
 DVLP_s DVLP;
 DVLE_s* DVLE;
}DVLB_s;


DVLB_s* SHDR_ParseSHBIN(u32* shbinData, u32 shbinSize);
void SHDR_UseProgram(DVLB_s* dvlb, u8 id);
void SHDR_FreeDVLB(DVLB_s* dvlb);
s8 SHDR_GetUniformRegister(DVLB_s* dvlb, const char* name, u8 programID);

void DVLP_SendCode(DVLP_s* dvlp);
void DVLP_SendOpDesc(DVLP_s* dvlp);

void DVLE_SendOutmap(DVLE_s* dvle);
void DVLE_SendConstants(DVLE_s* dvle);
# 36 "c:/devkitPro/libctru/include/3ds.h" 2

# 1 "c:/devkitPro/libctru/include/3ds/sdmc.h" 1
       



Result sdmcInit(void);
Result sdmcExit(void);
# 38 "c:/devkitPro/libctru/include/3ds.h" 2
# 64 "c:/devl/prboom3ds/src/m_menu.c" 2

extern patchnum_t hu_font[((0x7f) - '!' + 1)];
extern boolean message_dontfuckwithme;

extern boolean chat_on;





int mouseSensitivity_horiz;
int mouseSensitivity_vert;

int showMessages;

int hide_setup=1;



int screenblocks;

int screenSize;

int quickSaveSlot;

int messageToPrint;


static const char* messageString;


int messx;
int messy;
int messageLastMenuActive;

boolean messageNeedsInput;

void (*messageRoutine)(int response);




static int allow_changes(void)
{
 return !(demoplayback || demorecording || netgame);
}

static void M_UpdateCurrent(default_t* def)
{

  if (def->current) {
    if (allow_changes())
  *def->current = *def->location.pi;
    else if (*def->current != *def->location.pi)
  (warning_about_changes=(0x10000), print_warning_about_changes = 2);
  }
}

int warning_about_changes, print_warning_about_changes;



boolean menu_background = 1;

static void M_DrawBackground(const char *flat, int scrn)
{
  if (menu_background)
    V_DrawBackground(flat, scrn);
}



int saveStringEnter;
int saveSlot;
int saveCharIndex;

char saveOldString[24];

boolean inhelpscreens;

enum menuactive_e menuactive;




char savegamestrings[10][24];





typedef struct
{
  short status;
  char name[10];




  void (*routine)(int choice);
  char alphaKey;
  const char *alttext;
} menuitem_t;

typedef struct menu_s
{
  short numitems;
  struct menu_s* prevMenu;
  menuitem_t* menuitems;
  void (*routine)();
  short x;
  short y;
  short lastOn;
} menu_t;

short itemOn;
short skullAnimCounter;
short whichSkull;



const char skullName[2][ 9] = {"M_SKULL1","M_SKULL2"};

menu_t* currentMenu;




int mapcolor_me;

extern int map_point_coordinates;

extern char* chat_macros[];
extern const char* shiftxform;
extern default_t defaults[];
extern int numdefaults;






void M_NewGame(int choice);
void M_Episode(int choice);
void M_ChooseSkill(int choice);
void M_LoadGame(int choice);
void M_SaveGame(int choice);
void M_Options(int choice);
void M_EndGame(int choice);
void M_ReadThis(int choice);
void M_ReadThis2(int choice);
void M_QuitDOOM(int choice);

void M_ChangeMessages(int choice);
void M_ChangeSensitivity(int choice);
void M_SfxVol(int choice);
void M_MusicVol(int choice);

void M_SizeDisplay(int choice);
void M_StartGame(int choice);
void M_Sound(int choice);

void M_Mouse(int choice, int *sens);
void M_MouseVert(int choice);
void M_MouseHoriz(int choice);
void M_DrawMouse(void);

void M_FinishReadThis(int choice);
void M_FinishHelp(int choice);
void M_LoadSelect(int choice);
void M_SaveSelect(int choice);
void M_ReadSaveStrings(void);
void M_QuickSave(void);
void M_QuickLoad(void);

void M_DrawMainMenu(void);
void M_DrawReadThis1(void);
void M_DrawReadThis2(void);
void M_DrawNewGame(void);
void M_DrawEpisode(void);
void M_DrawOptions(void);
void M_DrawSound(void);
void M_DrawLoad(void);
void M_DrawSave(void);
void M_DrawSetup(void);
void M_DrawHelp (void);

void M_DrawSaveLoadBorder(int x,int y);
void M_SetupNextMenu(menu_t *menudef);
void M_DrawThermo(int x,int y,int thermWidth,int thermDot);
void M_DrawEmptyCell(menu_t *menu,int item);
void M_DrawSelCell(menu_t *menu,int item);
void M_WriteText(int x, int y, const char *string, int cm);
int M_StringWidth(const char *string);
int M_StringHeight(const char *string);
void M_DrawTitle(int x, int y, const char *patch, int cm,
                 const char *alttext, int altcm);
void M_StartMessage(const char *string,void *routine,boolean input);
void M_StopMessage(void);
void M_ClearMenus (void);




int M_GetKeyString(int,int);
void M_Setup(int choice);
void M_KeyBindings(int choice);
void M_Weapons(int);
void M_StatusBar(int);
void M_Automap(int);
void M_Enemy(int);
void M_Messages(int);
void M_ChatStrings(int);
void M_InitExtendedHelp(void);
void M_ExtHelpNextScreen(int);
void M_ExtHelp(int);
static int M_GetPixelWidth(const char*);
void M_DrawKeybnd(void);
void M_DrawWeapons(void);
static void M_DrawMenuString(int,int,int);
static void M_DrawStringCentered(int,int,int,const char*);
void M_DrawStatusHUD(void);
void M_DrawExtHelp(void);
void M_DrawAutoMap(void);
void M_DrawEnemy(void);
void M_DrawMessages(void);
void M_DrawChatStrings(void);
void M_Compat(int);
void M_ChangeDemoSmoothTurns(void);
void M_General(int);
void M_DrawCompat(void);
void M_DrawGeneral(void);
void M_FullScreen(void);

menu_t NewDef;
# 314 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  newgame = 0,
  loadgame,
  savegame,
  options,
  readthis,
  quitdoom,
  main_end
} main_e;
# 333 "c:/devl/prboom3ds/src/m_menu.c"
menuitem_t MainMenu[]=
{
  {1,"M_NGAME", M_NewGame, 'n'},
  {1,"M_OPTION",M_Options, 'o'},
  {1,"M_LOADG", M_LoadGame,'l'},
  {1,"M_SAVEG", M_SaveGame,'s'},

  {1,"M_RDTHIS",M_ReadThis,'r'},
  {1,"M_QUITG", M_QuitDOOM,'q'}
};

menu_t MainDef =
{
  main_end,
  ((void *)0),
  MainMenu,
  M_DrawMainMenu,
  97,64,
  0
};





void M_DrawMainMenu(void)
{

  V_DrawNumPatch(94,2,0,W_GetNumForName("M_DOOM"),CR_RED,VPT_STRETCH);
}
# 372 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  rdthsempty1,
  read1_end
} read_e;

enum
{
  rdthsempty2,
  read2_end
} read_e2;

enum
{
  helpempty,
  help_end
} help_e;




menuitem_t ReadMenu1[] =
{
  {1,"",M_ReadThis2,0}
};

menuitem_t ReadMenu2[]=
{
  {1,"",M_FinishReadThis,0}
};

menuitem_t HelpMenu[]=
{
  {1,"",M_FinishHelp,0}
};

menu_t ReadDef1 =
{
  read1_end,
  &MainDef,
  ReadMenu1,
  M_DrawReadThis1,
  330,175,

  0
};

menu_t ReadDef2 =
{
  read2_end,
  &ReadDef1,
  ReadMenu2,
  M_DrawReadThis2,
  330,175,
  0
};

menu_t HelpDef =
{
  help_end,
  &HelpDef,
  HelpMenu,
  M_DrawHelp,
  330,175,
  0
};





void M_ReadThis(int choice)
{
  M_SetupNextMenu(&ReadDef1);
}

void M_ReadThis2(int choice)
{
  M_SetupNextMenu(&ReadDef2);
}

void M_FinishReadThis(int choice)
{
  M_SetupNextMenu(&MainDef);
}

void M_FinishHelp(int choice)
{
  M_SetupNextMenu(&MainDef);
}







void M_DrawReadThis1(void)
{
  inhelpscreens = 1;
  if (gamemode == shareware)
    V_DrawNumPatch(0,0,0,W_GetNumForName("HELP2"),CR_RED,VPT_STRETCH);
  else
    M_DrawCredits();
}






void M_DrawReadThis2(void)
{
  inhelpscreens = 1;
  if (gamemode == shareware)
    M_DrawCredits();
  else
    V_DrawNumPatch(0,0,0,W_GetNumForName("CREDIT"),CR_RED,VPT_STRETCH);
}
# 503 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  ep1,
  ep2,
  ep3,
  ep4,
  ep_end
} episodes_e;



menuitem_t EpisodeMenu[]=
{
  {1,"M_EPI1", M_Episode,'k'},
  {1,"M_EPI2", M_Episode,'t'},
  {1,"M_EPI3", M_Episode,'i'},
  {1,"M_EPI4", M_Episode,'t'}
};

menu_t EpiDef =
{
  ep_end,
  &MainDef,
  EpisodeMenu,
  M_DrawEpisode,
  48,63,
  ep1
};




int epi;

void M_DrawEpisode(void)
{

  V_DrawNumPatch(54,38,0,W_GetNumForName("M_EPISOD"),CR_RED,VPT_STRETCH);
}

void M_Episode(int choice)
{
  if ( (gamemode == shareware) && choice) {
    M_StartMessage(s_SWSTRING,((void *)0),0);
    M_SetupNextMenu(&ReadDef1);
    return;
  }


  if ( (gamemode == registered) && (choice > 2))
    {
    lprintf( LO_WARN,
     "M_Episode: 4th episode requires UltimateDOOM\n");
    choice = 0;
    }

  epi = choice;
  M_SetupNextMenu(&NewDef);
}
# 570 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  killthings,
  toorough,
  hurtme,
  violence,
  nightmare,
  newg_end
} newgame_e;



menuitem_t NewGameMenu[]=
{
  {1,"M_JKILL", M_ChooseSkill, 'i'},
  {1,"M_ROUGH", M_ChooseSkill, 'h'},
  {1,"M_HURT", M_ChooseSkill, 'h'},
  {1,"M_ULTRA", M_ChooseSkill, 'u'},
  {1,"M_NMARE", M_ChooseSkill, 'n'}
};

menu_t NewDef =
{
  newg_end,
  &EpiDef,
  NewGameMenu,
  M_DrawNewGame,
  48,63,
  hurtme
};





void M_DrawNewGame(void)
{

  V_DrawNumPatch(96,14,0,W_GetNumForName("M_NEWG"),CR_RED,VPT_STRETCH);
  V_DrawNumPatch(54,38,0,W_GetNumForName("M_SKILL"),CR_RED,VPT_STRETCH);
}


static void M_RestartLevelResponse(int ch)
{
  if (ch != 'y')
    return;

  if (demorecording)
    exit(0);

  currentMenu->lastOn = itemOn;
  M_ClearMenus ();
  G_RestartLevel ();
}

void M_NewGame(int choice)
{
  if (netgame && !demoplayback) {
    if (compatibility_level < lxdoom_1_compatibility)
      M_StartMessage(s_NEWGAME,((void *)0),0);
    else
      M_StartMessage(s_RESTARTLEVEL,M_RestartLevelResponse,1);
    return;
  }

  if (demorecording) {
    M_StartMessage("you can't start a new game\n"
       "while recording a demo!\n\n""press a key.",
       ((void *)0), 0);
    return;
  }

  if ( gamemode == commercial )
    M_SetupNextMenu(&NewDef);
  else
    M_SetupNextMenu(&EpiDef);
}


static void M_VerifyNightmare(int ch)
{
  if (ch != 'y')
    return;

  G_DeferedInitNew(nightmare,epi+1,1);
  M_ClearMenus ();
}

void M_ChooseSkill(int choice)
{
  if (choice == nightmare)
    {
      M_StartMessage(s_NIGHTMARE,M_VerifyNightmare,1);
      return;
    }

  G_DeferedInitNew(choice,epi+1,1);
  M_ClearMenus ();
}
# 678 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  load1,
  load2,
  load3,
  load4,
  load5,
  load6,
  load7,
  load8,
  load_end
} load_e;



menuitem_t LoadMenue[]=
{
  {1,"", M_LoadSelect,'1'},
  {1,"", M_LoadSelect,'2'},
  {1,"", M_LoadSelect,'3'},
  {1,"", M_LoadSelect,'4'},
  {1,"", M_LoadSelect,'5'},
  {1,"", M_LoadSelect,'6'},
  {1,"", M_LoadSelect,'7'},
  {1,"", M_LoadSelect,'8'},
};

menu_t LoadDef =
{
  load_end,
  &MainDef,
  LoadMenue,
  M_DrawLoad,
  80,34,
  0
};







void M_DrawLoad(void)
{
  int i;



  V_DrawNumPatch(72,8,0,W_GetNumForName("M_LOADG"),CR_RED,VPT_STRETCH);
  for (i = 0 ; i < load_end ; i++) {
    M_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+16*i);
    M_WriteText(LoadDef.x,LoadDef.y+16*i,savegamestrings[i], CR_RED);
  }
}





void M_DrawSaveLoadBorder(int x,int y)
{
  int i;

  V_DrawNumPatch(x-8,y+7,0,W_GetNumForName("M_LSLEFT"),CR_RED,VPT_STRETCH);

  for (i = 0 ; i < 24 ; i++)
    {
      V_DrawNumPatch(x,y+7,0,W_GetNumForName("M_LSCNTR"),CR_RED,VPT_STRETCH);
      x += 8;
    }

  V_DrawNumPatch(x,y+7,0,W_GetNumForName("M_LSRGHT"),CR_RED,VPT_STRETCH);
}





void M_LoadSelect(int choice)
{



  G_LoadGame(choice, 0);

  M_ClearMenus ();
}





static char *forced_loadgame_message;

static void M_VerifyForcedLoadGame(int ch)
{
  if (ch=='y')
    G_ForcedLoadGame();
  Z_Free(forced_loadgame_message);
  M_ClearMenus();
}

void M_ForcedLoadGame(const char *msg)
{
  forced_loadgame_message = Z_Strdup(msg,PU_STATIC,0);
  M_StartMessage(forced_loadgame_message, M_VerifyForcedLoadGame, 1);
}





void M_LoadGame (int choice)
{


  if (demorecording && (compatibility_level < prboom_2_compatibility))
    {
    M_StartMessage("you can't load a game\n"
       "while recording an old demo!\n\n""press a key.",
       ((void *)0), 0);
    return;
    }

  M_SetupNextMenu(&LoadDef);
  M_ReadSaveStrings();
}
# 814 "c:/devl/prboom3ds/src/m_menu.c"
menuitem_t SaveMenu[]=
{
  {1,"", M_SaveSelect,'1'},
  {1,"", M_SaveSelect,'2'},
  {1,"", M_SaveSelect,'3'},
  {1,"", M_SaveSelect,'4'},
  {1,"", M_SaveSelect,'5'},
  {1,"", M_SaveSelect,'6'},
  {1,"", M_SaveSelect,'7'},
  {1,"", M_SaveSelect,'8'},
};

menu_t SaveDef =
{
  load_end,
  &MainDef,
  SaveMenu,
  M_DrawSave,
  80,34,
  0
};





void M_ReadSaveStrings(void)
{
  int i;

  for (i = 0 ; i < load_end ; i++) {
    char *name;
    int len;
    FILE *fp;



    len = G_SaveGameName(((void *)0), 0, i, 0);
    name = Z_Malloc(len+1,PU_STATIC,0);
    G_SaveGameName(name, len+1, i, 0);
    fp = fopen(name,"rb");
    Z_Free(name);
    if (!fp) {
      strcpy(&savegamestrings[i][0],s_EMPTYSTRING);
      LoadMenue[i].status = 0;
      continue;
    }
    fread(&savegamestrings[i], 24, 1, fp);
    fclose(fp);
    LoadMenue[i].status = 1;
  }
}




void M_DrawSave(void)
{
  int i;



  V_DrawNumPatch(72,8,0,W_GetNumForName("M_SAVEG"),CR_RED,VPT_STRETCH);
  for (i = 0 ; i < load_end ; i++)
    {
    M_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+16*i);
    M_WriteText(LoadDef.x,LoadDef.y+16*i,savegamestrings[i], CR_RED);
    }

  if (saveStringEnter)
    {
    i = M_StringWidth(savegamestrings[saveSlot]);
    M_WriteText(LoadDef.x + i,LoadDef.y+16*saveSlot,"_", CR_RED);
    }
}




static void M_DoSave(int slot)
{
  M_StartMessage(s_SAVING, ((void *)0), 0);
  lprintf(LO_INFO, "%s\n", s_SAVING);
  G_SaveGame (slot,savegamestrings[slot]);
  M_ClearMenus ();


  if (quickSaveSlot == -2)
    quickSaveSlot = slot;
}




void M_SaveSelect(int choice)
{

  saveStringEnter = 1;





  saveSlot = choice;
  strcpy(saveOldString,savegamestrings[choice]);
  if (!strcmp(savegamestrings[choice],s_EMPTYSTRING))
    savegamestrings[choice][0] = 0;
  saveCharIndex = strlen(savegamestrings[choice]);
}




void M_SaveGame (int choice)
{

  if (!usergame && (!demoplayback || netgame))
    {
    M_StartMessage(s_SAVEDEAD,((void *)0),0);
    return;
    }

  if (gamestate != GS_LEVEL)
    return;

  M_SetupNextMenu(&SaveDef);
  M_ReadSaveStrings();
}
# 950 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  general,

  setup,
  endgame,
  messages,

  scrnsize,
  option_empty1,
  mousesens,

  soundvol,
  opt_end
} options_e;



menuitem_t OptionsMenu[]=
{

  {1,"M_GENERL", M_General, 'g', "GENERAL"},
  {1,"M_SETUP", M_Setup, 's', "SETUP"},
  {1,"M_ENDGAM", M_EndGame,'e', "END GAME"},
  {1,"M_MESSG", M_ChangeMessages,'m', "MESSAGES"},

  {2,"M_SCRNSZ", M_SizeDisplay,'s', "SCREEN SIZE"},
  {-1,"",0},
  {1,"M_MSENS", M_ChangeSensitivity,'m', "MOUSE SENSITIVITY"},

  {1,"M_SVOL", M_Sound,'s', "SOUND VOLUME"},
};

menu_t OptionsDef =
{
  opt_end,
  &MainDef,
  OptionsMenu,
  M_DrawOptions,
  60,37,
  0
};




char detailNames[2][9] = {"M_GDHIGH","M_GDLOW"};
char msgNames[2][9] = {"M_MSGOFF","M_MSGON"};


void M_DrawOptions(void)
{


  V_DrawNumPatch(108,15,0,W_GetNumForName("M_OPTTTL"),CR_RED,VPT_STRETCH);

  V_DrawNumPatch(OptionsDef.x + 120,OptionsDef.y+16*messages,0,W_GetNumForName(msgNames[showMessages]),CR_RED,VPT_STRETCH)
                                                      ;

  M_DrawThermo(OptionsDef.x,OptionsDef.y+16*(scrnsize+1),
   9,screenSize);
}

void M_Options(int choice)
{
  M_SetupNextMenu(&OptionsDef);
}





int quitsounds[8] =
{
  sfx_pldeth,
  sfx_dmpain,
  sfx_popain,
  sfx_slop,
  sfx_telept,
  sfx_posit1,
  sfx_posit3,
  sfx_sgtatk
};

int quitsounds2[8] =
{
  sfx_vilact,
  sfx_getpow,
  sfx_boscub,
  sfx_slop,
  sfx_skeswg,
  sfx_kntdth,
  sfx_bspact,
  sfx_sgtatk
};

static void M_QuitResponse(int ch)
{
  if (ch != 'y')
    return;
  if ((!netgame || demoplayback)
      && !nosfxparm && snd_card)
  {
    int i;

    if (gamemode == commercial)
      S_StartSound(((void *)0),quitsounds2[(gametic>>2)&7]);
    else
      S_StartSound(((void *)0),quitsounds[(gametic>>2)&7]);
# 1068 "c:/devl/prboom3ds/src/m_menu.c"
  }
  exit(0);
}

void M_QuitDOOM(int choice)
{
  static char endstring[160];




  if (language != english)
    sprintf(endstring,"%s\n\n%s",s_DOSY, endmsg[0] );
  else
    sprintf(endstring,"%s\n\n%s", endmsg[gametic%(NUM_QUITMESSAGES-1)+1], s_DOSY);

  M_StartMessage(endstring,M_QuitResponse,1);
}
# 1095 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  sfx_vol,
  sfx_empty1,
  music_vol,
  sfx_empty2,
  sound_end
} sound_e;



menuitem_t SoundMenu[]=
{
  {2,"M_SFXVOL",M_SfxVol,'s'},
  {-1,"",0},
  {2,"M_MUSVOL",M_MusicVol,'m'},
  {-1,"",0}
};

menu_t SoundDef =
{
  sound_end,
  &OptionsDef,
  SoundMenu,
  M_DrawSound,
  80,64,
  0
};





void M_DrawSound(void)
{

  V_DrawNumPatch(60,38,0,W_GetNumForName("M_SVOL"),CR_RED,VPT_STRETCH);

  M_DrawThermo(SoundDef.x,SoundDef.y+16*(sfx_vol+1),16,snd_SfxVolume);

  M_DrawThermo(SoundDef.x,SoundDef.y+16*(music_vol+1),16,snd_MusicVolume);
}

void M_Sound(int choice)
{
  M_SetupNextMenu(&SoundDef);
}

void M_SfxVol(int choice)
{
  switch(choice)
    {
    case 0:
      if (snd_SfxVolume)
        snd_SfxVolume--;
      break;
    case 1:
      if (snd_SfxVolume < 15)
        snd_SfxVolume++;
      break;
    }

  S_SetSfxVolume(snd_SfxVolume );
}

void M_MusicVol(int choice)
{
  switch(choice)
    {
    case 0:
      if (snd_MusicVolume)
        snd_MusicVolume--;
      break;
    case 1:
      if (snd_MusicVolume < 15)
        snd_MusicVolume++;
      break;
    }

  S_SetMusicVolume(snd_MusicVolume );
}
# 1185 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  mouse_horiz,
  mouse_empty1,
  mouse_vert,
  mouse_empty2,
  mouse_end
} mouse_e;



menuitem_t MouseMenu[]=
{
  {2,"M_HORSEN",M_MouseHoriz,'h', "HORIZONTAL"},
  {-1,"",0},
  {2,"M_VERSEN",M_MouseVert,'v', "VERTICAL"},
  {-1,"",0}
};

menu_t MouseDef =
{
  mouse_end,
  &OptionsDef,
  MouseMenu,
  M_DrawMouse,
  60,64,
  0
};
# 1223 "c:/devl/prboom3ds/src/m_menu.c"
void M_DrawMouse(void)
{
  int mhmx,mvmx;


  V_DrawNumPatch(60,38,0,W_GetNumForName("M_MSENS"),CR_RED,VPT_STRETCH);


  mhmx = mouseSensitivity_horiz>99? 99 : mouseSensitivity_horiz;
  M_DrawThermo(MouseDef.x,MouseDef.y+16*(mouse_horiz+1),100,mhmx);

  mvmx = mouseSensitivity_vert>99? 99 : mouseSensitivity_vert;
  M_DrawThermo(MouseDef.x,MouseDef.y+16*(mouse_vert+1),100,mvmx);
}

void M_ChangeSensitivity(int choice)
{
  M_SetupNextMenu(&MouseDef);
# 1253 "c:/devl/prboom3ds/src/m_menu.c"
}

void M_MouseHoriz(int choice)
{
  M_Mouse(choice, &mouseSensitivity_horiz);
}

void M_MouseVert(int choice)
{
  M_Mouse(choice, &mouseSensitivity_vert);
}

void M_Mouse(int choice, int *sens)
{
  switch(choice)
    {
    case 0:
      if (*sens)
        --*sens;
      break;
    case 1:
      if (*sens < 99)
        ++*sens;
      break;
    }
}






char tempstring[80];

static void M_QuickSaveResponse(int ch)
{
  if (ch == 'y') {
    M_DoSave(quickSaveSlot);
    S_StartSound(((void *)0),sfx_swtchx);
  }
}

void M_QuickSave(void)
{
  if (!usergame && (!demoplayback || netgame)) {
    S_StartSound(((void *)0),sfx_oof);
    return;
  }

  if (gamestate != GS_LEVEL)
    return;

  if (quickSaveSlot < 0) {
    M_StartControlPanel();
    M_ReadSaveStrings();
    M_SetupNextMenu(&SaveDef);
    quickSaveSlot = -2;
    return;
  }
  sprintf(tempstring,s_QSPROMPT,savegamestrings[quickSaveSlot]);
  M_StartMessage(tempstring,M_QuickSaveResponse,1);
}






static void M_QuickLoadResponse(int ch)
{
  if (ch == 'y') {
    M_LoadSelect(quickSaveSlot);
    S_StartSound(((void *)0),sfx_swtchx);
  }
}

void M_QuickLoad(void)
{


  if (demorecording) {
    M_StartMessage("you can't quickload\n"
       "while recording a demo!\n\n""press a key.",
       ((void *)0), 0);
    return;
  }

  if (quickSaveSlot < 0) {
    M_StartMessage(s_QSAVESPOT,((void *)0),0);
    return;
  }
  sprintf(tempstring,s_QLPROMPT,savegamestrings[quickSaveSlot]);
  M_StartMessage(tempstring,M_QuickLoadResponse,1);
}






static void M_EndGameResponse(int ch)
{
  if (ch != 'y')
    return;


  if (demorecording || singledemo)
    G_CheckDemoStatus();

  currentMenu->lastOn = itemOn;
  M_ClearMenus ();
  D_StartTitle ();
}

void M_EndGame(int choice)
{
  if (netgame)
    {
    M_StartMessage(s_NETEND,((void *)0),0);
    return;
    }
  M_StartMessage(s_ENDGAME,M_EndGameResponse,1);
}






void M_ChangeMessages(int choice)
{

  choice = 0;
  showMessages = 1 - showMessages;

  if (!showMessages)
    players[consoleplayer].message = s_MSGOFF;
  else
    players[consoleplayer].message = s_MSGON ;

  message_dontfuckwithme = 1;
}
# 1405 "c:/devl/prboom3ds/src/m_menu.c"
void M_SizeDisplay(int choice)
{
  switch(choice) {
  case 0:
    if (screenSize > 0) {
      screenblocks--;
      screenSize--;
      hud_displayed = 0;
    }
    break;
  case 1:
    if (screenSize < 8) {
      screenblocks++;
      screenSize++;
    }
    else
      hud_displayed = !hud_displayed;
    break;
  }
  R_SetViewSize (screenblocks );
}
# 1457 "c:/devl/prboom3ds/src/m_menu.c"
boolean setup_active = 0;
boolean set_keybnd_active = 0;
boolean set_weapon_active = 0;
boolean set_status_active = 0;
boolean set_auto_active = 0;
boolean set_enemy_active = 0;
boolean set_mess_active = 0;
boolean set_chat_active = 0;
boolean setup_select = 0;
boolean setup_gather = 0;
boolean colorbox_active = 0;
boolean default_verify = 0;
boolean set_general_active = 0;
boolean set_compat_active = 0;
# 1479 "c:/devl/prboom3ds/src/m_menu.c"
static int set_menu_itemon;
setup_menu_t* current_setup_menu;





static char menu_buffer[64];






enum
{
  set_compat,
  set_key_bindings,
  set_weapons,
  set_statbar,
  set_automap,
  set_enemy,
  set_messages,
  set_chatstrings,
  set_setup_end
} setup_e;

int setup_screen;
# 1516 "c:/devl/prboom3ds/src/m_menu.c"
menuitem_t SetupMenu[]=
{
  {1,"M_COMPAT",M_Compat, 'p', "DOOM COMPATIBILITY"},
  {1,"M_KEYBND",M_KeyBindings,'k', "KEY BINDINGS"},
  {1,"M_WEAP" ,M_Weapons, 'w', "WEAPONS"},
  {1,"M_STAT" ,M_StatusBar, 's', "STATUS BAR / HUD"},
  {1,"M_AUTO" ,M_Automap, 'a', "AUTOMAP"},
  {1,"M_ENEM" ,M_Enemy, 'e', "ENEMIES"},
  {1,"M_MESS" ,M_Messages, 'm', "MESSAGES"},
  {1,"M_CHAT" ,M_ChatStrings,'c', "CHAT STRINGS"},
};





static void M_DoNothing(int choice)
{
}
# 1543 "c:/devl/prboom3ds/src/m_menu.c"
enum
{
  generic_setupempty1,
  generic_setup_end
} generic_setup_e;




menuitem_t Generic_Setup[] =
{
  {1,"",M_DoNothing,0}
};







menu_t SetupDef =
{
  set_setup_end,
  &OptionsDef,
  SetupMenu,
  M_DrawSetup,
  59,37,


  0
};







menu_t KeybndDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawKeybnd,
  34,5,
  0
};

menu_t WeaponDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawWeapons,
  34,5,
  0
};

menu_t StatusHUDDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawStatusHUD,
  34,5,
  0
};

menu_t AutoMapDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawAutoMap,
  34,5,
  0
};

menu_t EnemyDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawEnemy,
  34,5,
  0
};

menu_t MessageDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawMessages,
  34,5,
  0
};

menu_t ChatStrDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawChatStrings,
  34,5,
  0
};

menu_t GeneralDef =
{
  generic_setup_end,
  &OptionsDef,
  Generic_Setup,
  M_DrawGeneral,
  34,5,
  0
};

menu_t CompatDef =
{
  generic_setup_end,
  &SetupDef,
  Generic_Setup,
  M_DrawCompat,
  34,5,
  0
};





void M_DrawSetup(void)
{

  M_DrawTitle(124, 15, "M_SETUP", CR_RED, "SETUP", CR_GOLD);
}






void M_Setup(int choice)
{
  M_SetupNextMenu(&SetupDef);
}
# 1721 "c:/devl/prboom3ds/src/m_menu.c"
int chat_index;
char* chat_string_buffer;
# 1732 "c:/devl/prboom3ds/src/m_menu.c"
char ResetButtonName[2][8] = {"M_BUTT1","M_BUTT2"};
# 1744 "c:/devl/prboom3ds/src/m_menu.c"
static void M_DrawItem(const setup_menu_t* s)
{
  int x = s->m_x;
  int y = s->m_y;
  int flags = s->m_flags;
  if (flags & 0x80)
# 1758 "c:/devl/prboom3ds/src/m_menu.c"
    V_DrawNumPatch(x,y,0,W_GetNumForName(ResetButtonName[(flags & (0x1|0x2)) ? whichSkull : 0]),CR_RED,VPT_STRETCH)
                                ;

  else {
    char *p, *t;
    int w = 0;
    int color =
  flags & 0x2 ? CR_GRAY :
  flags & 0x1 ? CR_ORANGE :
  flags & (0x4|0x200|0x100) ? CR_GOLD : CR_RED;






    for (p = t = Z_Strdup(s->m_text,PU_STATIC,0); (p = strtok(p,"\n")); y += 8, p = ((void *)0))
      {
  strcpy(menu_buffer,p);
  if (!(flags & 0x100000))
    w = M_GetPixelWidth(menu_buffer) + 4;
  M_DrawMenuString(x - w, y ,color);
      }
    Z_Free(t);
  }
}






int gather_count;
char gather_buffer[5 +1];
# 1804 "c:/devl/prboom3ds/src/m_menu.c"
static void M_DrawSetting(const setup_menu_t* s)
{
  int x = s->m_x, y = s->m_y, flags = s->m_flags, color;




  color = flags & 0x2 ? CR_GRAY : flags & 0x1 ? CR_ORANGE : CR_GREEN;



  if (flags & 0x8) {
    strcpy(menu_buffer,*s->var.def->location.pi ? "YES" : "NO");
    M_DrawMenuString(x,y,color);
    return;
  }



  if (flags & 0x1000) {

    if (flags & (0x1|0x2) && setup_gather) {
      gather_buffer[gather_count] = 0;
      strcpy(menu_buffer, gather_buffer);
    }
    else
      sprintf(menu_buffer,"%d",*s->var.def->location.pi);
    M_DrawMenuString(x,y,color);
    return;
  }



  if (flags & 0x400) {
    int *key = s->var.m_key;



    if (key) {
      M_GetKeyString(*key,0);
      if (key == &key_up || key == &key_down || key == &key_speed ||
         key == &key_fire || key == &key_strafe || key == &key_use)
  {
    if (s->m_mouse && *s->m_mouse != -1)
      sprintf(menu_buffer+strlen(menu_buffer), "/MB%d",
        *s->m_mouse+1);
    if (s->m_joy)
      sprintf(menu_buffer+strlen(menu_buffer), "/JSB%d",
        *s->m_joy+1);
  }
      M_DrawMenuString(x,y,color);
    }
    return;
  }
# 1868 "c:/devl/prboom3ds/src/m_menu.c"
  if (flags & (0x800|0x10))
    {
      sprintf(menu_buffer,"%d", *s->var.def->location.pi);
      M_DrawMenuString(x,y, flags & 0x10 ? *s->var.def->location.pi : color);
      return;
    }



  if (flags & 0x20)
    {
      int ch;

      ch = *s->var.def->location.pi;


      V_FillRect(0, x*SCREENWIDTH/320, (y-1)*SCREENHEIGHT/200,
                    8*SCREENWIDTH/320, 8*SCREENHEIGHT/200,
                 0);
      V_FillRect(0, (x+1)*SCREENWIDTH/320, y*SCREENHEIGHT/200,
                        6*SCREENWIDTH/320, 6*SCREENHEIGHT/200,
                 (byte)ch);

      if (!ch)
  V_DrawNumPatch(x+1,y,0,W_GetNumForName("M_PALNO"),CR_RED,VPT_STRETCH);
      return;
    }




  if (flags & (0x40|0x80000)) {

    union { const char **c; char **s; } u;
    char *text;

    u.c = s->var.def->location.ppsz;
    text = *(u.s);




    if (setup_select && (s->m_flags & (0x1|0x2))) {
      int cursor_start, char_width;
      char c[2];





      while (M_GetPixelWidth(text) >= 272) {
  int len = strlen(text);
  text[--len] = 0;
  if (chat_index > len)
    chat_index--;
      }





      *c = text[chat_index];
      c[1] = 0;
      char_width = M_GetPixelWidth(c);
      if (char_width == 1)
  char_width = 7;
      text[chat_index] = 0;
      cursor_start = M_GetPixelWidth(text);
      text[chat_index] = *c;



      V_FillRect(0, ((x+cursor_start-1)*SCREENWIDTH)/320, (y*SCREENHEIGHT)/200,
      (char_width*SCREENWIDTH)/320, 9*SCREENHEIGHT/200, 4);
    }



    strcpy(menu_buffer,text);
    M_DrawMenuString(x,y,color);
    return;
  }



  if (flags & 0x800000) {
    if (s->var.def->type == def_int) {
      if (s->selectstrings == ((void *)0)) {
        sprintf(menu_buffer,"%d",*s->var.def->location.pi);
      } else {
        strcpy(menu_buffer,s->selectstrings[*s->var.def->location.pi]);
      }
    }

    if (s->var.def->type == def_str) {
      sprintf(menu_buffer,"%s", *s->var.def->location.ppsz);
    }

    M_DrawMenuString(x,y,color);
    return;
  }
}







static void M_DrawScreenItems(const setup_menu_t* src)
{
  if (print_warning_about_changes > 0) {
    if (warning_about_changes & 0x40000) {
  strcpy(menu_buffer, "Value out of Range");
  M_DrawMenuString(100,176,CR_RED);
    } else if (warning_about_changes & 0x20000) {
        strcpy(menu_buffer, "Warning: Program must be restarted to see changes");
  M_DrawMenuString(3, 176, CR_RED);
    } else if (warning_about_changes & 0x400000) {
        strcpy(menu_buffer, "Video mode not supported");
  M_DrawMenuString(80,176,CR_RED);
    } else {
  strcpy(menu_buffer, "Warning: Changes are pending until next game");
        M_DrawMenuString(18,184,CR_RED);
    }
  }

  while (!(src->m_flags & 0x8000)) {



    if (src->m_flags & (0x4|0x8|0x10|0x20|0x40|0x80|0x100|0x200|0x400|0x800|0x1000|0x80000|0x200000|0x800000))
      M_DrawItem(src);



    if (src->m_flags & (0x8|0x10|0x20|0x40|0x400|0x800|0x1000|0x80000|0x800000))
      M_DrawSetting(src);
    src++;
  }
}
# 2023 "c:/devl/prboom3ds/src/m_menu.c"
static void M_DrawDefVerify(void)
{

  V_DrawNumPatch(66,88,0,W_GetNumForName("M_VBOX"),CR_RED,VPT_STRETCH);



  if (whichSkull) {
    strcpy(menu_buffer,"Reset to defaults? (Y or N)");
    M_DrawMenuString(66 +8,88 +8,CR_RED);
  }
}
# 2045 "c:/devl/prboom3ds/src/m_menu.c"
static void M_DrawInstructions(void)
{
  int flags = current_setup_menu[set_menu_itemon].m_flags;




  if (setup_select) {
    switch (flags & (0x400 | 0x8 | 0x800 | 0x1000 | 0x20 | 0x10 | 0x40 | 0x80 | 0x80000 | 0x800000)) {
      case 0x400:


        if (current_setup_menu[set_menu_itemon].m_mouse || current_setup_menu[set_menu_itemon].m_joy)
          M_DrawStringCentered(160, 20, CR_GRAY, "Press key or button for this action");
        else
          M_DrawStringCentered(160, 20, CR_GRAY, "Press key for this action");
        break;

    case 0x8:
      M_DrawStringCentered(160, 20, CR_GRAY, "Press ENTER key to toggle");
      break;
    case 0x800:
      M_DrawStringCentered(160, 20, CR_GRAY, "Enter weapon number");
      break;
    case 0x1000:
      M_DrawStringCentered(160, 20, CR_GRAY, "Enter value. Press ENTER when finished.");
      break;
    case 0x20:
      M_DrawStringCentered(160, 20, CR_GRAY, "Select color and press enter");
      break;
    case 0x10:
      M_DrawStringCentered(160, 20, CR_GRAY, "Enter value");
      break;
    case 0x40:
      M_DrawStringCentered(160, 20, CR_GRAY, "Type/edit chat string and Press ENTER");
      break;
    case 0x80000:
      M_DrawStringCentered(160, 20, CR_GRAY, "Type/edit filename and Press ENTER");
      break;
    case 0x800000:
      M_DrawStringCentered(160, 20, CR_GRAY, "Press left or right to choose");
      break;
    case 0x80:
      break;

    default:
      lprintf(LO_WARN,"Unrecognised menu item type %d", flags);

    }
  } else {
    if (flags & 0x80)
      M_DrawStringCentered(160, 20, CR_ORANGE, "Press ENTER key to reset to defaults");
    else
      M_DrawStringCentered(160, 20, CR_ORANGE, "Press Enter to Change");
  }
}
# 2121 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t keys_settings1[];
setup_menu_t keys_settings2[];
setup_menu_t keys_settings3[];
setup_menu_t keys_settings4[];



setup_menu_t* keys_settings[] =
{
  keys_settings1,
  keys_settings2,
  keys_settings3,
  keys_settings4,
  ((void *)0)
};

int mult_screens_index;
# 2174 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t keys_settings1[] =
{
  {"MOVEMENT" ,0x2000|0x4,m_null,160,31},
  {"FORWARD" ,0x400 ,m_scrn,160,31 +1*8,{&key_up},&mousebforward},
  {"BACKWARD" ,0x400 ,m_scrn,160,31 +2*8,{&key_down},&mousebbackward},
  {"TURN LEFT" ,0x400 ,m_scrn,160,31 +3*8,{&key_left}},
  {"TURN RIGHT" ,0x400 ,m_scrn,160,31 +4*8,{&key_right}},
  {"RUN" ,0x400 ,m_scrn,160,31 +5*8,{&key_speed},0,&joybspeed},
  {"STRAFE LEFT" ,0x400 ,m_scrn,160,31 +6*8,{&key_strafeleft}},
  {"STRAFE RIGHT",0x400 ,m_scrn,160,31 +7*8,{&key_straferight}},
  {"STRAFE" ,0x400 ,m_scrn,160,31 +8*8,{&key_strafe},&mousebstrafe,&joybstrafe},
  {"AUTORUN" ,0x400 ,m_scrn,160,31 +9*8,{&key_autorun}},
  {"180 TURN" ,0x400 ,m_scrn,160,31 +10*8,{&key_reverse}},
  {"USE" ,0x400 ,m_scrn,160,31 +11*8,{&key_use},&mousebuse,&joybuse},

  {"MENUS" ,0x2000|0x4,m_null,160,31 +12*8},
  {"NEXT ITEM" ,0x400 ,m_menu,160,31 +13*8,{&key_menu_down}},
  {"PREV ITEM" ,0x400 ,m_menu,160,31 +14*8,{&key_menu_up}},
  {"LEFT" ,0x400 ,m_menu,160,31 +15*8,{&key_menu_left}},
  {"RIGHT" ,0x400 ,m_menu,160,31 +16*8,{&key_menu_right}},
  {"BACKSPACE" ,0x400 ,m_menu,160,31 +17*8,{&key_menu_backspace}},
  {"SELECT ITEM" ,0x400 ,m_menu,160,31 +18*8,{&key_menu_enter}},
  {"EXIT" ,0x400 ,m_menu,160,31 +19*8,{&key_menu_escape}},


  {0,0x80,m_null,301,3},

  {"NEXT ->",0x2000|0x200,m_null,310,31 +20*8, {keys_settings2}},


  {0,0x2000|0x8000,m_null}

};

setup_menu_t keys_settings2[] =
{
  {"SCREEN" ,0x2000|0x4,m_null,160,31},
# 2222 "c:/devl/prboom3ds/src/m_menu.c"
  {"HELP" ,0x2000|0x4000 ,m_scrn,0 ,0 ,{&key_help}},
  {"MENU" ,0x2000|0x4000 ,m_scrn,0 ,0 ,{&key_escape}},

  {"SETUP" ,0x400 ,m_scrn,160,31 + 1*8,{&key_setup}},
  {"PAUSE" ,0x400 ,m_scrn,160,31 + 2*8,{&key_pause}},
  {"AUTOMAP" ,0x400 ,m_scrn,160,31 + 3*8,{&key_map}},
  {"VOLUME" ,0x400 ,m_scrn,160,31 + 4*8,{&key_soundvolume}},
  {"HUD" ,0x400 ,m_scrn,160,31 + 5*8,{&key_hud}},
  {"MESSAGES" ,0x400 ,m_scrn,160,31 + 6*8,{&key_messages}},
  {"GAMMA FIX" ,0x400 ,m_scrn,160,31 + 7*8,{&key_gamma}},
  {"SPY" ,0x400 ,m_scrn,160,31 + 8*8,{&key_spy}},
  {"LARGER VIEW" ,0x400 ,m_scrn,160,31 + 9*8,{&key_zoomin}},
  {"SMALLER VIEW",0x400 ,m_scrn,160,31 +10*8,{&key_zoomout}},
  {"SCREENSHOT" ,0x400 ,m_scrn,160,31 +11*8,{&key_screenshot}},
  {"GAME" ,0x2000|0x4,m_null,160,31 +12*8},
  {"SAVE" ,0x400 ,m_scrn,160,31 +13*8,{&key_savegame}},
  {"LOAD" ,0x400 ,m_scrn,160,31 +14*8,{&key_loadgame}},
  {"QUICKSAVE" ,0x400 ,m_scrn,160,31 +15*8,{&key_quicksave}},
  {"QUICKLOAD" ,0x400 ,m_scrn,160,31 +16*8,{&key_quickload}},
  {"END GAME" ,0x400 ,m_scrn,160,31 +17*8,{&key_endgame}},
  {"QUIT" ,0x400 ,m_scrn,160,31 +18*8,{&key_quit}},
  {"<- PREV", 0x2000|0x100,m_null,57,31 +20*8, {keys_settings1}},
  {"NEXT ->", 0x2000|0x200,m_null,310,31 +20*8, {keys_settings3}},



  {0,0x2000|0x8000,m_null}
};

setup_menu_t keys_settings3[] =
{
  {"WEAPONS" ,0x2000|0x4,m_null,160,31},
  {"FIST" ,0x400 ,m_scrn,160,31 + 1*8,{&key_weapon1}},
  {"PISTOL" ,0x400 ,m_scrn,160,31 + 2*8,{&key_weapon2}},
  {"SHOTGUN" ,0x400 ,m_scrn,160,31 + 3*8,{&key_weapon3}},
  {"CHAINGUN",0x400 ,m_scrn,160,31 + 4*8,{&key_weapon4}},
  {"ROCKET" ,0x400 ,m_scrn,160,31 + 5*8,{&key_weapon5}},
  {"PLASMA" ,0x400 ,m_scrn,160,31 + 6*8,{&key_weapon6}},
  {"BFG", 0x400 ,m_scrn,160,31 + 7*8,{&key_weapon7}},
  {"CHAINSAW",0x400 ,m_scrn,160,31 + 8*8,{&key_weapon8}},
  {"SSG" ,0x400 ,m_scrn,160,31 + 9*8,{&key_weapon9}},
  {"BEST" ,0x400 ,m_scrn,160,31 +10*8,{&key_weapontoggle}},
  {"FIRE" ,0x400 ,m_scrn,160,31 +11*8,{&key_fire},&mousebfire,&joybfire},

  {"<- PREV",0x2000|0x100,m_null,57,31 +20*8, {keys_settings2}},
  {"NEXT ->",0x2000|0x200,m_null,310,31 +20*8, {keys_settings4}},



  {0,0x2000|0x8000,m_null}

};

setup_menu_t keys_settings4[] =
{
  {"AUTOMAP" ,0x2000|0x4,m_null,160,31},
  {"FOLLOW" ,0x400 ,m_map ,160,31 + 1*8,{&key_map_follow}},
  {"ZOOM IN" ,0x400 ,m_map ,160,31 + 2*8,{&key_map_zoomin}},
  {"ZOOM OUT" ,0x400 ,m_map ,160,31 + 3*8,{&key_map_zoomout}},
  {"SHIFT UP" ,0x400 ,m_map ,160,31 + 4*8,{&key_map_up}},
  {"SHIFT DOWN" ,0x400 ,m_map ,160,31 + 5*8,{&key_map_down}},
  {"SHIFT LEFT" ,0x400 ,m_map ,160,31 + 6*8,{&key_map_left}},
  {"SHIFT RIGHT",0x400 ,m_map ,160,31 + 7*8,{&key_map_right}},
  {"MARK PLACE" ,0x400 ,m_map ,160,31 + 8*8,{&key_map_mark}},
  {"CLEAR MARKS",0x400 ,m_map ,160,31 + 9*8,{&key_map_clear}},
  {"FULL/ZOOM" ,0x400 ,m_map ,160,31 +10*8,{&key_map_gobig}},
  {"GRID" ,0x400 ,m_map ,160,31 +11*8,{&key_map_grid}},

  {"CHATTING" ,0x2000|0x4,m_null,160,31 +12*8},
  {"BEGIN CHAT" ,0x400 ,m_scrn,160,31 +13*8,{&key_chat}},
  {"PLAYER 1" ,0x400 ,m_scrn,160,31 +14*8,{&destination_keys[0]}},
  {"PLAYER 2" ,0x400 ,m_scrn,160,31 +15*8,{&destination_keys[1]}},
  {"PLAYER 3" ,0x400 ,m_scrn,160,31 +16*8,{&destination_keys[2]}},
  {"PLAYER 4" ,0x400 ,m_scrn,160,31 +17*8,{&destination_keys[3]}},
  {"BACKSPACE" ,0x400 ,m_scrn,160,31 +18*8,{&key_backspace}},
  {"ENTER" ,0x400 ,m_scrn,160,31 +19*8,{&key_enter}},

  {"<- PREV" ,0x2000|0x100,m_null,57,31 +20*8, {keys_settings3}},



  {0,0x2000|0x8000,m_null}

};





void M_KeyBindings(int choice)
{
  M_SetupNextMenu(&KeybndDef);

  setup_active = 1;
  setup_screen = ss_keys;
  set_keybnd_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = keys_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




void M_DrawKeybnd(void)
{
  menuactive = mnact_full;



  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(84, 2, "M_KEYBND", CR_RED, "KEY BINDINGS", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}
# 2365 "c:/devl/prboom3ds/src/m_menu.c"
enum {
  weap_recoil,
  weap_bobbing,
  weap_bfg,
  weap_stub1,
  weap_pref1,
  weap_pref2,
  weap_pref3,
  weap_pref4,
  weap_pref5,
  weap_pref6,
  weap_pref7,
  weap_pref8,
  weap_pref9,
  weap_stub2,
  weap_toggle,
  weap_toggle2,
};

setup_menu_t weap_settings1[];

setup_menu_t* weap_settings[] =
{
  weap_settings1,
  ((void *)0)
};

setup_menu_t weap_settings1[] =
{
  {"ENABLE RECOIL", 0x8,m_null,203, 33 + weap_recoil*8, {"weapon_recoil"}},
  {"ENABLE BOBBING",0x8,m_null,203, 33 +weap_bobbing*8, {"player_bobbing"}},

  {"1ST CHOICE WEAPON",0x800,m_null,203,33 +weap_pref1*8, {"weapon_choice_1"}},
  {"2nd CHOICE WEAPON",0x800,m_null,203,33 +weap_pref2*8, {"weapon_choice_2"}},
  {"3rd CHOICE WEAPON",0x800,m_null,203,33 +weap_pref3*8, {"weapon_choice_3"}},
  {"4th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref4*8, {"weapon_choice_4"}},
  {"5th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref5*8, {"weapon_choice_5"}},
  {"6th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref6*8, {"weapon_choice_6"}},
  {"7th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref7*8, {"weapon_choice_7"}},
  {"8th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref8*8, {"weapon_choice_8"}},
  {"9th CHOICE WEAPON",0x800,m_null,203,33 +weap_pref9*8, {"weapon_choice_9"}},

  {"Enable Fist/Chainsaw\n& SG/SSG toggle", 0x8, m_null, 203,
   33 + weap_toggle*8, {"doom_weapon_toggles"}},


  {0,0x80,m_null,301,3},


  {0,0x2000|0x8000,m_null}

};





void M_Weapons(int choice)
{
  M_SetupNextMenu(&WeaponDef);

  setup_active = 1;
  setup_screen = ss_weap;
  set_weapon_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = weap_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}





void M_DrawWeapons(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(109, 2, "M_WEAP", CR_RED, "WEAPONS", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}
# 2470 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t stat_settings1[];

setup_menu_t* stat_settings[] =
{
  stat_settings1,
  ((void *)0)
};

setup_menu_t stat_settings1[] =
{
  {"STATUS BAR" ,0x2000|0x4,m_null,203,31 + 1*8 },

  {"USE RED NUMBERS" ,0x8, m_null,203,31 + 2*8, {"sts_always_red"}},
  {"GRAY %" ,0x8, m_null,203,31 + 3*8, {"sts_pct_always_gray"}},
  {"SINGLE KEY DISPLAY",0x8, m_null,203,31 + 4*8, {"sts_traditional_keys"}},

  {"HEADS-UP DISPLAY" ,0x2000|0x4,m_null,203,31 + 6*8},

  {"HIDE SECRETS" ,0x8 ,m_null,203,31 + 7*8, {"hud_nosecrets"}},
  {"HEALTH LOW/OK" ,0x1000 ,m_null,203,31 + 8*8, {"health_red"}},
  {"HEALTH OK/GOOD" ,0x1000 ,m_null,203,31 + 9*8, {"health_yellow"}},
  {"HEALTH GOOD/EXTRA" ,0x1000 ,m_null,203,31 +10*8, {"health_green"}},
  {"ARMOR LOW/OK" ,0x1000 ,m_null,203,31 +11*8, {"armor_red"}},
  {"ARMOR OK/GOOD" ,0x1000 ,m_null,203,31 +12*8, {"armor_yellow"}},
  {"ARMOR GOOD/EXTRA" ,0x1000 ,m_null,203,31 +13*8, {"armor_green"}},
  {"AMMO LOW/OK" ,0x1000 ,m_null,203,31 +14*8, {"ammo_red"}},
  {"AMMO OK/GOOD" ,0x1000 ,m_null,203,31 +15*8, {"ammo_yellow"}},


  {0,0x80,m_null,301,3},


  {0,0x2000|0x8000,m_null}
};





void M_StatusBar(int choice)
{
  M_SetupNextMenu(&StatusHUDDef);

  setup_active = 1;
  setup_screen = ss_stat;
  set_status_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = stat_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}





void M_DrawStatusHUD(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(59, 2, "M_STAT", CR_RED, "STATUS BAR / HUD", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}
# 2558 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t auto_settings1[];
setup_menu_t auto_settings2[];

setup_menu_t* auto_settings[] =
{
  auto_settings1,
  auto_settings2,
  ((void *)0)
};

setup_menu_t auto_settings1[] =
{
  {"background", 0x20, m_null, 250, 31, {"mapcolor_back"}},
  {"grid lines", 0x20, m_null, 250, 31 + 1*8, {"mapcolor_grid"}},
  {"normal 1s wall", 0x20, m_null,250,31 + 2*8, {"mapcolor_wall"}},
  {"line at floor height change", 0x20, m_null, 250, 31 + 3*8, {"mapcolor_fchg"}},
  {"line at ceiling height change" ,0x20,m_null,250,31 + 4*8, {"mapcolor_cchg"}},
  {"line at sector with floor = ceiling",0x20,m_null,250,31 + 5*8, {"mapcolor_clsd"}},
  {"red key" ,0x20,m_null,250,31 + 6*8, {"mapcolor_rkey"}},
  {"blue key" ,0x20,m_null,250,31 + 7*8, {"mapcolor_bkey"}},
  {"yellow key" ,0x20,m_null,250,31 + 8*8, {"mapcolor_ykey"}},
  {"red door" ,0x20,m_null,250,31 + 9*8, {"mapcolor_rdor"}},
  {"blue door" ,0x20,m_null,250,31 +10*8, {"mapcolor_bdor"}},
  {"yellow door" ,0x20,m_null,250,31 +11*8, {"mapcolor_ydor"}},

  {"AUTOMAP LEVEL TITLE COLOR" ,0x10,m_null,250,31 +13*8, {"hudcolor_titl"}},
  {"AUTOMAP COORDINATES COLOR" ,0x10,m_null,250,31 +14*8, {"hudcolor_xyco"}},

  {"Show Secrets only after entering",0x8,m_null,250,31 +15*8, {"map_secret_after"}},

  {"Show coordinates of automap pointer",0x8,m_null,250,31 +16*8, {"map_point_coord"}},


  {0,0x80,m_null,301,3},

  {"NEXT ->",0x2000|0x200,m_null,310,31 +20*8, {auto_settings2}},


  {0,0x2000|0x8000,m_null}

};

setup_menu_t auto_settings2[] =
{
  {"teleporter line" ,0x20 ,m_null,250,31, {"mapcolor_tele"}},
  {"secret sector boundary" ,0x20 ,m_null,250,31 + 1*8, {"mapcolor_secr"}},

  {"exit line" ,0x20 ,m_null,250,31 + 2*8, {"mapcolor_exit"}},
  {"computer map unseen line" ,0x20 ,m_null,250,31 + 3*8, {"mapcolor_unsn"}},
  {"line w/no floor/ceiling changes",0x20 ,m_null,250,31 + 4*8, {"mapcolor_flat"}},
  {"general sprite" ,0x20 ,m_null,250,31 + 5*8, {"mapcolor_sprt"}},
  {"countable enemy sprite" ,0x20 ,m_null,250,31 + 6*8, {"mapcolor_enemy"}},
  {"countable item sprite" ,0x20 ,m_null,250,31 + 7*8, {"mapcolor_item"}},
  {"crosshair" ,0x20 ,m_null,250,31 + 8*8, {"mapcolor_hair"}},
  {"single player arrow" ,0x20 ,m_null,250,31 + 9*8, {"mapcolor_sngl"}},
  {"your colour in multiplayer" ,0x20 ,m_null,250,31 +10*8, {"mapcolor_me"}},

  {"friends" ,0x20 ,m_null,250,31 +12*8, {"mapcolor_frnd"}},

  {"<- PREV",0x2000|0x100,m_null,57,31 +20*8, {auto_settings1}},



  {0,0x2000|0x8000,m_null}

};






void M_Automap(int choice)
{
  M_SetupNextMenu(&AutoMapDef);

  setup_active = 1;
  setup_screen = ss_auto;
  set_auto_active = 1;
  setup_select = 0;
  colorbox_active = 0;
  default_verify = 0;
  setup_gather = 0;
  set_menu_itemon = 0;
  mult_screens_index = 0;
  current_setup_menu = auto_settings[0];
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




int color_palette_x;
int color_palette_y;
byte palette_background[16*(7 +1)+8];







static void M_DrawColPal(void)
{
  int cpx, cpy;





  V_DrawNumPatch(((320 - 16*(7 +1))/2)-5,((200 - 16*(7 +1))/2)-5,0,W_GetNumForName("M_COLORS"),CR_RED,VPT_STRETCH);




  cpx = ((320 - 16*(7 +1))/2)+color_palette_x*(7 +1)-1;
  cpy = ((200 - 16*(7 +1))/2)+color_palette_y*(7 +1)-1;

  V_DrawNumPatch(cpx,cpy,0,W_GetNumForName("M_PALSEL"),CR_RED,VPT_STRETCH);
}




void M_DrawAutoMap(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(109, 2, "M_AUTO", CR_RED, "AUTOMAP", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);



  if (colorbox_active)
    M_DrawColPal();




  else if (default_verify)
    M_DrawDefVerify();
}
# 2714 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t enem_settings1[];

setup_menu_t* enem_settings[] =
{
  enem_settings1,
  ((void *)0)
};

enum {
  enem_infighting,

  enem_remember = 1,

  enem_backing,
  enem_monkeys,
  enem_avoid_hazards,
  enem_friction,
  enem_help_friends,


  enem_helpers,


  enem_distfriend,


  enem_dog_jumping,


  enem_end
};

setup_menu_t enem_settings1[] =
{

  {"Monster Infighting When Provoked",0x8,m_null,250,31 + enem_infighting*8, {"monster_infighting"}},

  {"Remember Previous Enemy",0x8,m_null,250,31 + enem_remember*8, {"monsters_remember"}},


  {"Monster Backing Out",0x8,m_null,250,31 + enem_backing*8, {"monster_backing"}},

  {"Climb Steep Stairs", 0x8,m_null,250,31 +enem_monkeys*8, {"monkeys"}},


  {"Intelligently Avoid Hazards",0x8,m_null,250,31 + enem_avoid_hazards*8, {"monster_avoid_hazards"}},


  {"Affected by Friction",0x8,m_null,250,31 + enem_friction*8, {"monster_friction"}},

  {"Rescue Dying Friends",0x8,m_null,250,31 + enem_help_friends*8, {"help_friends"}},



  {"Number Of Single-Player Helper Dogs",0x1000|0x10000,m_null,250,31 + enem_helpers*8, {"player_helpers"}},


  {"Distance Friends Stay Away",0x1000,m_null,250,31 + enem_distfriend*8, {"friend_distance"}},

  {"Allow dogs to jump down",0x8,m_null,250,31 + enem_dog_jumping*8, {"dog_jumping"}},



  {0,0x80,m_null,301,3},


  {0,0x2000|0x8000,m_null}

};







void M_Enemy(int choice)
{
  M_SetupNextMenu(&EnemyDef);

  setup_active = 1;
  setup_screen = ss_enem;
  set_enemy_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = enem_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




void M_DrawEnemy(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(114, 2, "M_ENEM", CR_RED, "ENEMIES", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}







extern int usejoystick, usemouse, default_mus_card, default_snd_card;
extern int detect_voices, realtic_clock_rate, tran_filter_pct;

setup_menu_t gen_settings1[], gen_settings2[], gen_settings3[];

setup_menu_t* gen_settings[] =
{
  gen_settings1,
  gen_settings2,
  gen_settings3,
  ((void *)0)
};

enum {
  general_trans,
  general_transpct,
  general_fullscreen,
  general_videomode,


  general_uncapped,
};

enum {
  general_gl_texfilter,
  general_gl_texformat,
  general_flooroffset,
};

enum {



  general_sndchan,
  general_pitch
};







static const char *videomodes[] = {"8bit","15bit","16bit",
                                   "32bit","OpenGL", ((void *)0)};

static const char *gltexfilters[] = {"GL_NEAREST","GL_LINEAR",
                                     "GL_LINEAR_MIPMAP_LINEAR",
                                     ((void *)0)};

static const char *gltexformats[] = {"GL_RGBA","GL_RGB5_A1",
                                     "GL_RGBA4", ((void *)0)};

setup_menu_t gen_settings1[] = {

  {"Video" ,0x2000|0x4, m_null, 250, 44 - 12},

  {"Enable Translucency", 0x8, m_null, 250,
   44 + general_trans*8, {"translucency"}, 0, 0, M_Trans},

  {"Translucency filter percentage", 0x1000, m_null, 250,
   44 + general_transpct*8, {"tran_filter_pct"}, 0, 0, M_Trans},

  {"Fullscreen Video mode", 0x8|0x20000, m_null, 250,
   44 + general_fullscreen*8, {"use_fullscreen"}, 0, 0, ((void *)0)},

  {"Video mode", 0x800000|0x20000, m_null, 250,
   44 + general_videomode*8, {"videomode"}, 0, 0, ((void *)0), videomodes},

  {"Uncapped Framerate", 0x8, m_null, 250,
  44 + general_uncapped*8, {"uncapped_framerate"}},
# 2929 "c:/devl/prboom3ds/src/m_menu.c"
  {"Sound & Music", 0x2000|0x4, m_null, 250, ((44 +9*8)+5*8) - 12},
# 2941 "c:/devl/prboom3ds/src/m_menu.c"
  {"Number of Sound Channels", 0x1000|0x20000, m_null, 250,
   ((44 +9*8)+5*8) + general_sndchan*8, {"snd_channels"}},

  {"Enable v1.1 Pitch Effects", 0x8, m_null, 250,
   ((44 +9*8)+5*8) + general_pitch*8, {"pitched_sounds"}},


  {0,0x80,m_null,301,3},

  {"NEXT ->",0x2000|0x200,m_null,310,31 +20*8, {gen_settings2}},


  {0,0x2000|0x8000,m_null}
};

enum {
  general_mouse,
  general_joy,
  general_leds
};

enum {
  general_wad1,
  general_wad2,
  general_deh1,
  general_deh2
};

enum {
  general_corpse,
  general_realtic,
  general_smooth,
  general_smoothfactor,
  general_defskill,
  general_menubg,
};





static const char *gen_skillstrings[] = {

  "", "ITYTD", "HNTR", "HMP", "UV", "NM", ((void *)0)
};

setup_menu_t gen_settings2[] = {

  {"Input Devices" ,0x2000|0x4, m_null, 250, 44 - 12},

  {"Enable Mouse", 0x8, m_null, 250,
   44 + general_mouse*8, {"use_mouse"}},






  {"Files Preloaded at Game Startup",0x2000|0x4, m_null, 250,
   (44 +44) - 12},

  {"WAD # 1", 0x80000, m_null, 76, (44 +44) + general_wad1*8, {"wadfile_1"}},

  {"WAD #2", 0x80000, m_null, 76, (44 +44) + general_wad2*8, {"wadfile_2"}},

  {"DEH/BEX # 1", 0x80000, m_null, 76, (44 +44) + general_deh1*8, {"dehfile_1"}},

  {"DEH/BEX #2", 0x80000, m_null, 76, (44 +44) + general_deh2*8, {"dehfile_2"}},

  {"Miscellaneous" ,0x2000|0x4, m_null, 250, ((44 +44)+52) - 12},

  {"Maximum number of player corpses", 0x1000|0x20000, m_null, 250,
   ((44 +44)+52) + general_corpse*8, {"max_player_corpse"}},

  {"Game speed, percentage of normal", 0x1000|0x20000, m_null, 250,
   ((44 +44)+52) + general_realtic*8, {"realtic_clock_rate"}},

  {"Smooth Demo Playback", 0x8, m_null, 250,
   ((44 +44)+52) + general_smooth*8, {"demo_smoothturns"}, 0, 0, M_ChangeDemoSmoothTurns},

  {"Smooth Demo Playback Factor", 0x1000, m_null, 250,
   ((44 +44)+52) + general_smoothfactor*8, {"demo_smoothturnsfactor"}, 0, 0, M_ChangeDemoSmoothTurns},

  {"Default skill level", 0x800000, m_null, 250,
    ((44 +44)+52) + general_defskill*8, {"default_skill"}, 0, 0, ((void *)0), gen_skillstrings},

  {"Fullscreen menu background", 0x8, m_null, 250,
    ((44 +44)+52) + general_menubg*8, {"menu_background"}},

  {"<- PREV",0x2000|0x100, m_null, 57, 31 +20*8, {gen_settings1}},

  {"NEXT ->",0x2000|0x200,m_null,310,31 +20*8, {gen_settings3}},



  {0,0x2000|0x8000,m_null}
};

enum {
  general_filterwall,
  general_filterfloor,
  general_filtersprite,
  general_filterpatch,
  general_filterz,
  general_filter_threshold,
  general_spriteedges,
  general_patchedges,
  general_hom,
};



static const char *renderfilters[] = {"none", "point", "linear", "rounded"};
static const char *edgetypes[] = {"jagged", "sloped"};

setup_menu_t gen_settings3[] = {

  {"Renderer settings" ,0x2000|0x4, m_null, 250, 44 - 12},

  {"Filter for walls", 0x800000, m_null, 250,
   44 + general_filterwall*8, {"filter_wall"}, 0, 0, ((void *)0), renderfilters},

  {"Filter for floors/ceilings", 0x800000, m_null, 250,
   44 + general_filterfloor*8, {"filter_floor"}, 0, 0, ((void *)0), renderfilters},

  {"Filter for sprites", 0x800000, m_null, 250,
   44 + general_filtersprite*8, {"filter_sprite"}, 0, 0, ((void *)0), renderfilters},

  {"Filter for patches", 0x800000, m_null, 250,
   44 + general_filterpatch*8, {"filter_patch"}, 0, 0, ((void *)0), renderfilters},

  {"Filter for lighting", 0x800000, m_null, 250,
   44 + general_filterz*8, {"filter_z"}, 0, 0, ((void *)0), renderfilters},

  {"Drawing of sprite edges", 0x800000, m_null, 250,
   44 + general_spriteedges*8, {"sprite_edges"}, 0, 0, ((void *)0), edgetypes},

  {"Drawing of patch edges", 0x800000, m_null, 250,
   44 + general_patchedges*8, {"patch_edges"}, 0, 0, ((void *)0), edgetypes},

  {"Flashing HOM indicator", 0x8, m_null, 250,
   44 + general_hom*8, {"flashing_hom"}},

  {"<- PREV",0x2000|0x100, m_null, 57, 31 +20*8, {gen_settings2}},



  {0,0x2000|0x8000,m_null}
};

void M_Trans(void)
{
  general_translucency = default_translucency;

  if (general_translucency)
    R_InitTranMap(0);
}

void M_FullScreen(void)
{
  I_UpdateVideoMode();
  V_SetPalette(0);
}

void M_ChangeDemoSmoothTurns(void)
{
  if (demo_smoothturns)
    gen_settings2[12].m_flags &= ~(0x2000|0x2);
  else
    gen_settings2[12].m_flags |= (0x2000|0x2);

  R_SmoothPlaying_Reset(((void *)0));
}





void M_General(int choice)
{
  M_SetupNextMenu(&GeneralDef);

  setup_active = 1;
  setup_screen = ss_gen;
  set_general_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = gen_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




void M_DrawGeneral(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(114, 2, "M_GENERL", CR_RED, "GENERAL", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}
# 3167 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t comp_settings1[], comp_settings2[], comp_settings3[];

setup_menu_t* comp_settings[] =
{
  comp_settings1,
  comp_settings2,
  comp_settings3,
  ((void *)0)
};

enum
{
  compat_telefrag,
  compat_dropoff,
  compat_falloff,
  compat_staylift,
  compat_doorstuck,
  compat_pursuit,
  compat_vile,
  compat_pain,
  compat_skull,
  compat_blazing,
  compat_doorlight = 0,
  compat_god,
  compat_infcheat,
  compat_zombie,
  compat_skymap,
  compat_stairs,
  compat_floors,
  compat_moveblock,
  compat_model,
  compat_zerotags,
  compat_666 = 0,
  compat_soul,
  compat_maskedanim,
  compat_sound
};

setup_menu_t comp_settings1[] =
{
  {"Any monster can telefrag on MAP30", 0x8, m_null, 284,
   32 + compat_telefrag * 12, {"comp_telefrag"}},

  {"Some objects never hang over tall ledges", 0x8, m_null, 284,
   32 + compat_dropoff * 12, {"comp_dropoff"}},

  {"Objects don't fall under their own weight", 0x8, m_null, 284,
   32 + compat_falloff * 12, {"comp_falloff"}},

  {"Monsters randomly walk off of moving lifts", 0x8, m_null, 284,
   32 + compat_staylift * 12, {"comp_staylift"}},

  {"Monsters get stuck on doortracks", 0x8, m_null, 284,
   32 + compat_doorstuck * 12, {"comp_doorstuck"}},

  {"Monsters don't give up pursuit of targets", 0x8, m_null, 284,
   32 + compat_pursuit * 12, {"comp_pursuit"}},

  {"Arch-Vile resurrects invincible ghosts", 0x8, m_null, 284,
   32 + compat_vile * 12, {"comp_vile"}},

  {"Pain Elementals limited to 21 lost souls", 0x8, m_null, 284,
   32 + compat_pain * 12, {"comp_pain"}},

  {"Lost souls get stuck behind walls", 0x8, m_null, 284,
   32 + compat_skull * 12, {"comp_skull"}},

  {"Blazing doors make double closing sounds", 0x8, m_null, 284,
   32 + compat_blazing * 12, {"comp_blazing"}},


  {0,0x80,m_null,301,3},

  {"NEXT ->",0x2000|0x200, m_null, 310, 32 +131, {comp_settings2}},


  {0,0x2000|0x8000,m_null}
};

setup_menu_t comp_settings2[] =
{
  {"Tagged doors don't trigger special lighting", 0x8, m_null, 284,
   32 + compat_doorlight * 12, {"comp_doorlight"}},

  {"God mode isn't absolute", 0x8, m_null, 284,
   32 + compat_god * 12, {"comp_god"}},

  {"Powerup cheats are not infinite duration", 0x8, m_null, 284,
   32 + compat_infcheat * 12, {"comp_infcheat"}},

  {"Dead players can exit levels", 0x8, m_null, 284,
   32 + compat_zombie * 12, {"comp_zombie"}},

  {"Sky is unaffected by invulnerability", 0x8, m_null, 284,
   32 + compat_skymap * 12, {"comp_skymap"}},

  {"Use exactly Doom's stairbuilding method", 0x8, m_null, 284,
   32 + compat_stairs * 12, {"comp_stairs"}},

  {"Use exactly Doom's floor motion behavior", 0x8, m_null, 284,
   32 + compat_floors * 12, {"comp_floors"}},

  {"Use exactly Doom's movement clipping code", 0x8, m_null, 284,
   32 + compat_moveblock * 12, {"comp_moveblock"}},

  {"Use exactly Doom's linedef trigger model", 0x8, m_null, 284,
   32 + compat_model * 12, {"comp_model"}},

  {"Linedef effects work with sector tag = 0", 0x8, m_null, 284,
   32 + compat_zerotags * 12, {"comp_zerotags"}},

  {"<- PREV", 0x2000|0x100, m_null, 57, 32 +131,{comp_settings1}},

  {"NEXT ->",0x2000|0x200, m_null, 310, 32 +131, {comp_settings3}},



  {0,0x2000|0x8000,m_null}
};

setup_menu_t comp_settings3[] =
{
  {"All boss types can trigger tag 666 at ExM8", 0x8, m_null, 284,
   32 + compat_666 * 12, {"comp_666"}},

  {"Lost souls don't bounce off flat surfaces", 0x8, m_null, 284,
   32 + compat_soul * 12, {"comp_soul"}},

  {"2S middle textures do not animate", 0x8, m_null, 284,
   32 + compat_maskedanim * 12, {"comp_maskedanim"}},

  {"Use exactly Doom's sound code behavior", 0x8, m_null, 284,
   32 + compat_sound * 12, {"comp_sound"}},

  {"<- PREV", 0x2000|0x100, m_null, 57, 32 +131,{comp_settings2}},



  {0,0x2000|0x8000,m_null}
};





void M_Compat(int choice)
{
  M_SetupNextMenu(&CompatDef);

  setup_active = 1;
  setup_screen = ss_comp;
  set_general_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = comp_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




void M_DrawCompat(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);

  M_DrawTitle(52, 2, "M_COMPAT", CR_RED, "DOOM COMPATIBILITY", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}
# 3358 "c:/devl/prboom3ds/src/m_menu.c"
enum {
  mess_color_play,
  mess_timer,
  mess_color_chat,
  mess_chat_timer,
  mess_color_review,
  mess_timed,
  mess_hud_timer,
  mess_lines,
  mess_scrollup,
  mess_background,
};

setup_menu_t mess_settings1[];

setup_menu_t* mess_settings[] =
{
  mess_settings1,
  ((void *)0)
};

setup_menu_t mess_settings1[] =
{
  {"Message Color During Play", 0x10, m_null, 230,
   39 + mess_color_play*8, {"hudcolor_mesg"}},






  {"Chat Message Color", 0x10, m_null, 230,
   39 + mess_color_chat*8, {"hudcolor_chat"}},






  {"Message Review Color", 0x10, m_null, 230,
   39 + mess_color_review*8, {"hudcolor_list"}},
# 3408 "c:/devl/prboom3ds/src/m_menu.c"
  {"Number of Review Message Lines", 0x1000, m_null, 230,
   39 + mess_lines*8, {"hud_msg_lines"}},






  {"Message Background", 0x8, m_null, 230,
   39 + mess_background*8, {"hud_list_bgon"}},


  {0,0x80,m_null,301,3},



  {0,0x2000|0x8000,m_null}
};






void M_Messages(int choice)
{
  M_SetupNextMenu(&MessageDef);

  setup_active = 1;
  setup_screen = ss_mess;
  set_mess_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = mess_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}





void M_DrawMessages(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(103, 2, "M_MESS", CR_RED, "MESSAGES", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);
  if (default_verify)
    M_DrawDefVerify();
}
# 3475 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t chat_settings1[];

setup_menu_t* chat_settings[] =
{
  chat_settings1,
  ((void *)0)
};

setup_menu_t chat_settings1[] =
{
  {"1",0x40,m_null,20,(31+8)+ 1*8, {"chatmacro1"}},
  {"2",0x40,m_null,20,(31+8)+ 2*8, {"chatmacro2"}},
  {"3",0x40,m_null,20,(31+8)+ 3*8, {"chatmacro3"}},
  {"4",0x40,m_null,20,(31+8)+ 4*8, {"chatmacro4"}},
  {"5",0x40,m_null,20,(31+8)+ 5*8, {"chatmacro5"}},
  {"6",0x40,m_null,20,(31+8)+ 6*8, {"chatmacro6"}},
  {"7",0x40,m_null,20,(31+8)+ 7*8, {"chatmacro7"}},
  {"8",0x40,m_null,20,(31+8)+ 8*8, {"chatmacro8"}},
  {"9",0x40,m_null,20,(31+8)+ 9*8, {"chatmacro9"}},
  {"0",0x40,m_null,20,(31+8)+10*8, {"chatmacro0"}},


  {0,0x80,m_null,301,3},


  {0,0x2000|0x8000,m_null}

};





void M_ChatStrings(int choice)
{
  M_SetupNextMenu(&ChatStrDef);
  setup_active = 1;
  setup_screen = ss_chat;
  set_chat_active = 1;
  setup_select = 0;
  default_verify = 0;
  setup_gather = 0;
  mult_screens_index = 0;
  current_setup_menu = chat_settings[0];
  set_menu_itemon = 0;
  while (current_setup_menu[set_menu_itemon++].m_flags & 0x2000);
  current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
}




void M_DrawChatStrings(void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);


  M_DrawTitle(83, 2, "M_CHAT", CR_RED, "CHAT STRINGS", CR_GOLD);
  M_DrawInstructions();
  M_DrawScreenItems(current_setup_menu);




  if (default_verify)
    M_DrawDefVerify();
}






static boolean shiftdown = 0;





static void M_SelectDone(setup_menu_t* ptr)
{
  ptr->m_flags &= ~0x2;
  ptr->m_flags |= 0x1;
  S_StartSound(((void *)0),sfx_itemup);
  setup_select = 0;
  colorbox_active = 0;
  if (print_warning_about_changes)
    print_warning_about_changes--;
}




static setup_menu_t **setup_screens[] =
{
  keys_settings,
  weap_settings,
  stat_settings,
  auto_settings,
  enem_settings,
  mess_settings,
  chat_settings,
  gen_settings,
  comp_settings,
};






static void M_ResetDefaults(void)
{
  int i;

  default_t *dp;
  int warn = 0;
# 3606 "c:/devl/prboom3ds/src/m_menu.c"
  for (i = 0; i < numdefaults ; i++)
  {
    dp = &defaults[i];

    if (dp->setupscreen == setup_screen)
      {
  setup_menu_t **l, *p;
  for (l = setup_screens[setup_screen-1]; *l; l++)
    for (p = *l; !(p->m_flags & 0x8000); p++)
      if (p->m_flags & ((0x40|0x80000)|0x8|0x1000|0x800|0x20|0x10|0x800000) ? p->var.def == dp :
    p->var.m_key == dp->location.pi ||
    p->m_mouse == dp->location.pi ||
    p->m_joy == dp->location.pi)
        {
    if (((*dp).type == def_str))
    {
      union { const char **c; char **s; } u;

      u.c = dp->location.ppsz;
      Z_Free(*(u.s));
      *(u.c) = Z_Strdup(dp->defaultvalue.psz,PU_STATIC,0);
    }
    else
      *dp->location.pi = dp->defaultvalue.i;
# 3641 "c:/devl/prboom3ds/src/m_menu.c"
    if (p->action)
      p->action();

    goto end;
        }
      end:;
      }
  }

  if (warn)
    (warning_about_changes=(warn), print_warning_about_changes = 2);
}
# 3664 "c:/devl/prboom3ds/src/m_menu.c"
static void M_InitDefaults(void)
{
  setup_menu_t *const *p, *t;
  default_t *dp;
  int i;
  for (i = 0; i < ss_max-1; i++)
    for (p = setup_screens[i]; *p; p++)
      for (t = *p; !(t->m_flags & 0x8000); t++)
  if (t->m_flags & ((0x40|0x80000)|0x8|0x1000|0x800|0x20|0x10|0x800000)) {
    if (!(dp = M_LookupDefault(t->var.name)))
      I_Error("M_InitDefaults: Couldn't find config variable %s", t->var.name);
    else
      (t->var.def = dp)->setup_menu = t;
  }
}
# 3702 "c:/devl/prboom3ds/src/m_menu.c"
int extended_help_count;
int extended_help_index;

menuitem_t ExtHelpMenu[] =
{
  {1,"",M_ExtHelpNextScreen,0}
};

menu_t ExtHelpDef =
{
  1,
  &ReadDef1,
  ExtHelpMenu,
  M_DrawExtHelp,
  330,181,
  0
};




void M_ExtHelpNextScreen(int choice)
{
  choice = 0;
  if (++extended_help_index > extended_help_count)
    {



      extended_help_index = 1;
      M_SetupNextMenu(&MainDef);
    }
}





void M_InitExtendedHelp(void)

{
  int index,i;
  char namebfr[] = { "HELPnn"} ;

  extended_help_count = 0;
  for (index = 1 ; index < 100 ; index++) {
    namebfr[4] = index/10 + 0x30;
    namebfr[5] = index%10 + 0x30;
    i = (W_CheckNumForName)(namebfr, ns_global);
    if (i == -1) {
      if (extended_help_count) {
        if (gamemode == commercial) {
          ExtHelpDef.prevMenu = &ReadDef1;
          ReadMenu1[0].routine = M_ExtHelp;
  } else {
          ExtHelpDef.prevMenu = &ReadDef2;
          ReadMenu2[0].routine = M_ExtHelp;
  }
      }
      return;
    }
    extended_help_count++;
  }

}



void M_ExtHelp(int choice)
{
  choice = 0;
  extended_help_index = 1;
  M_SetupNextMenu(&ExtHelpDef);
}



void M_DrawExtHelp(void)
{
  char namebfr[10] = { "HELPnn" };

  inhelpscreens = 1;
  namebfr[4] = extended_help_index/10 + 0x30;
  namebfr[5] = extended_help_index%10 + 0x30;

  V_DrawNumPatch(0,0,0,W_GetNumForName(namebfr),CR_RED,VPT_STRETCH);
}
# 3809 "c:/devl/prboom3ds/src/m_menu.c"
int M_GetKeyString(int c,int offset)
{
  const char* s;

  if (c >= 33 && c <= 126) {







    if (c == '=')
      c = '+';
    else if (c == ',')
      c = '<';
    else if (c == '.')
      c = '>';
    menu_buffer[offset++] = c;
    menu_buffer[offset] = 0;

  } else {





    if ((0x100 <= c) && (c < 0x200)) {
      if (c == (0x100 + 13))
  s = "PADE";
      else {
  strcpy(&menu_buffer[offset], "PAD");
  offset+=4;
  menu_buffer[offset-1] = c & 0xff;
  menu_buffer[offset] = 0;
      }
    } else if (((0x80+0x3b) <= c) && (c < (0x80+0x44))) {
      menu_buffer[offset++] = 'F';
      menu_buffer[offset++] = '1' + c - (0x80+0x3b);
      menu_buffer[offset] = 0;
    } else {
      switch(c) {
      case 9: s = "TAB"; break;
      case 13: s = "ENTR"; break;
      case 27: s = "ESC"; break;
      case 0x20: s = "SPAC"; break;
      case 127: s = "BACK"; break;
      case (0x80+0x1d): s = "CTRL"; break;
      case 0xac: s = "LARR"; break;
      case 0xad: s = "UARR"; break;
      case 0xae: s = "RARR"; break;
      case 0xaf: s = "DARR"; break;
      case (0x80+0x36): s = "SHFT"; break;
      case (0x80+0x38): s = "ALT"; break;
      case 0xba: s = "CAPS"; break;
      case 0xc6: s = "SCRL"; break;
      case 0xc7: s = "HOME"; break;
      case 0xc9: s = "PGUP"; break;
      case 0xcf: s = "END"; break;
      case 0xd1: s = "PGDN"; break;
      case 0xd2: s = "INST"; break;
      case 0xc8: s = "DEL"; break;
      case (0x80+0x44): s = "F10"; break;
      case (0x80+0x57): s = "F11"; break;
      case (0x80+0x58): s = "F12"; break;
      case 0xff: s = "PAUS"; break;
      default: s = "JUNK"; break;
      }

      if (s) {
  strcpy(&menu_buffer[offset],s);
  offset += strlen(s);
      }
    }
  }
  return offset;
}
# 3898 "c:/devl/prboom3ds/src/m_menu.c"
setup_menu_t helpstrings[] =
{
  {"SCREEN" ,0x2000|0x4,m_null,283,2},
  {"HELP" ,0x2000|0x400,m_null,283,2 + 1*8,{&key_help}},
  {"MENU" ,0x2000|0x400,m_null,283,2 + 2*8,{&key_escape}},
  {"SETUP" ,0x2000|0x400,m_null,283,2 + 3*8,{&key_setup}},
  {"PAUSE" ,0x2000|0x400,m_null,283,2 + 4*8,{&key_pause}},
  {"AUTOMAP" ,0x2000|0x400,m_null,283,2 + 5*8,{&key_map}},
  {"SOUND VOLUME",0x2000|0x400,m_null,283,2 + 6*8,{&key_soundvolume}},
  {"HUD" ,0x2000|0x400,m_null,283,2 + 7*8,{&key_hud}},
  {"MESSAGES" ,0x2000|0x400,m_null,283,2 + 8*8,{&key_messages}},
  {"GAMMA FIX" ,0x2000|0x400,m_null,283,2 + 9*8,{&key_gamma}},
  {"SPY" ,0x2000|0x400,m_null,283,2 +10*8,{&key_spy}},
  {"LARGER VIEW" ,0x2000|0x400,m_null,283,2 +11*8,{&key_zoomin}},
  {"SMALLER VIEW",0x2000|0x400,m_null,283,2 +12*8,{&key_zoomout}},
  {"SCREENSHOT" ,0x2000|0x400,m_null,283,2 +13*8,{&key_screenshot}},

  {"AUTOMAP" ,0x2000|0x4,m_null,283,118},
  {"FOLLOW MODE" ,0x2000|0x400,m_null,283,118 + 1*8,{&key_map_follow}},
  {"ZOOM IN" ,0x2000|0x400,m_null,283,118 + 2*8,{&key_map_zoomin}},
  {"ZOOM OUT" ,0x2000|0x400,m_null,283,118 + 3*8,{&key_map_zoomout}},
  {"MARK PLACE" ,0x2000|0x400,m_null,283,118 + 4*8,{&key_map_mark}},
  {"CLEAR MARKS" ,0x2000|0x400,m_null,283,118 + 5*8,{&key_map_clear}},
  {"FULL/ZOOM" ,0x2000|0x400,m_null,283,118 + 6*8,{&key_map_gobig}},
  {"GRID" ,0x2000|0x400,m_null,283,118 + 7*8,{&key_map_grid}},

  {"WEAPONS" ,0x2000|0x4,m_null,87,2},
  {"FIST" ,0x2000|0x400,m_null,87,2 + 1*8,{&key_weapon1}},
  {"PISTOL" ,0x2000|0x400,m_null,87,2 + 2*8,{&key_weapon2}},
  {"SHOTGUN" ,0x2000|0x400,m_null,87,2 + 3*8,{&key_weapon3}},
  {"CHAINGUN" ,0x2000|0x400,m_null,87,2 + 4*8,{&key_weapon4}},
  {"ROCKET" ,0x2000|0x400,m_null,87,2 + 5*8,{&key_weapon5}},
  {"PLASMA" ,0x2000|0x400,m_null,87,2 + 6*8,{&key_weapon6}},
  {"BFG 9000" ,0x2000|0x400,m_null,87,2 + 7*8,{&key_weapon7}},
  {"CHAINSAW" ,0x2000|0x400,m_null,87,2 + 8*8,{&key_weapon8}},
  {"SSG" ,0x2000|0x400,m_null,87,2 + 9*8,{&key_weapon9}},
  {"BEST" ,0x2000|0x400,m_null,87,2 +10*8,{&key_weapontoggle}},
  {"FIRE" ,0x2000|0x400,m_null,87,2 +11*8,{&key_fire},&mousebfire,&joybfire},

  {"MOVEMENT" ,0x2000|0x4,m_null,87,102},
  {"FORWARD" ,0x2000|0x400,m_null,87,102 + 1*8,{&key_up},&mousebforward},
  {"BACKWARD" ,0x2000|0x400,m_null,87,102 + 2*8,{&key_down},&mousebbackward},
  {"TURN LEFT" ,0x2000|0x400,m_null,87,102 + 3*8,{&key_left}},
  {"TURN RIGHT" ,0x2000|0x400,m_null,87,102 + 4*8,{&key_right}},
  {"RUN" ,0x2000|0x400,m_null,87,102 + 5*8,{&key_speed},0,&joybspeed},
  {"STRAFE LEFT" ,0x2000|0x400,m_null,87,102 + 6*8,{&key_strafeleft}},
  {"STRAFE RIGHT",0x2000|0x400,m_null,87,102 + 7*8,{&key_straferight}},
  {"STRAFE" ,0x2000|0x400,m_null,87,102 + 8*8,{&key_strafe},&mousebstrafe,&joybstrafe},
  {"AUTORUN" ,0x2000|0x400,m_null,87,102 + 9*8,{&key_autorun}},
  {"180 TURN" ,0x2000|0x400,m_null,87,102 +10*8,{&key_reverse}},
  {"USE" ,0x2000|0x400,m_null,87,102 +11*8,{&key_use},&mousebuse,&joybuse},

  {"GAME" ,0x2000|0x4,m_null,172,2},
  {"SAVE" ,0x2000|0x400,m_null,172,2 + 1*8,{&key_savegame}},
  {"LOAD" ,0x2000|0x400,m_null,172,2 + 2*8,{&key_loadgame}},
  {"QUICKSAVE" ,0x2000|0x400,m_null,172,2 + 3*8,{&key_quicksave}},
  {"END GAME" ,0x2000|0x400,m_null,172,2 + 4*8,{&key_endgame}},
  {"QUICKLOAD" ,0x2000|0x400,m_null,172,2 + 5*8,{&key_quickload}},
  {"QUIT" ,0x2000|0x400,m_null,172,2 + 6*8,{&key_quit}},



  {0,0x2000|0x8000,m_null}
};







static void M_DrawString(int cx, int cy, int color, const char* ch)
{
  int w;
  int c;

  while (*ch) {
    c = *ch++;
    c = __extension__ ({ __typeof__ (c) __x = (c); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) - '!';
    if (c < 0 || c> ((0x7f) - '!' + 1))
      {
      cx += 4;
      continue;
      }
    w = hu_font[c].width;
    if (cx + w > 320)
      break;





    V_DrawNumPatch(cx, cy, 0, hu_font[c].lumpnum, color, VPT_STRETCH | VPT_TRANS);


    cx += w - 1;
  }
}



static void M_DrawMenuString(int cx, int cy, int color)
{
    M_DrawString(cx, cy, color, menu_buffer);
}




static int M_GetPixelWidth(const char* ch)
{
  int len = 0;
  int c;

  while (*ch) {
    c = *ch++;
    c = __extension__ ({ __typeof__ (c) __x = (c); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) - '!';
    if (c < 0 || c > ((0x7f) - '!' + 1))
      {
      len += 4;
      continue;
      }
    len += hu_font[c].width;
    len--;
  }
  len++;
  return len;
}

static void M_DrawStringCentered(int cx, int cy, int color, const char* ch)
{
    M_DrawString(cx - M_GetPixelWidth(ch)/2, cy, color, ch);
}






void M_DrawHelp (void)
{
  menuactive = mnact_full;

  M_DrawBackground("FLOOR4_6", 0);

  M_DrawScreenItems(helpstrings);
}






enum {
  prog,
  prog_stub,
  prog_stub1,
  prog_stub2,
  adcr
};

enum {
  cr_prog=0,
  cr_adcr=2,
};







setup_menu_t cred_settings[]={

  {"Programmers",0x2000|0x200000|0x100000,m_null, 20, 32 + 9*prog + 9*cr_prog},
  {"Florian 'Proff' Schulze",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(prog+1) + 9*cr_prog},
  {"Colin Phipps",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(prog+2) + 9*cr_prog},
  {"Neil Stevens",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(prog+3) + 9*cr_prog},
  {"Andrey Budko",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(prog+4) + 9*cr_prog},

  {"Additional Credit To",0x2000|0x200000|0x100000,m_null, 20, 32 + 9*adcr + 9*cr_adcr},
  {"id Software for DOOM",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+1)+9*cr_adcr},
  {"TeamTNT for BOOM",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+2)+9*cr_adcr},
  {"Lee Killough for MBF",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+3)+9*cr_adcr},
  {"The DOSDoom-Team for DOSDOOM",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+4)+9*cr_adcr},
  {"Randy Heit for ZDOOM",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+5)+9*cr_adcr},
  {"Michael 'Kodak' Ryssen for DOOMGL",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+6)+9*cr_adcr},
  {"Jess Haas for lSDLDoom",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+7) + 9*cr_adcr},
  {"all others who helped (see AUTHORS file)",0x2000|0x200000|0x100000,m_null, 50, 32 + 9*(adcr+8)+9*cr_adcr},

  {0,0x2000|0x8000,m_null}
};

void M_DrawCredits(void)
{
  inhelpscreens = 1;

  V_DrawBackground(gamemode==shareware ? "CEIL5_1" : "MFLR8_4", 0);
  M_DrawTitle(115, 9, "PRBOOM", CR_GOLD,
              "" " v" "", CR_GOLD);
  M_DrawScreenItems(cred_settings);
}

static int M_IndexInChoices(const char *str, const char **choices) {
  int i = 0;

  while (*choices != ((void *)0)) {
    if (!strcmp(str, *choices))
      return i;
    i++;
    choices++;
  }
  return 0;
}
# 4121 "c:/devl/prboom3ds/src/m_menu.c"
boolean M_Responder (event_t* ev) {
  int ch;
  int i;
  static int joywait = 0;
  static int mousewait = 0;
  static int mousey = 0;
  static int lasty = 0;
  static int mousex = 0;
  static int lastx = 0;

  ch = -1;



  if (ev->type == ev_joystick && joywait < I_GetTime()) {
    if (ev->data3 == -1)
      {
  ch = key_menu_up;
  joywait = I_GetTime() + 5;
      }
    else if (ev->data3 == 1)
      {
  ch = key_menu_down;
  joywait = I_GetTime() + 5;
      }

    if (ev->data2 == -1)
      {
  ch = key_menu_left;
  joywait = I_GetTime() + 2;
      }
    else if (ev->data2 == 1)
      {
  ch = key_menu_right;
  joywait = I_GetTime() + 2;
      }

    if (ev->data1&1)
      {
  ch = key_menu_enter;
  joywait = I_GetTime() + 5;
      }

    if (ev->data1&2)
      {
  ch = key_menu_backspace;
  joywait = I_GetTime() + 5;
      }





    if (setup_active && set_keybnd_active) {
      if (ev->data1&4) {
  ch = 0;
  joywait = I_GetTime() + 5;
      }
      if (ev->data1&8) {
  ch = 0;
  joywait = I_GetTime() + 5;
      }
    }

  } else {


    if (ev->type == ev_mouse && mousewait < I_GetTime()) {



      if (ev->data1&1)
  {
    ch = key_menu_enter;
    mousewait = I_GetTime() + 15;
  }

      if (ev->data1&2)
  {
    ch = key_menu_backspace;
    mousewait = I_GetTime() + 15;
  }





      if (setup_active && set_keybnd_active)
  if (ev->data1&4)
    {
    ch = 0;
    mousewait = I_GetTime() + 15;
    }
    }
    else



      if (ev->type == ev_keydown)
        {
        ch = ev->data1;
        if (ch == (0x80+0x36))
          shiftdown = 1;
        }
      else if (ev->type == ev_keyup)
        if (ev->data1 == (0x80+0x36))
          shiftdown = 0;
    }

  if (ch == -1)
    return 0;



  if (saveStringEnter) {
   if (ch == 8 || ch == key_menu_backspace)
   {
    if (saveCharIndex > 0)
    {
     saveCharIndex--;
     savegamestrings[saveSlot][saveCharIndex] = 0;
    }
   }
   else if (ch == key_menu_escape)
   {
    saveStringEnter = 0;
    strcpy(&savegamestrings[saveSlot][0], saveOldString);




   }
   else if (ch == 10 || ch == key_menu_enter)
   {
    saveStringEnter = 0;
    if (savegamestrings[saveSlot][0])
     M_DoSave(saveSlot);




   }
   else
   {
    ch = __extension__ ({ __typeof__ (ch) __x = (ch); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;});
    if (ch >= 32 && ch <= 127 &&
     saveCharIndex < 24 - 1 &&
     M_StringWidth(savegamestrings[saveSlot]) < (24 - 2) * 8)
    {
     savegamestrings[saveSlot][saveCharIndex++] = ch;
     savegamestrings[saveSlot][saveCharIndex] = 0;
    }
   }
   return 1;
  }



  if (messageToPrint) {
    if (messageNeedsInput == 1 &&
  !(ch == ' ' || ch == 'n' || ch == 'y' || ch == key_escape))
      return 0;

    menuactive = messageLastMenuActive;
    messageToPrint = 0;
    if (messageRoutine)
      messageRoutine(ch);

    menuactive = mnact_inactive;
    S_StartSound(((void *)0),sfx_swtchx);
    return 1;
  }




  if (ch == key_screenshot)
    {
    M_ScreenShot ();

    }



  if (!menuactive) {
    if (ch == key_autorun)
      {
      autorun = !autorun;
      return 1;
      }

    if (ch == key_help)
      {
      M_StartControlPanel ();

      currentMenu = &HelpDef;

      itemOn = 0;
      S_StartSound(((void *)0),sfx_swtchn);
      return 1;
      }

    if (ch == key_savegame)
      {
      M_StartControlPanel();
      S_StartSound(((void *)0),sfx_swtchn);
      M_SaveGame(0);
      return 1;
      }

    if (ch == key_loadgame)
      {
      M_StartControlPanel();
      S_StartSound(((void *)0),sfx_swtchn);
      M_LoadGame(0);
      return 1;
      }

    if (ch == key_soundvolume)
      {
      M_StartControlPanel ();
      currentMenu = &SoundDef;
      itemOn = sfx_vol;
      S_StartSound(((void *)0),sfx_swtchn);
      return 1;
      }

    if (ch == key_quicksave)
      {
      S_StartSound(((void *)0),sfx_swtchn);
      M_QuickSave();
      return 1;
      }

    if (ch == key_endgame)
      {
      S_StartSound(((void *)0),sfx_swtchn);
      M_EndGame(0);
      return 1;
      }

    if (ch == key_messages)
      {
      M_ChangeMessages(0);
      S_StartSound(((void *)0),sfx_swtchn);
      return 1;
      }

    if (ch == key_quickload)
      {
      S_StartSound(((void *)0),sfx_swtchn);
      M_QuickLoad();
      return 1;
      }

    if (ch == key_quit)
      {
      S_StartSound(((void *)0),sfx_swtchn);
      M_QuitDOOM(0);
      return 1;
      }

    if (ch == key_gamma)
      {
      usegamma++;
      if (usegamma > 4)
  usegamma = 0;
      players[consoleplayer].message =
  usegamma == 0 ? s_GAMMALVL0 :
  usegamma == 1 ? s_GAMMALVL1 :
  usegamma == 2 ? s_GAMMALVL2 :
  usegamma == 3 ? s_GAMMALVL3 :
  s_GAMMALVL4;
      V_SetPalette(0);
      return 1;
      }


    if (ch == key_zoomout)
      {
      if ((automapmode & am_active) || chat_on)
        return 0;
      M_SizeDisplay(0);
      S_StartSound(((void *)0),sfx_stnmov);
      return 1;
      }

    if (ch == key_zoomin)
      {
      if ((automapmode & am_active) || chat_on)
        return 0;
      M_SizeDisplay(1);
      S_StartSound(((void *)0),sfx_stnmov);
      return 1;
      }

    if (ch == key_hud)
      {
      if ((automapmode & am_active) || chat_on)
        return 0;
      if (screenSize<8)
        while (screenSize<8 || !hud_displayed)
          M_SizeDisplay(1);
      else
        {
        hud_displayed = 1;
        hud_active = (hud_active+1)%3;
        if (!hud_active)
          {
          hud_distributed = !hud_distributed;
          HU_MoveHud();
          }
        }
      return 1;
      }


    if (ch == key_setup) {
      M_StartControlPanel();
      S_StartSound(((void *)0),sfx_swtchn);
      M_SetupNextMenu(&SetupDef);
      return 1;
    }
  }


  if (!menuactive)
    {
    if (ch == key_escape)
      {
      M_StartControlPanel ();
      S_StartSound(((void *)0),sfx_swtchn);
      return 1;
      }
    return 0;
    }




  if (setup_active) {
    setup_menu_t* ptr1= current_setup_menu + set_menu_itemon;
    setup_menu_t* ptr2 = ((void *)0);





    if (default_verify)
      {
  if (__extension__ ({ __typeof__ (ch) __x = (ch); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) == 'Y') {
    M_ResetDefaults();
    default_verify = 0;
    M_SelectDone(ptr1);
  }
  else if (__extension__ ({ __typeof__ (ch) __x = (ch); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) == 'N') {
    default_verify = 0;
    M_SelectDone(ptr1);
  }
  return 1;
      }



      if (setup_select) {
  if (ch == key_menu_escape)
    {
    M_SelectDone(ptr1);
    setup_gather = 0;
    return 1;
    }

  if (ptr1->m_flags & 0x8)
    {
    if (ch == key_menu_enter) {
      *ptr1->var.def->location.pi = !*ptr1->var.def->location.pi;
# 4505 "c:/devl/prboom3ds/src/m_menu.c"
      if (ptr1->m_flags & (0x10000 | 0x20000))
        (warning_about_changes=(ptr1->m_flags & (0x10000 | 0x20000)), print_warning_about_changes = 2)
                                 ;
      else
        M_UpdateCurrent(ptr1->var.def);

      if (ptr1->action)
        ptr1->action();
    }
    M_SelectDone(ptr1);
    return 1;
    }

  if (ptr1->m_flags & 0x10)
    {
    if (ch != key_menu_enter)
      {
      ch -= 0x30;
      if (ch < 0 || ch > 9)
        return 1;
      *ptr1->var.def->location.pi = ch;
      }
    if (ptr1->action)
      ptr1->action();
    M_SelectDone(ptr1);
    return 1;
    }

  if (ptr1->m_flags & 0x1000)
    {
      if (setup_gather) {





        if (ch == key_menu_enter) {
    if (gather_count) {
      int value;

      gather_buffer[gather_count] = 0;
      value = atoi(gather_buffer);

      if ((ptr1->var.def->minvalue != (-123456789) &&
           value < ptr1->var.def->minvalue) ||
          (ptr1->var.def->maxvalue != (-123456789) &&
           value > ptr1->var.def->maxvalue))
        (warning_about_changes=(0x40000), print_warning_about_changes = 2);
      else {
        *ptr1->var.def->location.pi = value;




        if (ptr1->m_flags & (0x10000 | 0x20000))
          (warning_about_changes=(ptr1->m_flags & (0x10000 | 0x20000)), print_warning_about_changes = 2)
                                   ;
        else
          M_UpdateCurrent(ptr1->var.def);

        if (ptr1->action)
          ptr1->action();
      }
    }
    M_SelectDone(ptr1);
    setup_gather = 0;
    return 1;
        }

        if (ch == key_menu_backspace && gather_count) {
    gather_count--;
    return 1;
        }

        if (gather_count >= 5)
    return 1;

        if (!(((__ctype_ptr__+sizeof(""[ch]))[(int)(ch)])&04) && ch != '-')
    return 1;


        gather_buffer[gather_count++] = ch;
      }
      return 1;
    }

  if (ptr1->m_flags & 0x800000)
    {
    if (ch == key_menu_left) {
      if (ptr1->var.def->type == def_int) {
        int value = *ptr1->var.def->location.pi;

        value = value - 1;
        if ((ptr1->var.def->minvalue != (-123456789) &&
             value < ptr1->var.def->minvalue))
          value = ptr1->var.def->minvalue;
        if ((ptr1->var.def->maxvalue != (-123456789) &&
             value > ptr1->var.def->maxvalue))
          value = ptr1->var.def->maxvalue;
        if (*ptr1->var.def->location.pi != value)
          S_StartSound(((void *)0),sfx_pstop);
        *ptr1->var.def->location.pi = value;
      }
      if (ptr1->var.def->type == def_str) {
        int old_value, value;

        old_value = M_IndexInChoices(*ptr1->var.def->location.ppsz,
                                     ptr1->selectstrings);
        value = old_value - 1;
        if (value < 0)
          value = 0;
        if (old_value != value)
          S_StartSound(((void *)0),sfx_pstop);
        *ptr1->var.def->location.ppsz = ptr1->selectstrings[value];
      }
    }
    if (ch == key_menu_right) {
      if (ptr1->var.def->type == def_int) {
        int value = *ptr1->var.def->location.pi;

        value = value + 1;
        if ((ptr1->var.def->minvalue != (-123456789) &&
             value < ptr1->var.def->minvalue))
          value = ptr1->var.def->minvalue;
        if ((ptr1->var.def->maxvalue != (-123456789) &&
             value > ptr1->var.def->maxvalue))
          value = ptr1->var.def->maxvalue;
        if (*ptr1->var.def->location.pi != value)
          S_StartSound(((void *)0),sfx_pstop);
        *ptr1->var.def->location.pi = value;
      }
      if (ptr1->var.def->type == def_str) {
        int old_value, value;

        old_value = M_IndexInChoices(*ptr1->var.def->location.ppsz,
                                     ptr1->selectstrings);
        value = old_value + 1;
        if (ptr1->selectstrings[value] == ((void *)0))
          value = old_value;
        if (old_value != value)
          S_StartSound(((void *)0),sfx_pstop);
        *ptr1->var.def->location.ppsz = ptr1->selectstrings[value];
      }
    }
    if (ch == key_menu_enter) {







      if (ptr1->m_flags & (0x10000 | 0x20000))
        (warning_about_changes=(ptr1->m_flags & (0x10000 | 0x20000)), print_warning_about_changes = 2)
                                 ;
      else
        M_UpdateCurrent(ptr1->var.def);

      if (ptr1->action)
        ptr1->action();
      M_SelectDone(ptr1);
    }
    return 1;
    }

      }



      if (set_keybnd_active)
  if (setup_select)
    {
      if (ev->type == ev_joystick)
        {
    int oldbutton,group;
    boolean search = 1;

    if (!ptr1->m_joy)
      return 1;
# 4692 "c:/devl/prboom3ds/src/m_menu.c"
    oldbutton = *ptr1->m_joy;
    group = ptr1->m_group;
    if (ev->data1 & 1)
      ch = 0;
    else if (ev->data1 & 2)
      ch = 1;
    else if (ev->data1 & 4)
      ch = 2;
    else if (ev->data1 & 8)
      ch = 3;
    else
      return 1;
    for (i = 0 ; keys_settings[i] && search ; i++)
      for (ptr2 = keys_settings[i] ; !(ptr2->m_flags & 0x8000) ; ptr2++)
        if (ptr2->m_group == group && ptr1 != ptr2)
          if (ptr2->m_flags & 0x400 && ptr2->m_joy)
      if (*ptr2->m_joy == ch)
        {
          *ptr2->m_joy = oldbutton;
          search = 0;
          break;
        }
    *ptr1->m_joy = ch;
        }
      else if (ev->type == ev_mouse)
        {
    int i,oldbutton,group;
    boolean search = 1;

    if (!ptr1->m_mouse)
      return 1;
# 4731 "c:/devl/prboom3ds/src/m_menu.c"
    oldbutton = *ptr1->m_mouse;
    group = ptr1->m_group;
    if (ev->data1 & 1)
      ch = 0;
    else if (ev->data1 & 2)
      ch = 1;
    else if (ev->data1 & 4)
      ch = 2;
    else
      return 1;
    for (i = 0 ; keys_settings[i] && search ; i++)
      for (ptr2 = keys_settings[i] ; !(ptr2->m_flags & 0x8000) ; ptr2++)
        if (ptr2->m_group == group && ptr1 != ptr2)
          if (ptr2->m_flags & 0x400 && ptr2->m_mouse)
      if (*ptr2->m_mouse == ch)
        {
          *ptr2->m_mouse = oldbutton;
          search = 0;
          break;
        }
    *ptr1->m_mouse = ch;
        }
      else
        {
    int i,oldkey,group;
    boolean search = 1;
# 4770 "c:/devl/prboom3ds/src/m_menu.c"
    oldkey = *ptr1->var.m_key;
    group = ptr1->m_group;
    for (i = 0 ; keys_settings[i] && search ; i++)
      for (ptr2 = keys_settings[i] ; !(ptr2->m_flags & 0x8000) ; ptr2++)
        if (ptr2->m_flags & (0x400|0x4000) &&
      ptr2->m_group == group &&
      ptr1 != ptr2)
          if (*ptr2->var.m_key == ch)
      {
        if (ptr2->m_flags & 0x4000)
          return 1;
        *ptr2->var.m_key = oldkey;
        search = 0;
        break;
      }
    *ptr1->var.m_key = ch;
        }

      M_SelectDone(ptr1);
      return 1;
    }



      if (set_weapon_active)
  if (setup_select)
    {
      if (ch != key_menu_enter)
        {
    ch -= '0';
    if (ch < 1 || ch > 9)
      return 1;
# 4812 "c:/devl/prboom3ds/src/m_menu.c"
    for (i = 0; (ptr2 = weap_settings[i]); i++)
      for (; !(ptr2->m_flags & 0x8000); ptr2++)
        if (ptr2->m_flags & 0x800 &&
      *ptr2->var.def->location.pi == ch && ptr1 != ptr2)
          {
      *ptr2->var.def->location.pi = *ptr1->var.def->location.pi;
      goto end;
          }
        end:
    *ptr1->var.def->location.pi = ch;
        }

      M_SelectDone(ptr1);
      return 1;
    }



      if (set_auto_active)
  if (setup_select)
    {
      if (ch == key_menu_down)
        {
    if (++color_palette_y == 16)
      color_palette_y = 0;
    S_StartSound(((void *)0),sfx_itemup);
    return 1;
        }

      if (ch == key_menu_up)
        {
    if (--color_palette_y < 0)
      color_palette_y = 15;
    S_StartSound(((void *)0),sfx_itemup);
    return 1;
        }

      if (ch == key_menu_left)
        {
    if (--color_palette_x < 0)
      color_palette_x = 15;
    S_StartSound(((void *)0),sfx_itemup);
    return 1;
        }

      if (ch == key_menu_right)
        {
    if (++color_palette_x == 16)
      color_palette_x = 0;
    S_StartSound(((void *)0),sfx_itemup);
    return 1;
        }

      if (ch == key_menu_enter)
        {
    *ptr1->var.def->location.pi = color_palette_x + 16*color_palette_y;
    M_SelectDone(ptr1);
    colorbox_active = 0;
    return 1;
        }
    }


      if (setup_select &&
    set_enemy_active | set_general_active | set_chat_active |
    set_mess_active | set_status_active | set_compat_active)
  {
    if (ptr1->m_flags & (0x40|0x80000))
      {
        if (ch == key_menu_backspace)
    {
      if (chat_string_buffer[chat_index] == 0)
        {
          if (chat_index > 0)
      chat_string_buffer[--chat_index] = 0;
        }

      else
        strcpy(&chat_string_buffer[chat_index],
         &chat_string_buffer[chat_index+1]);
    }
        else if (ch == key_menu_left)
    {
      if (chat_index > 0)
        chat_index--;
    }
        else if (ch == key_menu_right)
    {
      if (chat_string_buffer[chat_index] != 0)
        chat_index++;
    }
        else if ((ch == key_menu_enter) ||
           (ch == key_menu_escape))
    {
      *ptr1->var.def->location.ppsz = chat_string_buffer;
      M_SelectDone(ptr1);
    }






        else if ((ch >= 32) && (ch <= 126))
    if ((chat_index+1) < 128)
      {
        if (shiftdown)
          ch = shiftxform[ch];
        if (chat_string_buffer[chat_index] == 0)
          {
      chat_string_buffer[chat_index++] = ch;
      chat_string_buffer[chat_index] = 0;
          }
        else
          chat_string_buffer[chat_index++] = ch;
      }
        return 1;
      }

    M_SelectDone(ptr1);
    return 1;
  }




      if (ch == key_menu_down)
  {
    ptr1->m_flags &= ~0x1;
    do
      if (ptr1->m_flags & 0x8000)
        {
    set_menu_itemon = 0;
    ptr1 = current_setup_menu;
        }
      else
        {
    set_menu_itemon++;
    ptr1++;
        }
    while (ptr1->m_flags & 0x2000);
    M_SelectDone(ptr1);
    return 1;
  }

      if (ch == key_menu_up)
  {
    ptr1->m_flags &= ~0x1;
    do
      {
        if (set_menu_itemon == 0)
    do
      set_menu_itemon++;
    while(!((current_setup_menu + set_menu_itemon)->m_flags & 0x8000));
        set_menu_itemon--;
      }
    while((current_setup_menu + set_menu_itemon)->m_flags & 0x2000);
    M_SelectDone(current_setup_menu + set_menu_itemon);
    return 1;
  }

      if (ch == key_menu_enter)
  {
    int flags = ptr1->m_flags;







    if (flags & 0x1000)
      {
        setup_gather = 1;
        print_warning_about_changes = 0;
        gather_count = 0;
      }
    else if (flags & 0x20)
      {
        int color = *ptr1->var.def->location.pi;

        if (color < 0 || color > 255)
    color = 0;

        color_palette_x = *ptr1->var.def->location.pi & 15;
        color_palette_y = *ptr1->var.def->location.pi >> 4;
        colorbox_active = 1;
      }
    else if (flags & (0x40|0x80000))
      {






        chat_string_buffer = Z_Malloc(128,PU_STATIC,0);
        strncpy(chat_string_buffer,
          *ptr1->var.def->location.ppsz, 128);


        chat_string_buffer[128 -1] = 0;



        {
          union { const char **c; char **s; } u;

          u.c = ptr1->var.def->location.ppsz;
          Z_Free(*(u.s));
          *(u.c) = chat_string_buffer;
        }
        chat_index = 0;
      }
    else if (flags & 0x80)
      default_verify = 1;

    ptr1->m_flags |= 0x2;
    setup_select = 1;
    S_StartSound(((void *)0),sfx_itemup);
    return 1;
  }

      if ((ch == key_menu_escape) || (ch == key_menu_backspace))
  {
    if (ch == key_menu_escape)
      M_ClearMenus();
    else
      if (currentMenu->prevMenu)
        {
    currentMenu = currentMenu->prevMenu;
    itemOn = currentMenu->lastOn;
    S_StartSound(((void *)0),sfx_swtchn);
        }
    ptr1->m_flags &= ~(0x1|0x2);
    setup_active = 0;
    set_keybnd_active = 0;
    set_weapon_active = 0;
    set_status_active = 0;
    set_auto_active = 0;
    set_enemy_active = 0;
    set_mess_active = 0;
    set_chat_active = 0;
    colorbox_active = 0;
    default_verify = 0;
    set_general_active = 0;
          set_compat_active = 0;
    HU_Start();
    S_StartSound(((void *)0),sfx_swtchx);
    return 1;
  }
# 5071 "c:/devl/prboom3ds/src/m_menu.c"
      if (ch == key_menu_left)
  {
    ptr2 = ptr1;
    do
      {
        ptr2++;
        if (ptr2->m_flags & 0x100)
    {
      ptr1->m_flags &= ~0x1;
      mult_screens_index--;
      current_setup_menu = ptr2->var.menu;
      set_menu_itemon = 0;
      print_warning_about_changes = 0;
      while (current_setup_menu[set_menu_itemon++].m_flags&0x2000);
      current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
      S_StartSound(((void *)0),sfx_pstop);
      return 1;
    }
      }
    while (!(ptr2->m_flags & 0x8000));
  }

      if (ch == key_menu_right)
  {
    ptr2 = ptr1;
    do
      {
        ptr2++;
        if (ptr2->m_flags & 0x200)
    {
      ptr1->m_flags &= ~0x1;
      mult_screens_index++;
      current_setup_menu = ptr2->var.menu;
      set_menu_itemon = 0;
      print_warning_about_changes = 0;
      while (current_setup_menu[set_menu_itemon++].m_flags&0x2000);
      current_setup_menu[--set_menu_itemon].m_flags |= 0x1;
      S_StartSound(((void *)0),sfx_pstop);
      return 1;
    }
      }
    while (!(ptr2->m_flags & 0x8000));
  }

    }




  if (ch == key_menu_down)
    {
      do
  {
    if (itemOn+1 > currentMenu->numitems-1)
      itemOn = 0;
    else
      itemOn++;
    S_StartSound(((void *)0),sfx_pstop);
  }
      while(currentMenu->menuitems[itemOn].status==-1);
      return 1;
    }

  if (ch == key_menu_up)
    {
      do
  {
    if (!itemOn)
      itemOn = currentMenu->numitems-1;
    else
      itemOn--;
    S_StartSound(((void *)0),sfx_pstop);
  }
      while(currentMenu->menuitems[itemOn].status==-1);
      return 1;
    }

  if (ch == key_menu_left)
    {
      if (currentMenu->menuitems[itemOn].routine &&
    currentMenu->menuitems[itemOn].status == 2)
  {
    S_StartSound(((void *)0),sfx_stnmov);
    currentMenu->menuitems[itemOn].routine(0);
  }
      return 1;
    }

  if (ch == key_menu_right)
    {
      if (currentMenu->menuitems[itemOn].routine &&
    currentMenu->menuitems[itemOn].status == 2)
  {
    S_StartSound(((void *)0),sfx_stnmov);
    currentMenu->menuitems[itemOn].routine(1);
  }
      return 1;
    }

  if (ch == key_menu_enter)
    {
      if (currentMenu->menuitems[itemOn].routine &&
    currentMenu->menuitems[itemOn].status)
  {
    currentMenu->lastOn = itemOn;
    if (currentMenu->menuitems[itemOn].status == 2)
      {
        currentMenu->menuitems[itemOn].routine(1);
        S_StartSound(((void *)0),sfx_stnmov);
      }
    else
      {
        currentMenu->menuitems[itemOn].routine(itemOn);
        S_StartSound(((void *)0),sfx_pistol);
      }
  }


      return 1;
    }

  if (ch == key_menu_escape)
    {
      currentMenu->lastOn = itemOn;
      M_ClearMenus ();
      S_StartSound(((void *)0),sfx_swtchx);
      return 1;
    }

  if (ch == key_menu_backspace)
    {
      currentMenu->lastOn = itemOn;







      if (currentMenu->prevMenu)
  {
    if (currentMenu == &ExtHelpDef)
      {
        if (--extended_help_index == 0)
    {
      currentMenu = currentMenu->prevMenu;
      extended_help_index = 1;
    }
      }
    else
      currentMenu = currentMenu->prevMenu;
    itemOn = currentMenu->lastOn;
    S_StartSound(((void *)0),sfx_swtchn);
  }
      return 1;
    }

  else
    {
      for (i = itemOn+1;i < currentMenu->numitems;i++)
  if (currentMenu->menuitems[i].alphaKey == ch)
    {
      itemOn = i;
      S_StartSound(((void *)0),sfx_pstop);
      return 1;
    }
      for (i = 0;i <= itemOn;i++)
  if (currentMenu->menuitems[i].alphaKey == ch)
    {
      itemOn = i;
      S_StartSound(((void *)0),sfx_pstop);
      return 1;
    }
    }
  return 0;
}
# 5261 "c:/devl/prboom3ds/src/m_menu.c"
void M_StartControlPanel (void)
{


  if (menuactive)
    return;
# 5275 "c:/devl/prboom3ds/src/m_menu.c"
  NewDef.lastOn = defaultskill - 1;

  default_verify = 0;
  menuactive = mnact_float;
  currentMenu = &MainDef;
  itemOn = currentMenu->lastOn;
  print_warning_about_changes = 0;
}
# 5292 "c:/devl/prboom3ds/src/m_menu.c"
void M_Drawer (void)
{
  inhelpscreens = 0;



  if (messageToPrint)
    {

      char *ms = Z_Strdup(messageString,PU_STATIC,0);
      char *p = ms;

      int y = 100 - M_StringHeight(messageString)/2;
      while (*p)
      {
        char *string = p, c;
        while ((c = *p) && *p != '\n')
          p++;
        *p = 0;
        M_WriteText(160 - M_StringWidth(string)/2, y, string, CR_RED);
        y += hu_font[0].height;
        if ((*p = c))
          p++;
      }
      Z_Free(ms);
    }
  else
    if (menuactive)
      {
  int x,y,max,i;
  int lumps_missing = 0;

  menuactive = mnact_float;

  if (currentMenu->routine)
    currentMenu->routine();



  x = currentMenu->x;
  y = currentMenu->y;
  max = currentMenu->numitems;

  for (i = 0; i < max; i++)
    if (currentMenu->menuitems[i].name[0])
      if ((W_CheckNumForName)(currentMenu->menuitems[i].name, ns_global) < 0)
        lumps_missing++;

  if (lumps_missing == 0)
    for (i=0;i<max;i++)
    {
      if (currentMenu->menuitems[i].name[0])
        V_DrawNumPatch(x,y,0,W_GetNumForName(currentMenu->menuitems[i].name),CR_RED,VPT_STRETCH)
                                    ;
      y += 16;
    }
  else
    for (i = 0; i < max; i++)
    {
      const char *alttext = currentMenu->menuitems[i].alttext;
      if (alttext)
        M_WriteText(x, y+8-(M_StringHeight(alttext)/2), alttext, CR_RED);
      y += 16;
    }




  V_DrawNumPatch(x + -32,currentMenu->y - 5 + itemOn*16,0,W_GetNumForName(skullName[whichSkull]),CR_RED,VPT_STRETCH)
                                                     ;
      }
}






void M_ClearMenus (void)
{
  menuactive = mnact_inactive;
  print_warning_about_changes = 0;
  default_verify = 0;



}




void M_SetupNextMenu(menu_t *menudef)
{
  currentMenu = menudef;
  itemOn = currentMenu->lastOn;
}





void M_Ticker (void)
{
  if (--skullAnimCounter <= 0)
    {
      whichSkull ^= 1;
      skullAnimCounter = 8;
    }
}






void M_StartMessage (const char* string,void* routine,boolean input)
{
  messageLastMenuActive = menuactive;
  messageToPrint = 1;
  messageString = string;
  messageRoutine = routine;
  messageNeedsInput = input;
  menuactive = mnact_float;
  return;
}

void M_StopMessage(void)
{
  menuactive = messageLastMenuActive;
  messageToPrint = 0;
}
# 5436 "c:/devl/prboom3ds/src/m_menu.c"
void M_DrawThermo(int x,int y,int thermWidth,int thermDot )
{
  int xx;
  int i;
# 5448 "c:/devl/prboom3ds/src/m_menu.c"
  int horizScaler;
  thermWidth = (thermWidth > 200) ? 200 : thermWidth;
  horizScaler = (thermWidth > 23) ? (200 / thermWidth) : 8;
  xx = x;
  V_DrawNumPatch(xx,y,0,W_GetNumForName("M_THERML"),CR_RED,VPT_STRETCH);
  xx += 8;
  for (i=0;i<thermWidth;i++)
    {
    V_DrawNumPatch(xx,y,0,W_GetNumForName("M_THERMM"),CR_RED,VPT_STRETCH);
    xx += horizScaler;
    }

  xx += (8 - horizScaler);

  V_DrawNumPatch(xx,y,0,W_GetNumForName("M_THERMR"),CR_RED,VPT_STRETCH);
  V_DrawNumPatch((x+8)+thermDot*horizScaler,y,0,W_GetNumForName("M_THERMO"),CR_RED,VPT_STRETCH);
}





void M_DrawEmptyCell (menu_t* menu,int item)
{

  V_DrawNumPatch(menu->x - 10,menu->y+item*16 - 1,0,W_GetNumForName("M_CELL1"),CR_RED,VPT_STRETCH)
                                         ;
}





void M_DrawSelCell (menu_t* menu,int item)
{

  V_DrawNumPatch(menu->x - 10,menu->y+item*16 - 1,0,W_GetNumForName("M_CELL2"),CR_RED,VPT_STRETCH)
                                         ;
}
# 5497 "c:/devl/prboom3ds/src/m_menu.c"
int M_StringWidth(const char* string)
{
  int i, c, w = 0;
  for (i = 0;(size_t)i < strlen(string);i++)
    w += (c = __extension__ ({ __typeof__ (string[i]) __x = (string[i]); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) - '!') < 0 || c >= ((0x7f) - '!' + 1) ?
      4 : hu_font[c].width;
  return w;
}





int M_StringHeight(const char* string)
{
  int i, h, height = h = hu_font[0].height;
  for (i = 0;string[i];i++)
    if (string[i] == '\n')
      h += height;
  return h;
}




void M_WriteText (int x,int y, const char* string, int cm)
{
  int w;
  const char* ch;
  int c;
  int cx;
  int cy;
  int flags;

  ch = string;
  cx = x;
  cy = y;

  flags = VPT_STRETCH;
  if (cm != CR_RED)
    flags |= VPT_TRANS;

  while(1) {
    c = *ch++;
    if (!c)
      break;
    if (c == '\n') {
      cx = x;
      cy += 12;
      continue;
    }

    c = __extension__ ({ __typeof__ (c) __x = (c); ((((__ctype_ptr__+sizeof(""[__x]))[(int)(__x)])&(01|02))==02) ? (int) __x - 'a' + 'A' : (int) __x;}) - '!';
    if (c < 0 || c>= ((0x7f) - '!' + 1)) {
      cx += 4;
      continue;
    }

    w = hu_font[c].width;
    if (cx+w > SCREENWIDTH)
      break;


    V_DrawNumPatch(cx, cy, 0, hu_font[c].lumpnum, cm, flags);
    cx+=w;
  }
}

void M_DrawTitle(int x, int y, const char *patch, int cm,
                 const char *alttext, int altcm)
{
  int lumpnum = (W_CheckNumForName)(patch, ns_global);

  if (lumpnum >= 0)
  {
    int flags = VPT_STRETCH;
    if (cm != CR_RED)
      flags |= VPT_TRANS;
    V_DrawNumPatch(x, y, 0, lumpnum, cm, flags);
  }
  else
  {

    M_WriteText(160-(M_StringWidth(alttext)/2),
                y+8-(M_StringHeight(alttext)/2),
                alttext, altcm);
  }
}
# 5595 "c:/devl/prboom3ds/src/m_menu.c"
void M_InitHelpScreen(void)
{
  setup_menu_t* src;

  src = helpstrings;
  while (!(src->m_flags & 0x8000)) {

    if ((strncmp(src->m_text,"PLASMA",6) == 0) && (gamemode == shareware))
      src->m_flags = 0x2000;
    if ((strncmp(src->m_text,"BFG",3) == 0) && (gamemode == shareware))
      src->m_flags = 0x2000;
    if ((strncmp(src->m_text,"SSG",3) == 0) && (gamemode != commercial))
      src->m_flags = 0x2000;
    src++;
  }
}




void M_Init(void)
{
  M_InitDefaults();
  currentMenu = &MainDef;
  menuactive = mnact_inactive;
  itemOn = currentMenu->lastOn;
  whichSkull = 0;
  skullAnimCounter = 10;
  screenSize = screenblocks - 3;
  messageToPrint = 0;
  messageString = ((void *)0);
  messageLastMenuActive = menuactive;
  quickSaveSlot = -1;




  switch(gamemode)
    {
    case commercial:



      MainMenu[readthis] = MainMenu[quitdoom];
      MainDef.numitems--;
      MainDef.y += 8;
      NewDef.prevMenu = &MainDef;
      ReadDef1.routine = M_DrawReadThis1;
      ReadDef1.x = 330;
      ReadDef1.y = 165;
      ReadMenu1[0].routine = M_FinishReadThis;
      break;
    case registered:





      ReadDef2.y = 15;

    case shareware:

      EpiDef.numitems--;
      break;
    case retail:

    default:
      break;
    }

  M_InitHelpScreen();
  M_InitExtendedHelp();

  M_ChangeDemoSmoothTurns();
}
